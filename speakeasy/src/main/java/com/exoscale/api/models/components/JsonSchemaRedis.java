/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.exoscale.api.models.components;

import com.exoscale.api.utils.LazySingletonValue;
import com.exoscale.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class JsonSchemaRedis {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ssl")
    private Optional<? extends Boolean> ssl;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lfu_log_factor")
    private Optional<? extends Long> lfuLogFactor;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maxmemory_policy")
    private JsonNullable<? extends RedisMaxmemoryPolicy> maxmemoryPolicy;

    /**
     * Set Redis IO thread count. Changing this will cause a restart of the Redis service.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("io_threads")
    private Optional<? extends Long> ioThreads;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lfu_decay_time")
    private Optional<? extends Long> lfuDecayTime;

    /**
     * Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pubsub_client_output_buffer_limit")
    private Optional<? extends Long> pubsubClientOutputBufferLimit;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("notify_keyspace_events")
    private Optional<? extends String> notifyKeyspaceEvents;

    /**
     * When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is 'off', no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("persistence")
    private Optional<? extends RedisPersistence> persistence;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timeout")
    private Optional<? extends Long> timeout;

    /**
     * Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("acl_channels_default")
    private Optional<? extends DefaultACLForPubSubChannelsUsedWhenRedisUserIsCreated> aclChannelsDefault;

    /**
     * Set number of Redis databases. Changing this will cause a restart of the Redis service.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("number_of_databases")
    private Optional<? extends Long> numberOfDatabases;

    public JsonSchemaRedis(
            @JsonProperty("ssl") Optional<? extends Boolean> ssl,
            @JsonProperty("lfu_log_factor") Optional<? extends Long> lfuLogFactor,
            @JsonProperty("maxmemory_policy") JsonNullable<? extends RedisMaxmemoryPolicy> maxmemoryPolicy,
            @JsonProperty("io_threads") Optional<? extends Long> ioThreads,
            @JsonProperty("lfu_decay_time") Optional<? extends Long> lfuDecayTime,
            @JsonProperty("pubsub_client_output_buffer_limit") Optional<? extends Long> pubsubClientOutputBufferLimit,
            @JsonProperty("notify_keyspace_events") Optional<? extends String> notifyKeyspaceEvents,
            @JsonProperty("persistence") Optional<? extends RedisPersistence> persistence,
            @JsonProperty("timeout") Optional<? extends Long> timeout,
            @JsonProperty("acl_channels_default") Optional<? extends DefaultACLForPubSubChannelsUsedWhenRedisUserIsCreated> aclChannelsDefault,
            @JsonProperty("number_of_databases") Optional<? extends Long> numberOfDatabases) {
        Utils.checkNotNull(ssl, "ssl");
        Utils.checkNotNull(lfuLogFactor, "lfuLogFactor");
        Utils.checkNotNull(maxmemoryPolicy, "maxmemoryPolicy");
        Utils.checkNotNull(ioThreads, "ioThreads");
        Utils.checkNotNull(lfuDecayTime, "lfuDecayTime");
        Utils.checkNotNull(pubsubClientOutputBufferLimit, "pubsubClientOutputBufferLimit");
        Utils.checkNotNull(notifyKeyspaceEvents, "notifyKeyspaceEvents");
        Utils.checkNotNull(persistence, "persistence");
        Utils.checkNotNull(timeout, "timeout");
        Utils.checkNotNull(aclChannelsDefault, "aclChannelsDefault");
        Utils.checkNotNull(numberOfDatabases, "numberOfDatabases");
        this.ssl = ssl;
        this.lfuLogFactor = lfuLogFactor;
        this.maxmemoryPolicy = maxmemoryPolicy;
        this.ioThreads = ioThreads;
        this.lfuDecayTime = lfuDecayTime;
        this.pubsubClientOutputBufferLimit = pubsubClientOutputBufferLimit;
        this.notifyKeyspaceEvents = notifyKeyspaceEvents;
        this.persistence = persistence;
        this.timeout = timeout;
        this.aclChannelsDefault = aclChannelsDefault;
        this.numberOfDatabases = numberOfDatabases;
    }

    public Optional<? extends Boolean> ssl() {
        return ssl;
    }

    public Optional<? extends Long> lfuLogFactor() {
        return lfuLogFactor;
    }

    public JsonNullable<? extends RedisMaxmemoryPolicy> maxmemoryPolicy() {
        return maxmemoryPolicy;
    }

    /**
     * Set Redis IO thread count. Changing this will cause a restart of the Redis service.
     */
    public Optional<? extends Long> ioThreads() {
        return ioThreads;
    }

    public Optional<? extends Long> lfuDecayTime() {
        return lfuDecayTime;
    }

    /**
     * Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
     */
    public Optional<? extends Long> pubsubClientOutputBufferLimit() {
        return pubsubClientOutputBufferLimit;
    }

    public Optional<? extends String> notifyKeyspaceEvents() {
        return notifyKeyspaceEvents;
    }

    /**
     * When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is 'off', no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
     */
    public Optional<? extends RedisPersistence> persistence() {
        return persistence;
    }

    public Optional<? extends Long> timeout() {
        return timeout;
    }

    /**
     * Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.
     */
    public Optional<? extends DefaultACLForPubSubChannelsUsedWhenRedisUserIsCreated> aclChannelsDefault() {
        return aclChannelsDefault;
    }

    /**
     * Set number of Redis databases. Changing this will cause a restart of the Redis service.
     */
    public Optional<? extends Long> numberOfDatabases() {
        return numberOfDatabases;
    }

    public final static Builder builder() {
        return new Builder();
    }

    public JsonSchemaRedis withSsl(boolean ssl) {
        Utils.checkNotNull(ssl, "ssl");
        this.ssl = Optional.ofNullable(ssl);
        return this;
    }

    public JsonSchemaRedis withSsl(Optional<? extends Boolean> ssl) {
        Utils.checkNotNull(ssl, "ssl");
        this.ssl = ssl;
        return this;
    }

    public JsonSchemaRedis withLfuLogFactor(long lfuLogFactor) {
        Utils.checkNotNull(lfuLogFactor, "lfuLogFactor");
        this.lfuLogFactor = Optional.ofNullable(lfuLogFactor);
        return this;
    }

    public JsonSchemaRedis withLfuLogFactor(Optional<? extends Long> lfuLogFactor) {
        Utils.checkNotNull(lfuLogFactor, "lfuLogFactor");
        this.lfuLogFactor = lfuLogFactor;
        return this;
    }

    public JsonSchemaRedis withMaxmemoryPolicy(RedisMaxmemoryPolicy maxmemoryPolicy) {
        Utils.checkNotNull(maxmemoryPolicy, "maxmemoryPolicy");
        this.maxmemoryPolicy = JsonNullable.of(maxmemoryPolicy);
        return this;
    }

    public JsonSchemaRedis withMaxmemoryPolicy(JsonNullable<? extends RedisMaxmemoryPolicy> maxmemoryPolicy) {
        Utils.checkNotNull(maxmemoryPolicy, "maxmemoryPolicy");
        this.maxmemoryPolicy = maxmemoryPolicy;
        return this;
    }

    /**
     * Set Redis IO thread count. Changing this will cause a restart of the Redis service.
     */
    public JsonSchemaRedis withIoThreads(long ioThreads) {
        Utils.checkNotNull(ioThreads, "ioThreads");
        this.ioThreads = Optional.ofNullable(ioThreads);
        return this;
    }

    /**
     * Set Redis IO thread count. Changing this will cause a restart of the Redis service.
     */
    public JsonSchemaRedis withIoThreads(Optional<? extends Long> ioThreads) {
        Utils.checkNotNull(ioThreads, "ioThreads");
        this.ioThreads = ioThreads;
        return this;
    }

    public JsonSchemaRedis withLfuDecayTime(long lfuDecayTime) {
        Utils.checkNotNull(lfuDecayTime, "lfuDecayTime");
        this.lfuDecayTime = Optional.ofNullable(lfuDecayTime);
        return this;
    }

    public JsonSchemaRedis withLfuDecayTime(Optional<? extends Long> lfuDecayTime) {
        Utils.checkNotNull(lfuDecayTime, "lfuDecayTime");
        this.lfuDecayTime = lfuDecayTime;
        return this;
    }

    /**
     * Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
     */
    public JsonSchemaRedis withPubsubClientOutputBufferLimit(long pubsubClientOutputBufferLimit) {
        Utils.checkNotNull(pubsubClientOutputBufferLimit, "pubsubClientOutputBufferLimit");
        this.pubsubClientOutputBufferLimit = Optional.ofNullable(pubsubClientOutputBufferLimit);
        return this;
    }

    /**
     * Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
     */
    public JsonSchemaRedis withPubsubClientOutputBufferLimit(Optional<? extends Long> pubsubClientOutputBufferLimit) {
        Utils.checkNotNull(pubsubClientOutputBufferLimit, "pubsubClientOutputBufferLimit");
        this.pubsubClientOutputBufferLimit = pubsubClientOutputBufferLimit;
        return this;
    }

    public JsonSchemaRedis withNotifyKeyspaceEvents(String notifyKeyspaceEvents) {
        Utils.checkNotNull(notifyKeyspaceEvents, "notifyKeyspaceEvents");
        this.notifyKeyspaceEvents = Optional.ofNullable(notifyKeyspaceEvents);
        return this;
    }

    public JsonSchemaRedis withNotifyKeyspaceEvents(Optional<? extends String> notifyKeyspaceEvents) {
        Utils.checkNotNull(notifyKeyspaceEvents, "notifyKeyspaceEvents");
        this.notifyKeyspaceEvents = notifyKeyspaceEvents;
        return this;
    }

    /**
     * When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is 'off', no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
     */
    public JsonSchemaRedis withPersistence(RedisPersistence persistence) {
        Utils.checkNotNull(persistence, "persistence");
        this.persistence = Optional.ofNullable(persistence);
        return this;
    }

    /**
     * When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is 'off', no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
     */
    public JsonSchemaRedis withPersistence(Optional<? extends RedisPersistence> persistence) {
        Utils.checkNotNull(persistence, "persistence");
        this.persistence = persistence;
        return this;
    }

    public JsonSchemaRedis withTimeout(long timeout) {
        Utils.checkNotNull(timeout, "timeout");
        this.timeout = Optional.ofNullable(timeout);
        return this;
    }

    public JsonSchemaRedis withTimeout(Optional<? extends Long> timeout) {
        Utils.checkNotNull(timeout, "timeout");
        this.timeout = timeout;
        return this;
    }

    /**
     * Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.
     */
    public JsonSchemaRedis withAclChannelsDefault(DefaultACLForPubSubChannelsUsedWhenRedisUserIsCreated aclChannelsDefault) {
        Utils.checkNotNull(aclChannelsDefault, "aclChannelsDefault");
        this.aclChannelsDefault = Optional.ofNullable(aclChannelsDefault);
        return this;
    }

    /**
     * Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.
     */
    public JsonSchemaRedis withAclChannelsDefault(Optional<? extends DefaultACLForPubSubChannelsUsedWhenRedisUserIsCreated> aclChannelsDefault) {
        Utils.checkNotNull(aclChannelsDefault, "aclChannelsDefault");
        this.aclChannelsDefault = aclChannelsDefault;
        return this;
    }

    /**
     * Set number of Redis databases. Changing this will cause a restart of the Redis service.
     */
    public JsonSchemaRedis withNumberOfDatabases(long numberOfDatabases) {
        Utils.checkNotNull(numberOfDatabases, "numberOfDatabases");
        this.numberOfDatabases = Optional.ofNullable(numberOfDatabases);
        return this;
    }

    /**
     * Set number of Redis databases. Changing this will cause a restart of the Redis service.
     */
    public JsonSchemaRedis withNumberOfDatabases(Optional<? extends Long> numberOfDatabases) {
        Utils.checkNotNull(numberOfDatabases, "numberOfDatabases");
        this.numberOfDatabases = numberOfDatabases;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        JsonSchemaRedis other = (JsonSchemaRedis) o;
        return 
            java.util.Objects.deepEquals(this.ssl, other.ssl) &&
            java.util.Objects.deepEquals(this.lfuLogFactor, other.lfuLogFactor) &&
            java.util.Objects.deepEquals(this.maxmemoryPolicy, other.maxmemoryPolicy) &&
            java.util.Objects.deepEquals(this.ioThreads, other.ioThreads) &&
            java.util.Objects.deepEquals(this.lfuDecayTime, other.lfuDecayTime) &&
            java.util.Objects.deepEquals(this.pubsubClientOutputBufferLimit, other.pubsubClientOutputBufferLimit) &&
            java.util.Objects.deepEquals(this.notifyKeyspaceEvents, other.notifyKeyspaceEvents) &&
            java.util.Objects.deepEquals(this.persistence, other.persistence) &&
            java.util.Objects.deepEquals(this.timeout, other.timeout) &&
            java.util.Objects.deepEquals(this.aclChannelsDefault, other.aclChannelsDefault) &&
            java.util.Objects.deepEquals(this.numberOfDatabases, other.numberOfDatabases);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            ssl,
            lfuLogFactor,
            maxmemoryPolicy,
            ioThreads,
            lfuDecayTime,
            pubsubClientOutputBufferLimit,
            notifyKeyspaceEvents,
            persistence,
            timeout,
            aclChannelsDefault,
            numberOfDatabases);
    }
    
    @Override
    public String toString() {
        return Utils.toString(JsonSchemaRedis.class,
                "ssl", ssl,
                "lfuLogFactor", lfuLogFactor,
                "maxmemoryPolicy", maxmemoryPolicy,
                "ioThreads", ioThreads,
                "lfuDecayTime", lfuDecayTime,
                "pubsubClientOutputBufferLimit", pubsubClientOutputBufferLimit,
                "notifyKeyspaceEvents", notifyKeyspaceEvents,
                "persistence", persistence,
                "timeout", timeout,
                "aclChannelsDefault", aclChannelsDefault,
                "numberOfDatabases", numberOfDatabases);
    }
    
    public final static class Builder {
 
        private Optional<? extends Boolean> ssl;
 
        private Optional<? extends Long> lfuLogFactor;
 
        private JsonNullable<? extends RedisMaxmemoryPolicy> maxmemoryPolicy;
 
        private Optional<? extends Long> ioThreads = Optional.empty();
 
        private Optional<? extends Long> lfuDecayTime;
 
        private Optional<? extends Long> pubsubClientOutputBufferLimit = Optional.empty();
 
        private Optional<? extends String> notifyKeyspaceEvents;
 
        private Optional<? extends RedisPersistence> persistence = Optional.empty();
 
        private Optional<? extends Long> timeout;
 
        private Optional<? extends DefaultACLForPubSubChannelsUsedWhenRedisUserIsCreated> aclChannelsDefault = Optional.empty();
 
        private Optional<? extends Long> numberOfDatabases = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        public Builder ssl(boolean ssl) {
            Utils.checkNotNull(ssl, "ssl");
            this.ssl = Optional.ofNullable(ssl);
            return this;
        }

        public Builder ssl(Optional<? extends Boolean> ssl) {
            Utils.checkNotNull(ssl, "ssl");
            this.ssl = ssl;
            return this;
        }

        public Builder lfuLogFactor(long lfuLogFactor) {
            Utils.checkNotNull(lfuLogFactor, "lfuLogFactor");
            this.lfuLogFactor = Optional.ofNullable(lfuLogFactor);
            return this;
        }

        public Builder lfuLogFactor(Optional<? extends Long> lfuLogFactor) {
            Utils.checkNotNull(lfuLogFactor, "lfuLogFactor");
            this.lfuLogFactor = lfuLogFactor;
            return this;
        }

        public Builder maxmemoryPolicy(RedisMaxmemoryPolicy maxmemoryPolicy) {
            Utils.checkNotNull(maxmemoryPolicy, "maxmemoryPolicy");
            this.maxmemoryPolicy = JsonNullable.of(maxmemoryPolicy);
            return this;
        }

        public Builder maxmemoryPolicy(JsonNullable<? extends RedisMaxmemoryPolicy> maxmemoryPolicy) {
            Utils.checkNotNull(maxmemoryPolicy, "maxmemoryPolicy");
            this.maxmemoryPolicy = maxmemoryPolicy;
            return this;
        }

        /**
         * Set Redis IO thread count. Changing this will cause a restart of the Redis service.
         */
        public Builder ioThreads(long ioThreads) {
            Utils.checkNotNull(ioThreads, "ioThreads");
            this.ioThreads = Optional.ofNullable(ioThreads);
            return this;
        }

        /**
         * Set Redis IO thread count. Changing this will cause a restart of the Redis service.
         */
        public Builder ioThreads(Optional<? extends Long> ioThreads) {
            Utils.checkNotNull(ioThreads, "ioThreads");
            this.ioThreads = ioThreads;
            return this;
        }

        public Builder lfuDecayTime(long lfuDecayTime) {
            Utils.checkNotNull(lfuDecayTime, "lfuDecayTime");
            this.lfuDecayTime = Optional.ofNullable(lfuDecayTime);
            return this;
        }

        public Builder lfuDecayTime(Optional<? extends Long> lfuDecayTime) {
            Utils.checkNotNull(lfuDecayTime, "lfuDecayTime");
            this.lfuDecayTime = lfuDecayTime;
            return this;
        }

        /**
         * Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
         */
        public Builder pubsubClientOutputBufferLimit(long pubsubClientOutputBufferLimit) {
            Utils.checkNotNull(pubsubClientOutputBufferLimit, "pubsubClientOutputBufferLimit");
            this.pubsubClientOutputBufferLimit = Optional.ofNullable(pubsubClientOutputBufferLimit);
            return this;
        }

        /**
         * Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
         */
        public Builder pubsubClientOutputBufferLimit(Optional<? extends Long> pubsubClientOutputBufferLimit) {
            Utils.checkNotNull(pubsubClientOutputBufferLimit, "pubsubClientOutputBufferLimit");
            this.pubsubClientOutputBufferLimit = pubsubClientOutputBufferLimit;
            return this;
        }

        public Builder notifyKeyspaceEvents(String notifyKeyspaceEvents) {
            Utils.checkNotNull(notifyKeyspaceEvents, "notifyKeyspaceEvents");
            this.notifyKeyspaceEvents = Optional.ofNullable(notifyKeyspaceEvents);
            return this;
        }

        public Builder notifyKeyspaceEvents(Optional<? extends String> notifyKeyspaceEvents) {
            Utils.checkNotNull(notifyKeyspaceEvents, "notifyKeyspaceEvents");
            this.notifyKeyspaceEvents = notifyKeyspaceEvents;
            return this;
        }

        /**
         * When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is 'off', no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
         */
        public Builder persistence(RedisPersistence persistence) {
            Utils.checkNotNull(persistence, "persistence");
            this.persistence = Optional.ofNullable(persistence);
            return this;
        }

        /**
         * When persistence is 'rdb', Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is 'off', no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
         */
        public Builder persistence(Optional<? extends RedisPersistence> persistence) {
            Utils.checkNotNull(persistence, "persistence");
            this.persistence = persistence;
            return this;
        }

        public Builder timeout(long timeout) {
            Utils.checkNotNull(timeout, "timeout");
            this.timeout = Optional.ofNullable(timeout);
            return this;
        }

        public Builder timeout(Optional<? extends Long> timeout) {
            Utils.checkNotNull(timeout, "timeout");
            this.timeout = timeout;
            return this;
        }

        /**
         * Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.
         */
        public Builder aclChannelsDefault(DefaultACLForPubSubChannelsUsedWhenRedisUserIsCreated aclChannelsDefault) {
            Utils.checkNotNull(aclChannelsDefault, "aclChannelsDefault");
            this.aclChannelsDefault = Optional.ofNullable(aclChannelsDefault);
            return this;
        }

        /**
         * Determines default pub/sub channels' ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn't affect Redis configuration acl-pubsub-default.
         */
        public Builder aclChannelsDefault(Optional<? extends DefaultACLForPubSubChannelsUsedWhenRedisUserIsCreated> aclChannelsDefault) {
            Utils.checkNotNull(aclChannelsDefault, "aclChannelsDefault");
            this.aclChannelsDefault = aclChannelsDefault;
            return this;
        }

        /**
         * Set number of Redis databases. Changing this will cause a restart of the Redis service.
         */
        public Builder numberOfDatabases(long numberOfDatabases) {
            Utils.checkNotNull(numberOfDatabases, "numberOfDatabases");
            this.numberOfDatabases = Optional.ofNullable(numberOfDatabases);
            return this;
        }

        /**
         * Set number of Redis databases. Changing this will cause a restart of the Redis service.
         */
        public Builder numberOfDatabases(Optional<? extends Long> numberOfDatabases) {
            Utils.checkNotNull(numberOfDatabases, "numberOfDatabases");
            this.numberOfDatabases = numberOfDatabases;
            return this;
        }
        
        public JsonSchemaRedis build() {
            if (ssl == null) {
                ssl = _SINGLETON_VALUE_Ssl.value();
            }
            if (lfuLogFactor == null) {
                lfuLogFactor = _SINGLETON_VALUE_LfuLogFactor.value();
            }
            if (maxmemoryPolicy == null) {
                maxmemoryPolicy = _SINGLETON_VALUE_MaxmemoryPolicy.value();
            }
            if (lfuDecayTime == null) {
                lfuDecayTime = _SINGLETON_VALUE_LfuDecayTime.value();
            }
            if (notifyKeyspaceEvents == null) {
                notifyKeyspaceEvents = _SINGLETON_VALUE_NotifyKeyspaceEvents.value();
            }
            if (timeout == null) {
                timeout = _SINGLETON_VALUE_Timeout.value();
            }
            return new JsonSchemaRedis(
                ssl,
                lfuLogFactor,
                maxmemoryPolicy,
                ioThreads,
                lfuDecayTime,
                pubsubClientOutputBufferLimit,
                notifyKeyspaceEvents,
                persistence,
                timeout,
                aclChannelsDefault,
                numberOfDatabases);
        }

        private static final LazySingletonValue<Optional<? extends Boolean>> _SINGLETON_VALUE_Ssl =
                new LazySingletonValue<>(
                        "ssl",
                        "true",
                        new TypeReference<Optional<? extends Boolean>>() {});

        private static final LazySingletonValue<Optional<? extends Long>> _SINGLETON_VALUE_LfuLogFactor =
                new LazySingletonValue<>(
                        "lfu_log_factor",
                        "10",
                        new TypeReference<Optional<? extends Long>>() {});

        private static final LazySingletonValue<JsonNullable<? extends RedisMaxmemoryPolicy>> _SINGLETON_VALUE_MaxmemoryPolicy =
                new LazySingletonValue<>(
                        "maxmemory_policy",
                        "\"noeviction\"",
                        new TypeReference<JsonNullable<? extends RedisMaxmemoryPolicy>>() {});

        private static final LazySingletonValue<Optional<? extends Long>> _SINGLETON_VALUE_LfuDecayTime =
                new LazySingletonValue<>(
                        "lfu_decay_time",
                        "1",
                        new TypeReference<Optional<? extends Long>>() {});

        private static final LazySingletonValue<Optional<? extends String>> _SINGLETON_VALUE_NotifyKeyspaceEvents =
                new LazySingletonValue<>(
                        "notify_keyspace_events",
                        "\"\"",
                        new TypeReference<Optional<? extends String>>() {});

        private static final LazySingletonValue<Optional<? extends Long>> _SINGLETON_VALUE_Timeout =
                new LazySingletonValue<>(
                        "timeout",
                        "300",
                        new TypeReference<Optional<? extends Long>>() {});
    }
}

