/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.exoscale.api.models.components;

import com.exoscale.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;


public class JsonSchemaPg {

    /**
     * Specifies the number of bytes reserved to track the currently executing command for each active session.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("track_activity_query_size")
    private Optional<? extends Long> trackActivityQuerySize;

    /**
     * PostgreSQL service timezone
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timezone")
    private Optional<? extends String> timezone;

    /**
     * Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("track_io_timing")
    private Optional<? extends TrackIoTiming> trackIoTiming;

    /**
     * Enables or disables query plan monitoring
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pg_stat_monitor.pgsm_enable_query_plan")
    private Optional<? extends Boolean> pgStatMonitorPgsmEnableQueryPlan;

    /**
     * PostgreSQL maximum number of files that can be open per process
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max_files_per_process")
    private Optional<? extends Long> maxFilesPerProcess;

    /**
     * Sets the maximum number of buckets 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pg_stat_monitor.pgsm_max_buckets")
    private Optional<? extends Long> pgStatMonitorPgsmMaxBuckets;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("wal")
    private Optional<? extends WriteAheadLogWALSettings> wal;

    /**
     * Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("default_toast_compression")
    private Optional<? extends DefaultToastCompression> defaultToastCompression;

    /**
     * This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("deadlock_timeout")
    private Optional<? extends Long> deadlockTimeout;

    /**
     * Time out sessions with open transactions after this number of milliseconds
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("idle_in_transaction_session_timeout")
    private Optional<? extends Long> idleInTransactionSessionTimeout;

    /**
     * PostgreSQL maximum predicate locks per transaction
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max_pred_locks_per_transaction")
    private Optional<? extends Long> maxPredLocksPerTransaction;

    /**
     * PostgreSQL maximum replication slots
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max_replication_slots")
    private Optional<? extends Long> maxReplicationSlots;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("autovacuum")
    private Optional<? extends AutovacuumSettings> autovacuum;

    /**
     * Sets the maximum number of workers that can be started by a single Gather or Gather Merge node
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max_parallel_workers_per_gather")
    private Optional<? extends Long> maxParallelWorkersPerGather;

    /**
     * Sets the time interval to run pg_partman's scheduled tasks
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pg_partman_bgw.interval")
    private Optional<? extends Long> pgPartmanBgwInterval;

    /**
     * Choose from one of the available log-formats. These can support popular log analyzers like pgbadger, pganalyze etc.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("log_line_prefix")
    private Optional<? extends LogLinePrefix> logLinePrefix;

    /**
     * Log statements for each temporary file created larger than this number of kilobytes, -1 disables
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("log_temp_files")
    private Optional<? extends Long> logTempFiles;

    /**
     * PostgreSQL maximum locks per transaction
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max_locks_per_transaction")
    private Optional<? extends Long> maxLocksPerTransaction;

    /**
     * Record commit time of transactions.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("track_commit_timestamp")
    private Optional<? extends TrackCommitTimestamp> trackCommitTimestamp;

    /**
     * Enables tracking of function call counts and time used.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("track_functions")
    private Optional<? extends TrackFunctions> trackFunctions;

    /**
     * Maximum depth of the stack in bytes
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max_stack_depth")
    private Optional<? extends Long> maxStackDepth;

    /**
     * Sets the maximum number of workers that the system can support for parallel queries
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max_parallel_workers")
    private Optional<? extends Long> maxParallelWorkers;

    /**
     * Controls which role to use for pg_partman's scheduled background tasks.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pg_partman_bgw.role")
    private Optional<? extends String> pgPartmanBgwRole;

    /**
     * PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max_logical_replication_workers")
    private Optional<? extends Long> maxLogicalReplicationWorkers;

    /**
     * PostgreSQL maximum prepared transactions
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max_prepared_transactions")
    private Optional<? extends Long> maxPreparedTransactions;

    /**
     * Sets the maximum number of background processes that the system can support
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max_worker_processes")
    private Optional<? extends Long> maxWorkerProcesses;

    /**
     * Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pg_stat_statements.track")
    private Optional<? extends PgStatStatementsTrack> pgStatStatementsTrack;

    /**
     * PostgreSQL temporary file limit in KiB, -1 for unlimited
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("temp_file_limit")
    private Optional<? extends Long> tempFileLimit;

    /**
     * Controls the amount of detail written in the server log for each message that is logged.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("log_error_verbosity")
    private Optional<? extends LogErrorVerbosity> logErrorVerbosity;

    /**
     * Log statements that take more than this number of milliseconds to run, -1 disables
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("log_min_duration_statement")
    private Optional<? extends Long> logMinDurationStatement;

    /**
     * Max standby streaming delay in milliseconds
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max_standby_streaming_delay")
    private Optional<? extends Long> maxStandbyStreamingDelay;

    /**
     * Controls system-wide use of Just-in-Time Compilation (JIT).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("jit")
    private Optional<? extends Boolean> jit;

    /**
     * Max standby archive delay in milliseconds
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max_standby_archive_delay")
    private Optional<? extends Long> maxStandbyArchiveDelay;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("bg-writer")
    private Optional<? extends BackgroundBGWriterSettings> bgWriter;

    public JsonSchemaPg(
            @JsonProperty("track_activity_query_size") Optional<? extends Long> trackActivityQuerySize,
            @JsonProperty("timezone") Optional<? extends String> timezone,
            @JsonProperty("track_io_timing") Optional<? extends TrackIoTiming> trackIoTiming,
            @JsonProperty("pg_stat_monitor.pgsm_enable_query_plan") Optional<? extends Boolean> pgStatMonitorPgsmEnableQueryPlan,
            @JsonProperty("max_files_per_process") Optional<? extends Long> maxFilesPerProcess,
            @JsonProperty("pg_stat_monitor.pgsm_max_buckets") Optional<? extends Long> pgStatMonitorPgsmMaxBuckets,
            @JsonProperty("wal") Optional<? extends WriteAheadLogWALSettings> wal,
            @JsonProperty("default_toast_compression") Optional<? extends DefaultToastCompression> defaultToastCompression,
            @JsonProperty("deadlock_timeout") Optional<? extends Long> deadlockTimeout,
            @JsonProperty("idle_in_transaction_session_timeout") Optional<? extends Long> idleInTransactionSessionTimeout,
            @JsonProperty("max_pred_locks_per_transaction") Optional<? extends Long> maxPredLocksPerTransaction,
            @JsonProperty("max_replication_slots") Optional<? extends Long> maxReplicationSlots,
            @JsonProperty("autovacuum") Optional<? extends AutovacuumSettings> autovacuum,
            @JsonProperty("max_parallel_workers_per_gather") Optional<? extends Long> maxParallelWorkersPerGather,
            @JsonProperty("pg_partman_bgw.interval") Optional<? extends Long> pgPartmanBgwInterval,
            @JsonProperty("log_line_prefix") Optional<? extends LogLinePrefix> logLinePrefix,
            @JsonProperty("log_temp_files") Optional<? extends Long> logTempFiles,
            @JsonProperty("max_locks_per_transaction") Optional<? extends Long> maxLocksPerTransaction,
            @JsonProperty("track_commit_timestamp") Optional<? extends TrackCommitTimestamp> trackCommitTimestamp,
            @JsonProperty("track_functions") Optional<? extends TrackFunctions> trackFunctions,
            @JsonProperty("max_stack_depth") Optional<? extends Long> maxStackDepth,
            @JsonProperty("max_parallel_workers") Optional<? extends Long> maxParallelWorkers,
            @JsonProperty("pg_partman_bgw.role") Optional<? extends String> pgPartmanBgwRole,
            @JsonProperty("max_logical_replication_workers") Optional<? extends Long> maxLogicalReplicationWorkers,
            @JsonProperty("max_prepared_transactions") Optional<? extends Long> maxPreparedTransactions,
            @JsonProperty("max_worker_processes") Optional<? extends Long> maxWorkerProcesses,
            @JsonProperty("pg_stat_statements.track") Optional<? extends PgStatStatementsTrack> pgStatStatementsTrack,
            @JsonProperty("temp_file_limit") Optional<? extends Long> tempFileLimit,
            @JsonProperty("log_error_verbosity") Optional<? extends LogErrorVerbosity> logErrorVerbosity,
            @JsonProperty("log_min_duration_statement") Optional<? extends Long> logMinDurationStatement,
            @JsonProperty("max_standby_streaming_delay") Optional<? extends Long> maxStandbyStreamingDelay,
            @JsonProperty("jit") Optional<? extends Boolean> jit,
            @JsonProperty("max_standby_archive_delay") Optional<? extends Long> maxStandbyArchiveDelay,
            @JsonProperty("bg-writer") Optional<? extends BackgroundBGWriterSettings> bgWriter) {
        Utils.checkNotNull(trackActivityQuerySize, "trackActivityQuerySize");
        Utils.checkNotNull(timezone, "timezone");
        Utils.checkNotNull(trackIoTiming, "trackIoTiming");
        Utils.checkNotNull(pgStatMonitorPgsmEnableQueryPlan, "pgStatMonitorPgsmEnableQueryPlan");
        Utils.checkNotNull(maxFilesPerProcess, "maxFilesPerProcess");
        Utils.checkNotNull(pgStatMonitorPgsmMaxBuckets, "pgStatMonitorPgsmMaxBuckets");
        Utils.checkNotNull(wal, "wal");
        Utils.checkNotNull(defaultToastCompression, "defaultToastCompression");
        Utils.checkNotNull(deadlockTimeout, "deadlockTimeout");
        Utils.checkNotNull(idleInTransactionSessionTimeout, "idleInTransactionSessionTimeout");
        Utils.checkNotNull(maxPredLocksPerTransaction, "maxPredLocksPerTransaction");
        Utils.checkNotNull(maxReplicationSlots, "maxReplicationSlots");
        Utils.checkNotNull(autovacuum, "autovacuum");
        Utils.checkNotNull(maxParallelWorkersPerGather, "maxParallelWorkersPerGather");
        Utils.checkNotNull(pgPartmanBgwInterval, "pgPartmanBgwInterval");
        Utils.checkNotNull(logLinePrefix, "logLinePrefix");
        Utils.checkNotNull(logTempFiles, "logTempFiles");
        Utils.checkNotNull(maxLocksPerTransaction, "maxLocksPerTransaction");
        Utils.checkNotNull(trackCommitTimestamp, "trackCommitTimestamp");
        Utils.checkNotNull(trackFunctions, "trackFunctions");
        Utils.checkNotNull(maxStackDepth, "maxStackDepth");
        Utils.checkNotNull(maxParallelWorkers, "maxParallelWorkers");
        Utils.checkNotNull(pgPartmanBgwRole, "pgPartmanBgwRole");
        Utils.checkNotNull(maxLogicalReplicationWorkers, "maxLogicalReplicationWorkers");
        Utils.checkNotNull(maxPreparedTransactions, "maxPreparedTransactions");
        Utils.checkNotNull(maxWorkerProcesses, "maxWorkerProcesses");
        Utils.checkNotNull(pgStatStatementsTrack, "pgStatStatementsTrack");
        Utils.checkNotNull(tempFileLimit, "tempFileLimit");
        Utils.checkNotNull(logErrorVerbosity, "logErrorVerbosity");
        Utils.checkNotNull(logMinDurationStatement, "logMinDurationStatement");
        Utils.checkNotNull(maxStandbyStreamingDelay, "maxStandbyStreamingDelay");
        Utils.checkNotNull(jit, "jit");
        Utils.checkNotNull(maxStandbyArchiveDelay, "maxStandbyArchiveDelay");
        Utils.checkNotNull(bgWriter, "bgWriter");
        this.trackActivityQuerySize = trackActivityQuerySize;
        this.timezone = timezone;
        this.trackIoTiming = trackIoTiming;
        this.pgStatMonitorPgsmEnableQueryPlan = pgStatMonitorPgsmEnableQueryPlan;
        this.maxFilesPerProcess = maxFilesPerProcess;
        this.pgStatMonitorPgsmMaxBuckets = pgStatMonitorPgsmMaxBuckets;
        this.wal = wal;
        this.defaultToastCompression = defaultToastCompression;
        this.deadlockTimeout = deadlockTimeout;
        this.idleInTransactionSessionTimeout = idleInTransactionSessionTimeout;
        this.maxPredLocksPerTransaction = maxPredLocksPerTransaction;
        this.maxReplicationSlots = maxReplicationSlots;
        this.autovacuum = autovacuum;
        this.maxParallelWorkersPerGather = maxParallelWorkersPerGather;
        this.pgPartmanBgwInterval = pgPartmanBgwInterval;
        this.logLinePrefix = logLinePrefix;
        this.logTempFiles = logTempFiles;
        this.maxLocksPerTransaction = maxLocksPerTransaction;
        this.trackCommitTimestamp = trackCommitTimestamp;
        this.trackFunctions = trackFunctions;
        this.maxStackDepth = maxStackDepth;
        this.maxParallelWorkers = maxParallelWorkers;
        this.pgPartmanBgwRole = pgPartmanBgwRole;
        this.maxLogicalReplicationWorkers = maxLogicalReplicationWorkers;
        this.maxPreparedTransactions = maxPreparedTransactions;
        this.maxWorkerProcesses = maxWorkerProcesses;
        this.pgStatStatementsTrack = pgStatStatementsTrack;
        this.tempFileLimit = tempFileLimit;
        this.logErrorVerbosity = logErrorVerbosity;
        this.logMinDurationStatement = logMinDurationStatement;
        this.maxStandbyStreamingDelay = maxStandbyStreamingDelay;
        this.jit = jit;
        this.maxStandbyArchiveDelay = maxStandbyArchiveDelay;
        this.bgWriter = bgWriter;
    }

    /**
     * Specifies the number of bytes reserved to track the currently executing command for each active session.
     */
    public Optional<? extends Long> trackActivityQuerySize() {
        return trackActivityQuerySize;
    }

    /**
     * PostgreSQL service timezone
     */
    public Optional<? extends String> timezone() {
        return timezone;
    }

    /**
     * Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
     */
    public Optional<? extends TrackIoTiming> trackIoTiming() {
        return trackIoTiming;
    }

    /**
     * Enables or disables query plan monitoring
     */
    public Optional<? extends Boolean> pgStatMonitorPgsmEnableQueryPlan() {
        return pgStatMonitorPgsmEnableQueryPlan;
    }

    /**
     * PostgreSQL maximum number of files that can be open per process
     */
    public Optional<? extends Long> maxFilesPerProcess() {
        return maxFilesPerProcess;
    }

    /**
     * Sets the maximum number of buckets 
     */
    public Optional<? extends Long> pgStatMonitorPgsmMaxBuckets() {
        return pgStatMonitorPgsmMaxBuckets;
    }

    public Optional<? extends WriteAheadLogWALSettings> wal() {
        return wal;
    }

    /**
     * Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
     */
    public Optional<? extends DefaultToastCompression> defaultToastCompression() {
        return defaultToastCompression;
    }

    /**
     * This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
     */
    public Optional<? extends Long> deadlockTimeout() {
        return deadlockTimeout;
    }

    /**
     * Time out sessions with open transactions after this number of milliseconds
     */
    public Optional<? extends Long> idleInTransactionSessionTimeout() {
        return idleInTransactionSessionTimeout;
    }

    /**
     * PostgreSQL maximum predicate locks per transaction
     */
    public Optional<? extends Long> maxPredLocksPerTransaction() {
        return maxPredLocksPerTransaction;
    }

    /**
     * PostgreSQL maximum replication slots
     */
    public Optional<? extends Long> maxReplicationSlots() {
        return maxReplicationSlots;
    }

    public Optional<? extends AutovacuumSettings> autovacuum() {
        return autovacuum;
    }

    /**
     * Sets the maximum number of workers that can be started by a single Gather or Gather Merge node
     */
    public Optional<? extends Long> maxParallelWorkersPerGather() {
        return maxParallelWorkersPerGather;
    }

    /**
     * Sets the time interval to run pg_partman's scheduled tasks
     */
    public Optional<? extends Long> pgPartmanBgwInterval() {
        return pgPartmanBgwInterval;
    }

    /**
     * Choose from one of the available log-formats. These can support popular log analyzers like pgbadger, pganalyze etc.
     */
    public Optional<? extends LogLinePrefix> logLinePrefix() {
        return logLinePrefix;
    }

    /**
     * Log statements for each temporary file created larger than this number of kilobytes, -1 disables
     */
    public Optional<? extends Long> logTempFiles() {
        return logTempFiles;
    }

    /**
     * PostgreSQL maximum locks per transaction
     */
    public Optional<? extends Long> maxLocksPerTransaction() {
        return maxLocksPerTransaction;
    }

    /**
     * Record commit time of transactions.
     */
    public Optional<? extends TrackCommitTimestamp> trackCommitTimestamp() {
        return trackCommitTimestamp;
    }

    /**
     * Enables tracking of function call counts and time used.
     */
    public Optional<? extends TrackFunctions> trackFunctions() {
        return trackFunctions;
    }

    /**
     * Maximum depth of the stack in bytes
     */
    public Optional<? extends Long> maxStackDepth() {
        return maxStackDepth;
    }

    /**
     * Sets the maximum number of workers that the system can support for parallel queries
     */
    public Optional<? extends Long> maxParallelWorkers() {
        return maxParallelWorkers;
    }

    /**
     * Controls which role to use for pg_partman's scheduled background tasks.
     */
    public Optional<? extends String> pgPartmanBgwRole() {
        return pgPartmanBgwRole;
    }

    /**
     * PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers)
     */
    public Optional<? extends Long> maxLogicalReplicationWorkers() {
        return maxLogicalReplicationWorkers;
    }

    /**
     * PostgreSQL maximum prepared transactions
     */
    public Optional<? extends Long> maxPreparedTransactions() {
        return maxPreparedTransactions;
    }

    /**
     * Sets the maximum number of background processes that the system can support
     */
    public Optional<? extends Long> maxWorkerProcesses() {
        return maxWorkerProcesses;
    }

    /**
     * Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
     */
    public Optional<? extends PgStatStatementsTrack> pgStatStatementsTrack() {
        return pgStatStatementsTrack;
    }

    /**
     * PostgreSQL temporary file limit in KiB, -1 for unlimited
     */
    public Optional<? extends Long> tempFileLimit() {
        return tempFileLimit;
    }

    /**
     * Controls the amount of detail written in the server log for each message that is logged.
     */
    public Optional<? extends LogErrorVerbosity> logErrorVerbosity() {
        return logErrorVerbosity;
    }

    /**
     * Log statements that take more than this number of milliseconds to run, -1 disables
     */
    public Optional<? extends Long> logMinDurationStatement() {
        return logMinDurationStatement;
    }

    /**
     * Max standby streaming delay in milliseconds
     */
    public Optional<? extends Long> maxStandbyStreamingDelay() {
        return maxStandbyStreamingDelay;
    }

    /**
     * Controls system-wide use of Just-in-Time Compilation (JIT).
     */
    public Optional<? extends Boolean> jit() {
        return jit;
    }

    /**
     * Max standby archive delay in milliseconds
     */
    public Optional<? extends Long> maxStandbyArchiveDelay() {
        return maxStandbyArchiveDelay;
    }

    public Optional<? extends BackgroundBGWriterSettings> bgWriter() {
        return bgWriter;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Specifies the number of bytes reserved to track the currently executing command for each active session.
     */
    public JsonSchemaPg withTrackActivityQuerySize(long trackActivityQuerySize) {
        Utils.checkNotNull(trackActivityQuerySize, "trackActivityQuerySize");
        this.trackActivityQuerySize = Optional.ofNullable(trackActivityQuerySize);
        return this;
    }

    /**
     * Specifies the number of bytes reserved to track the currently executing command for each active session.
     */
    public JsonSchemaPg withTrackActivityQuerySize(Optional<? extends Long> trackActivityQuerySize) {
        Utils.checkNotNull(trackActivityQuerySize, "trackActivityQuerySize");
        this.trackActivityQuerySize = trackActivityQuerySize;
        return this;
    }

    /**
     * PostgreSQL service timezone
     */
    public JsonSchemaPg withTimezone(String timezone) {
        Utils.checkNotNull(timezone, "timezone");
        this.timezone = Optional.ofNullable(timezone);
        return this;
    }

    /**
     * PostgreSQL service timezone
     */
    public JsonSchemaPg withTimezone(Optional<? extends String> timezone) {
        Utils.checkNotNull(timezone, "timezone");
        this.timezone = timezone;
        return this;
    }

    /**
     * Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
     */
    public JsonSchemaPg withTrackIoTiming(TrackIoTiming trackIoTiming) {
        Utils.checkNotNull(trackIoTiming, "trackIoTiming");
        this.trackIoTiming = Optional.ofNullable(trackIoTiming);
        return this;
    }

    /**
     * Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
     */
    public JsonSchemaPg withTrackIoTiming(Optional<? extends TrackIoTiming> trackIoTiming) {
        Utils.checkNotNull(trackIoTiming, "trackIoTiming");
        this.trackIoTiming = trackIoTiming;
        return this;
    }

    /**
     * Enables or disables query plan monitoring
     */
    public JsonSchemaPg withPgStatMonitorPgsmEnableQueryPlan(boolean pgStatMonitorPgsmEnableQueryPlan) {
        Utils.checkNotNull(pgStatMonitorPgsmEnableQueryPlan, "pgStatMonitorPgsmEnableQueryPlan");
        this.pgStatMonitorPgsmEnableQueryPlan = Optional.ofNullable(pgStatMonitorPgsmEnableQueryPlan);
        return this;
    }

    /**
     * Enables or disables query plan monitoring
     */
    public JsonSchemaPg withPgStatMonitorPgsmEnableQueryPlan(Optional<? extends Boolean> pgStatMonitorPgsmEnableQueryPlan) {
        Utils.checkNotNull(pgStatMonitorPgsmEnableQueryPlan, "pgStatMonitorPgsmEnableQueryPlan");
        this.pgStatMonitorPgsmEnableQueryPlan = pgStatMonitorPgsmEnableQueryPlan;
        return this;
    }

    /**
     * PostgreSQL maximum number of files that can be open per process
     */
    public JsonSchemaPg withMaxFilesPerProcess(long maxFilesPerProcess) {
        Utils.checkNotNull(maxFilesPerProcess, "maxFilesPerProcess");
        this.maxFilesPerProcess = Optional.ofNullable(maxFilesPerProcess);
        return this;
    }

    /**
     * PostgreSQL maximum number of files that can be open per process
     */
    public JsonSchemaPg withMaxFilesPerProcess(Optional<? extends Long> maxFilesPerProcess) {
        Utils.checkNotNull(maxFilesPerProcess, "maxFilesPerProcess");
        this.maxFilesPerProcess = maxFilesPerProcess;
        return this;
    }

    /**
     * Sets the maximum number of buckets 
     */
    public JsonSchemaPg withPgStatMonitorPgsmMaxBuckets(long pgStatMonitorPgsmMaxBuckets) {
        Utils.checkNotNull(pgStatMonitorPgsmMaxBuckets, "pgStatMonitorPgsmMaxBuckets");
        this.pgStatMonitorPgsmMaxBuckets = Optional.ofNullable(pgStatMonitorPgsmMaxBuckets);
        return this;
    }

    /**
     * Sets the maximum number of buckets 
     */
    public JsonSchemaPg withPgStatMonitorPgsmMaxBuckets(Optional<? extends Long> pgStatMonitorPgsmMaxBuckets) {
        Utils.checkNotNull(pgStatMonitorPgsmMaxBuckets, "pgStatMonitorPgsmMaxBuckets");
        this.pgStatMonitorPgsmMaxBuckets = pgStatMonitorPgsmMaxBuckets;
        return this;
    }

    public JsonSchemaPg withWal(WriteAheadLogWALSettings wal) {
        Utils.checkNotNull(wal, "wal");
        this.wal = Optional.ofNullable(wal);
        return this;
    }

    public JsonSchemaPg withWal(Optional<? extends WriteAheadLogWALSettings> wal) {
        Utils.checkNotNull(wal, "wal");
        this.wal = wal;
        return this;
    }

    /**
     * Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
     */
    public JsonSchemaPg withDefaultToastCompression(DefaultToastCompression defaultToastCompression) {
        Utils.checkNotNull(defaultToastCompression, "defaultToastCompression");
        this.defaultToastCompression = Optional.ofNullable(defaultToastCompression);
        return this;
    }

    /**
     * Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
     */
    public JsonSchemaPg withDefaultToastCompression(Optional<? extends DefaultToastCompression> defaultToastCompression) {
        Utils.checkNotNull(defaultToastCompression, "defaultToastCompression");
        this.defaultToastCompression = defaultToastCompression;
        return this;
    }

    /**
     * This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
     */
    public JsonSchemaPg withDeadlockTimeout(long deadlockTimeout) {
        Utils.checkNotNull(deadlockTimeout, "deadlockTimeout");
        this.deadlockTimeout = Optional.ofNullable(deadlockTimeout);
        return this;
    }

    /**
     * This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
     */
    public JsonSchemaPg withDeadlockTimeout(Optional<? extends Long> deadlockTimeout) {
        Utils.checkNotNull(deadlockTimeout, "deadlockTimeout");
        this.deadlockTimeout = deadlockTimeout;
        return this;
    }

    /**
     * Time out sessions with open transactions after this number of milliseconds
     */
    public JsonSchemaPg withIdleInTransactionSessionTimeout(long idleInTransactionSessionTimeout) {
        Utils.checkNotNull(idleInTransactionSessionTimeout, "idleInTransactionSessionTimeout");
        this.idleInTransactionSessionTimeout = Optional.ofNullable(idleInTransactionSessionTimeout);
        return this;
    }

    /**
     * Time out sessions with open transactions after this number of milliseconds
     */
    public JsonSchemaPg withIdleInTransactionSessionTimeout(Optional<? extends Long> idleInTransactionSessionTimeout) {
        Utils.checkNotNull(idleInTransactionSessionTimeout, "idleInTransactionSessionTimeout");
        this.idleInTransactionSessionTimeout = idleInTransactionSessionTimeout;
        return this;
    }

    /**
     * PostgreSQL maximum predicate locks per transaction
     */
    public JsonSchemaPg withMaxPredLocksPerTransaction(long maxPredLocksPerTransaction) {
        Utils.checkNotNull(maxPredLocksPerTransaction, "maxPredLocksPerTransaction");
        this.maxPredLocksPerTransaction = Optional.ofNullable(maxPredLocksPerTransaction);
        return this;
    }

    /**
     * PostgreSQL maximum predicate locks per transaction
     */
    public JsonSchemaPg withMaxPredLocksPerTransaction(Optional<? extends Long> maxPredLocksPerTransaction) {
        Utils.checkNotNull(maxPredLocksPerTransaction, "maxPredLocksPerTransaction");
        this.maxPredLocksPerTransaction = maxPredLocksPerTransaction;
        return this;
    }

    /**
     * PostgreSQL maximum replication slots
     */
    public JsonSchemaPg withMaxReplicationSlots(long maxReplicationSlots) {
        Utils.checkNotNull(maxReplicationSlots, "maxReplicationSlots");
        this.maxReplicationSlots = Optional.ofNullable(maxReplicationSlots);
        return this;
    }

    /**
     * PostgreSQL maximum replication slots
     */
    public JsonSchemaPg withMaxReplicationSlots(Optional<? extends Long> maxReplicationSlots) {
        Utils.checkNotNull(maxReplicationSlots, "maxReplicationSlots");
        this.maxReplicationSlots = maxReplicationSlots;
        return this;
    }

    public JsonSchemaPg withAutovacuum(AutovacuumSettings autovacuum) {
        Utils.checkNotNull(autovacuum, "autovacuum");
        this.autovacuum = Optional.ofNullable(autovacuum);
        return this;
    }

    public JsonSchemaPg withAutovacuum(Optional<? extends AutovacuumSettings> autovacuum) {
        Utils.checkNotNull(autovacuum, "autovacuum");
        this.autovacuum = autovacuum;
        return this;
    }

    /**
     * Sets the maximum number of workers that can be started by a single Gather or Gather Merge node
     */
    public JsonSchemaPg withMaxParallelWorkersPerGather(long maxParallelWorkersPerGather) {
        Utils.checkNotNull(maxParallelWorkersPerGather, "maxParallelWorkersPerGather");
        this.maxParallelWorkersPerGather = Optional.ofNullable(maxParallelWorkersPerGather);
        return this;
    }

    /**
     * Sets the maximum number of workers that can be started by a single Gather or Gather Merge node
     */
    public JsonSchemaPg withMaxParallelWorkersPerGather(Optional<? extends Long> maxParallelWorkersPerGather) {
        Utils.checkNotNull(maxParallelWorkersPerGather, "maxParallelWorkersPerGather");
        this.maxParallelWorkersPerGather = maxParallelWorkersPerGather;
        return this;
    }

    /**
     * Sets the time interval to run pg_partman's scheduled tasks
     */
    public JsonSchemaPg withPgPartmanBgwInterval(long pgPartmanBgwInterval) {
        Utils.checkNotNull(pgPartmanBgwInterval, "pgPartmanBgwInterval");
        this.pgPartmanBgwInterval = Optional.ofNullable(pgPartmanBgwInterval);
        return this;
    }

    /**
     * Sets the time interval to run pg_partman's scheduled tasks
     */
    public JsonSchemaPg withPgPartmanBgwInterval(Optional<? extends Long> pgPartmanBgwInterval) {
        Utils.checkNotNull(pgPartmanBgwInterval, "pgPartmanBgwInterval");
        this.pgPartmanBgwInterval = pgPartmanBgwInterval;
        return this;
    }

    /**
     * Choose from one of the available log-formats. These can support popular log analyzers like pgbadger, pganalyze etc.
     */
    public JsonSchemaPg withLogLinePrefix(LogLinePrefix logLinePrefix) {
        Utils.checkNotNull(logLinePrefix, "logLinePrefix");
        this.logLinePrefix = Optional.ofNullable(logLinePrefix);
        return this;
    }

    /**
     * Choose from one of the available log-formats. These can support popular log analyzers like pgbadger, pganalyze etc.
     */
    public JsonSchemaPg withLogLinePrefix(Optional<? extends LogLinePrefix> logLinePrefix) {
        Utils.checkNotNull(logLinePrefix, "logLinePrefix");
        this.logLinePrefix = logLinePrefix;
        return this;
    }

    /**
     * Log statements for each temporary file created larger than this number of kilobytes, -1 disables
     */
    public JsonSchemaPg withLogTempFiles(long logTempFiles) {
        Utils.checkNotNull(logTempFiles, "logTempFiles");
        this.logTempFiles = Optional.ofNullable(logTempFiles);
        return this;
    }

    /**
     * Log statements for each temporary file created larger than this number of kilobytes, -1 disables
     */
    public JsonSchemaPg withLogTempFiles(Optional<? extends Long> logTempFiles) {
        Utils.checkNotNull(logTempFiles, "logTempFiles");
        this.logTempFiles = logTempFiles;
        return this;
    }

    /**
     * PostgreSQL maximum locks per transaction
     */
    public JsonSchemaPg withMaxLocksPerTransaction(long maxLocksPerTransaction) {
        Utils.checkNotNull(maxLocksPerTransaction, "maxLocksPerTransaction");
        this.maxLocksPerTransaction = Optional.ofNullable(maxLocksPerTransaction);
        return this;
    }

    /**
     * PostgreSQL maximum locks per transaction
     */
    public JsonSchemaPg withMaxLocksPerTransaction(Optional<? extends Long> maxLocksPerTransaction) {
        Utils.checkNotNull(maxLocksPerTransaction, "maxLocksPerTransaction");
        this.maxLocksPerTransaction = maxLocksPerTransaction;
        return this;
    }

    /**
     * Record commit time of transactions.
     */
    public JsonSchemaPg withTrackCommitTimestamp(TrackCommitTimestamp trackCommitTimestamp) {
        Utils.checkNotNull(trackCommitTimestamp, "trackCommitTimestamp");
        this.trackCommitTimestamp = Optional.ofNullable(trackCommitTimestamp);
        return this;
    }

    /**
     * Record commit time of transactions.
     */
    public JsonSchemaPg withTrackCommitTimestamp(Optional<? extends TrackCommitTimestamp> trackCommitTimestamp) {
        Utils.checkNotNull(trackCommitTimestamp, "trackCommitTimestamp");
        this.trackCommitTimestamp = trackCommitTimestamp;
        return this;
    }

    /**
     * Enables tracking of function call counts and time used.
     */
    public JsonSchemaPg withTrackFunctions(TrackFunctions trackFunctions) {
        Utils.checkNotNull(trackFunctions, "trackFunctions");
        this.trackFunctions = Optional.ofNullable(trackFunctions);
        return this;
    }

    /**
     * Enables tracking of function call counts and time used.
     */
    public JsonSchemaPg withTrackFunctions(Optional<? extends TrackFunctions> trackFunctions) {
        Utils.checkNotNull(trackFunctions, "trackFunctions");
        this.trackFunctions = trackFunctions;
        return this;
    }

    /**
     * Maximum depth of the stack in bytes
     */
    public JsonSchemaPg withMaxStackDepth(long maxStackDepth) {
        Utils.checkNotNull(maxStackDepth, "maxStackDepth");
        this.maxStackDepth = Optional.ofNullable(maxStackDepth);
        return this;
    }

    /**
     * Maximum depth of the stack in bytes
     */
    public JsonSchemaPg withMaxStackDepth(Optional<? extends Long> maxStackDepth) {
        Utils.checkNotNull(maxStackDepth, "maxStackDepth");
        this.maxStackDepth = maxStackDepth;
        return this;
    }

    /**
     * Sets the maximum number of workers that the system can support for parallel queries
     */
    public JsonSchemaPg withMaxParallelWorkers(long maxParallelWorkers) {
        Utils.checkNotNull(maxParallelWorkers, "maxParallelWorkers");
        this.maxParallelWorkers = Optional.ofNullable(maxParallelWorkers);
        return this;
    }

    /**
     * Sets the maximum number of workers that the system can support for parallel queries
     */
    public JsonSchemaPg withMaxParallelWorkers(Optional<? extends Long> maxParallelWorkers) {
        Utils.checkNotNull(maxParallelWorkers, "maxParallelWorkers");
        this.maxParallelWorkers = maxParallelWorkers;
        return this;
    }

    /**
     * Controls which role to use for pg_partman's scheduled background tasks.
     */
    public JsonSchemaPg withPgPartmanBgwRole(String pgPartmanBgwRole) {
        Utils.checkNotNull(pgPartmanBgwRole, "pgPartmanBgwRole");
        this.pgPartmanBgwRole = Optional.ofNullable(pgPartmanBgwRole);
        return this;
    }

    /**
     * Controls which role to use for pg_partman's scheduled background tasks.
     */
    public JsonSchemaPg withPgPartmanBgwRole(Optional<? extends String> pgPartmanBgwRole) {
        Utils.checkNotNull(pgPartmanBgwRole, "pgPartmanBgwRole");
        this.pgPartmanBgwRole = pgPartmanBgwRole;
        return this;
    }

    /**
     * PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers)
     */
    public JsonSchemaPg withMaxLogicalReplicationWorkers(long maxLogicalReplicationWorkers) {
        Utils.checkNotNull(maxLogicalReplicationWorkers, "maxLogicalReplicationWorkers");
        this.maxLogicalReplicationWorkers = Optional.ofNullable(maxLogicalReplicationWorkers);
        return this;
    }

    /**
     * PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers)
     */
    public JsonSchemaPg withMaxLogicalReplicationWorkers(Optional<? extends Long> maxLogicalReplicationWorkers) {
        Utils.checkNotNull(maxLogicalReplicationWorkers, "maxLogicalReplicationWorkers");
        this.maxLogicalReplicationWorkers = maxLogicalReplicationWorkers;
        return this;
    }

    /**
     * PostgreSQL maximum prepared transactions
     */
    public JsonSchemaPg withMaxPreparedTransactions(long maxPreparedTransactions) {
        Utils.checkNotNull(maxPreparedTransactions, "maxPreparedTransactions");
        this.maxPreparedTransactions = Optional.ofNullable(maxPreparedTransactions);
        return this;
    }

    /**
     * PostgreSQL maximum prepared transactions
     */
    public JsonSchemaPg withMaxPreparedTransactions(Optional<? extends Long> maxPreparedTransactions) {
        Utils.checkNotNull(maxPreparedTransactions, "maxPreparedTransactions");
        this.maxPreparedTransactions = maxPreparedTransactions;
        return this;
    }

    /**
     * Sets the maximum number of background processes that the system can support
     */
    public JsonSchemaPg withMaxWorkerProcesses(long maxWorkerProcesses) {
        Utils.checkNotNull(maxWorkerProcesses, "maxWorkerProcesses");
        this.maxWorkerProcesses = Optional.ofNullable(maxWorkerProcesses);
        return this;
    }

    /**
     * Sets the maximum number of background processes that the system can support
     */
    public JsonSchemaPg withMaxWorkerProcesses(Optional<? extends Long> maxWorkerProcesses) {
        Utils.checkNotNull(maxWorkerProcesses, "maxWorkerProcesses");
        this.maxWorkerProcesses = maxWorkerProcesses;
        return this;
    }

    /**
     * Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
     */
    public JsonSchemaPg withPgStatStatementsTrack(PgStatStatementsTrack pgStatStatementsTrack) {
        Utils.checkNotNull(pgStatStatementsTrack, "pgStatStatementsTrack");
        this.pgStatStatementsTrack = Optional.ofNullable(pgStatStatementsTrack);
        return this;
    }

    /**
     * Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
     */
    public JsonSchemaPg withPgStatStatementsTrack(Optional<? extends PgStatStatementsTrack> pgStatStatementsTrack) {
        Utils.checkNotNull(pgStatStatementsTrack, "pgStatStatementsTrack");
        this.pgStatStatementsTrack = pgStatStatementsTrack;
        return this;
    }

    /**
     * PostgreSQL temporary file limit in KiB, -1 for unlimited
     */
    public JsonSchemaPg withTempFileLimit(long tempFileLimit) {
        Utils.checkNotNull(tempFileLimit, "tempFileLimit");
        this.tempFileLimit = Optional.ofNullable(tempFileLimit);
        return this;
    }

    /**
     * PostgreSQL temporary file limit in KiB, -1 for unlimited
     */
    public JsonSchemaPg withTempFileLimit(Optional<? extends Long> tempFileLimit) {
        Utils.checkNotNull(tempFileLimit, "tempFileLimit");
        this.tempFileLimit = tempFileLimit;
        return this;
    }

    /**
     * Controls the amount of detail written in the server log for each message that is logged.
     */
    public JsonSchemaPg withLogErrorVerbosity(LogErrorVerbosity logErrorVerbosity) {
        Utils.checkNotNull(logErrorVerbosity, "logErrorVerbosity");
        this.logErrorVerbosity = Optional.ofNullable(logErrorVerbosity);
        return this;
    }

    /**
     * Controls the amount of detail written in the server log for each message that is logged.
     */
    public JsonSchemaPg withLogErrorVerbosity(Optional<? extends LogErrorVerbosity> logErrorVerbosity) {
        Utils.checkNotNull(logErrorVerbosity, "logErrorVerbosity");
        this.logErrorVerbosity = logErrorVerbosity;
        return this;
    }

    /**
     * Log statements that take more than this number of milliseconds to run, -1 disables
     */
    public JsonSchemaPg withLogMinDurationStatement(long logMinDurationStatement) {
        Utils.checkNotNull(logMinDurationStatement, "logMinDurationStatement");
        this.logMinDurationStatement = Optional.ofNullable(logMinDurationStatement);
        return this;
    }

    /**
     * Log statements that take more than this number of milliseconds to run, -1 disables
     */
    public JsonSchemaPg withLogMinDurationStatement(Optional<? extends Long> logMinDurationStatement) {
        Utils.checkNotNull(logMinDurationStatement, "logMinDurationStatement");
        this.logMinDurationStatement = logMinDurationStatement;
        return this;
    }

    /**
     * Max standby streaming delay in milliseconds
     */
    public JsonSchemaPg withMaxStandbyStreamingDelay(long maxStandbyStreamingDelay) {
        Utils.checkNotNull(maxStandbyStreamingDelay, "maxStandbyStreamingDelay");
        this.maxStandbyStreamingDelay = Optional.ofNullable(maxStandbyStreamingDelay);
        return this;
    }

    /**
     * Max standby streaming delay in milliseconds
     */
    public JsonSchemaPg withMaxStandbyStreamingDelay(Optional<? extends Long> maxStandbyStreamingDelay) {
        Utils.checkNotNull(maxStandbyStreamingDelay, "maxStandbyStreamingDelay");
        this.maxStandbyStreamingDelay = maxStandbyStreamingDelay;
        return this;
    }

    /**
     * Controls system-wide use of Just-in-Time Compilation (JIT).
     */
    public JsonSchemaPg withJit(boolean jit) {
        Utils.checkNotNull(jit, "jit");
        this.jit = Optional.ofNullable(jit);
        return this;
    }

    /**
     * Controls system-wide use of Just-in-Time Compilation (JIT).
     */
    public JsonSchemaPg withJit(Optional<? extends Boolean> jit) {
        Utils.checkNotNull(jit, "jit");
        this.jit = jit;
        return this;
    }

    /**
     * Max standby archive delay in milliseconds
     */
    public JsonSchemaPg withMaxStandbyArchiveDelay(long maxStandbyArchiveDelay) {
        Utils.checkNotNull(maxStandbyArchiveDelay, "maxStandbyArchiveDelay");
        this.maxStandbyArchiveDelay = Optional.ofNullable(maxStandbyArchiveDelay);
        return this;
    }

    /**
     * Max standby archive delay in milliseconds
     */
    public JsonSchemaPg withMaxStandbyArchiveDelay(Optional<? extends Long> maxStandbyArchiveDelay) {
        Utils.checkNotNull(maxStandbyArchiveDelay, "maxStandbyArchiveDelay");
        this.maxStandbyArchiveDelay = maxStandbyArchiveDelay;
        return this;
    }

    public JsonSchemaPg withBgWriter(BackgroundBGWriterSettings bgWriter) {
        Utils.checkNotNull(bgWriter, "bgWriter");
        this.bgWriter = Optional.ofNullable(bgWriter);
        return this;
    }

    public JsonSchemaPg withBgWriter(Optional<? extends BackgroundBGWriterSettings> bgWriter) {
        Utils.checkNotNull(bgWriter, "bgWriter");
        this.bgWriter = bgWriter;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        JsonSchemaPg other = (JsonSchemaPg) o;
        return 
            java.util.Objects.deepEquals(this.trackActivityQuerySize, other.trackActivityQuerySize) &&
            java.util.Objects.deepEquals(this.timezone, other.timezone) &&
            java.util.Objects.deepEquals(this.trackIoTiming, other.trackIoTiming) &&
            java.util.Objects.deepEquals(this.pgStatMonitorPgsmEnableQueryPlan, other.pgStatMonitorPgsmEnableQueryPlan) &&
            java.util.Objects.deepEquals(this.maxFilesPerProcess, other.maxFilesPerProcess) &&
            java.util.Objects.deepEquals(this.pgStatMonitorPgsmMaxBuckets, other.pgStatMonitorPgsmMaxBuckets) &&
            java.util.Objects.deepEquals(this.wal, other.wal) &&
            java.util.Objects.deepEquals(this.defaultToastCompression, other.defaultToastCompression) &&
            java.util.Objects.deepEquals(this.deadlockTimeout, other.deadlockTimeout) &&
            java.util.Objects.deepEquals(this.idleInTransactionSessionTimeout, other.idleInTransactionSessionTimeout) &&
            java.util.Objects.deepEquals(this.maxPredLocksPerTransaction, other.maxPredLocksPerTransaction) &&
            java.util.Objects.deepEquals(this.maxReplicationSlots, other.maxReplicationSlots) &&
            java.util.Objects.deepEquals(this.autovacuum, other.autovacuum) &&
            java.util.Objects.deepEquals(this.maxParallelWorkersPerGather, other.maxParallelWorkersPerGather) &&
            java.util.Objects.deepEquals(this.pgPartmanBgwInterval, other.pgPartmanBgwInterval) &&
            java.util.Objects.deepEquals(this.logLinePrefix, other.logLinePrefix) &&
            java.util.Objects.deepEquals(this.logTempFiles, other.logTempFiles) &&
            java.util.Objects.deepEquals(this.maxLocksPerTransaction, other.maxLocksPerTransaction) &&
            java.util.Objects.deepEquals(this.trackCommitTimestamp, other.trackCommitTimestamp) &&
            java.util.Objects.deepEquals(this.trackFunctions, other.trackFunctions) &&
            java.util.Objects.deepEquals(this.maxStackDepth, other.maxStackDepth) &&
            java.util.Objects.deepEquals(this.maxParallelWorkers, other.maxParallelWorkers) &&
            java.util.Objects.deepEquals(this.pgPartmanBgwRole, other.pgPartmanBgwRole) &&
            java.util.Objects.deepEquals(this.maxLogicalReplicationWorkers, other.maxLogicalReplicationWorkers) &&
            java.util.Objects.deepEquals(this.maxPreparedTransactions, other.maxPreparedTransactions) &&
            java.util.Objects.deepEquals(this.maxWorkerProcesses, other.maxWorkerProcesses) &&
            java.util.Objects.deepEquals(this.pgStatStatementsTrack, other.pgStatStatementsTrack) &&
            java.util.Objects.deepEquals(this.tempFileLimit, other.tempFileLimit) &&
            java.util.Objects.deepEquals(this.logErrorVerbosity, other.logErrorVerbosity) &&
            java.util.Objects.deepEquals(this.logMinDurationStatement, other.logMinDurationStatement) &&
            java.util.Objects.deepEquals(this.maxStandbyStreamingDelay, other.maxStandbyStreamingDelay) &&
            java.util.Objects.deepEquals(this.jit, other.jit) &&
            java.util.Objects.deepEquals(this.maxStandbyArchiveDelay, other.maxStandbyArchiveDelay) &&
            java.util.Objects.deepEquals(this.bgWriter, other.bgWriter);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            trackActivityQuerySize,
            timezone,
            trackIoTiming,
            pgStatMonitorPgsmEnableQueryPlan,
            maxFilesPerProcess,
            pgStatMonitorPgsmMaxBuckets,
            wal,
            defaultToastCompression,
            deadlockTimeout,
            idleInTransactionSessionTimeout,
            maxPredLocksPerTransaction,
            maxReplicationSlots,
            autovacuum,
            maxParallelWorkersPerGather,
            pgPartmanBgwInterval,
            logLinePrefix,
            logTempFiles,
            maxLocksPerTransaction,
            trackCommitTimestamp,
            trackFunctions,
            maxStackDepth,
            maxParallelWorkers,
            pgPartmanBgwRole,
            maxLogicalReplicationWorkers,
            maxPreparedTransactions,
            maxWorkerProcesses,
            pgStatStatementsTrack,
            tempFileLimit,
            logErrorVerbosity,
            logMinDurationStatement,
            maxStandbyStreamingDelay,
            jit,
            maxStandbyArchiveDelay,
            bgWriter);
    }
    
    @Override
    public String toString() {
        return Utils.toString(JsonSchemaPg.class,
                "trackActivityQuerySize", trackActivityQuerySize,
                "timezone", timezone,
                "trackIoTiming", trackIoTiming,
                "pgStatMonitorPgsmEnableQueryPlan", pgStatMonitorPgsmEnableQueryPlan,
                "maxFilesPerProcess", maxFilesPerProcess,
                "pgStatMonitorPgsmMaxBuckets", pgStatMonitorPgsmMaxBuckets,
                "wal", wal,
                "defaultToastCompression", defaultToastCompression,
                "deadlockTimeout", deadlockTimeout,
                "idleInTransactionSessionTimeout", idleInTransactionSessionTimeout,
                "maxPredLocksPerTransaction", maxPredLocksPerTransaction,
                "maxReplicationSlots", maxReplicationSlots,
                "autovacuum", autovacuum,
                "maxParallelWorkersPerGather", maxParallelWorkersPerGather,
                "pgPartmanBgwInterval", pgPartmanBgwInterval,
                "logLinePrefix", logLinePrefix,
                "logTempFiles", logTempFiles,
                "maxLocksPerTransaction", maxLocksPerTransaction,
                "trackCommitTimestamp", trackCommitTimestamp,
                "trackFunctions", trackFunctions,
                "maxStackDepth", maxStackDepth,
                "maxParallelWorkers", maxParallelWorkers,
                "pgPartmanBgwRole", pgPartmanBgwRole,
                "maxLogicalReplicationWorkers", maxLogicalReplicationWorkers,
                "maxPreparedTransactions", maxPreparedTransactions,
                "maxWorkerProcesses", maxWorkerProcesses,
                "pgStatStatementsTrack", pgStatStatementsTrack,
                "tempFileLimit", tempFileLimit,
                "logErrorVerbosity", logErrorVerbosity,
                "logMinDurationStatement", logMinDurationStatement,
                "maxStandbyStreamingDelay", maxStandbyStreamingDelay,
                "jit", jit,
                "maxStandbyArchiveDelay", maxStandbyArchiveDelay,
                "bgWriter", bgWriter);
    }
    
    public final static class Builder {
 
        private Optional<? extends Long> trackActivityQuerySize = Optional.empty();
 
        private Optional<? extends String> timezone = Optional.empty();
 
        private Optional<? extends TrackIoTiming> trackIoTiming = Optional.empty();
 
        private Optional<? extends Boolean> pgStatMonitorPgsmEnableQueryPlan = Optional.empty();
 
        private Optional<? extends Long> maxFilesPerProcess = Optional.empty();
 
        private Optional<? extends Long> pgStatMonitorPgsmMaxBuckets = Optional.empty();
 
        private Optional<? extends WriteAheadLogWALSettings> wal = Optional.empty();
 
        private Optional<? extends DefaultToastCompression> defaultToastCompression = Optional.empty();
 
        private Optional<? extends Long> deadlockTimeout = Optional.empty();
 
        private Optional<? extends Long> idleInTransactionSessionTimeout = Optional.empty();
 
        private Optional<? extends Long> maxPredLocksPerTransaction = Optional.empty();
 
        private Optional<? extends Long> maxReplicationSlots = Optional.empty();
 
        private Optional<? extends AutovacuumSettings> autovacuum = Optional.empty();
 
        private Optional<? extends Long> maxParallelWorkersPerGather = Optional.empty();
 
        private Optional<? extends Long> pgPartmanBgwInterval = Optional.empty();
 
        private Optional<? extends LogLinePrefix> logLinePrefix = Optional.empty();
 
        private Optional<? extends Long> logTempFiles = Optional.empty();
 
        private Optional<? extends Long> maxLocksPerTransaction = Optional.empty();
 
        private Optional<? extends TrackCommitTimestamp> trackCommitTimestamp = Optional.empty();
 
        private Optional<? extends TrackFunctions> trackFunctions = Optional.empty();
 
        private Optional<? extends Long> maxStackDepth = Optional.empty();
 
        private Optional<? extends Long> maxParallelWorkers = Optional.empty();
 
        private Optional<? extends String> pgPartmanBgwRole = Optional.empty();
 
        private Optional<? extends Long> maxLogicalReplicationWorkers = Optional.empty();
 
        private Optional<? extends Long> maxPreparedTransactions = Optional.empty();
 
        private Optional<? extends Long> maxWorkerProcesses = Optional.empty();
 
        private Optional<? extends PgStatStatementsTrack> pgStatStatementsTrack = Optional.empty();
 
        private Optional<? extends Long> tempFileLimit = Optional.empty();
 
        private Optional<? extends LogErrorVerbosity> logErrorVerbosity = Optional.empty();
 
        private Optional<? extends Long> logMinDurationStatement = Optional.empty();
 
        private Optional<? extends Long> maxStandbyStreamingDelay = Optional.empty();
 
        private Optional<? extends Boolean> jit = Optional.empty();
 
        private Optional<? extends Long> maxStandbyArchiveDelay = Optional.empty();
 
        private Optional<? extends BackgroundBGWriterSettings> bgWriter = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Specifies the number of bytes reserved to track the currently executing command for each active session.
         */
        public Builder trackActivityQuerySize(long trackActivityQuerySize) {
            Utils.checkNotNull(trackActivityQuerySize, "trackActivityQuerySize");
            this.trackActivityQuerySize = Optional.ofNullable(trackActivityQuerySize);
            return this;
        }

        /**
         * Specifies the number of bytes reserved to track the currently executing command for each active session.
         */
        public Builder trackActivityQuerySize(Optional<? extends Long> trackActivityQuerySize) {
            Utils.checkNotNull(trackActivityQuerySize, "trackActivityQuerySize");
            this.trackActivityQuerySize = trackActivityQuerySize;
            return this;
        }

        /**
         * PostgreSQL service timezone
         */
        public Builder timezone(String timezone) {
            Utils.checkNotNull(timezone, "timezone");
            this.timezone = Optional.ofNullable(timezone);
            return this;
        }

        /**
         * PostgreSQL service timezone
         */
        public Builder timezone(Optional<? extends String> timezone) {
            Utils.checkNotNull(timezone, "timezone");
            this.timezone = timezone;
            return this;
        }

        /**
         * Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
         */
        public Builder trackIoTiming(TrackIoTiming trackIoTiming) {
            Utils.checkNotNull(trackIoTiming, "trackIoTiming");
            this.trackIoTiming = Optional.ofNullable(trackIoTiming);
            return this;
        }

        /**
         * Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
         */
        public Builder trackIoTiming(Optional<? extends TrackIoTiming> trackIoTiming) {
            Utils.checkNotNull(trackIoTiming, "trackIoTiming");
            this.trackIoTiming = trackIoTiming;
            return this;
        }

        /**
         * Enables or disables query plan monitoring
         */
        public Builder pgStatMonitorPgsmEnableQueryPlan(boolean pgStatMonitorPgsmEnableQueryPlan) {
            Utils.checkNotNull(pgStatMonitorPgsmEnableQueryPlan, "pgStatMonitorPgsmEnableQueryPlan");
            this.pgStatMonitorPgsmEnableQueryPlan = Optional.ofNullable(pgStatMonitorPgsmEnableQueryPlan);
            return this;
        }

        /**
         * Enables or disables query plan monitoring
         */
        public Builder pgStatMonitorPgsmEnableQueryPlan(Optional<? extends Boolean> pgStatMonitorPgsmEnableQueryPlan) {
            Utils.checkNotNull(pgStatMonitorPgsmEnableQueryPlan, "pgStatMonitorPgsmEnableQueryPlan");
            this.pgStatMonitorPgsmEnableQueryPlan = pgStatMonitorPgsmEnableQueryPlan;
            return this;
        }

        /**
         * PostgreSQL maximum number of files that can be open per process
         */
        public Builder maxFilesPerProcess(long maxFilesPerProcess) {
            Utils.checkNotNull(maxFilesPerProcess, "maxFilesPerProcess");
            this.maxFilesPerProcess = Optional.ofNullable(maxFilesPerProcess);
            return this;
        }

        /**
         * PostgreSQL maximum number of files that can be open per process
         */
        public Builder maxFilesPerProcess(Optional<? extends Long> maxFilesPerProcess) {
            Utils.checkNotNull(maxFilesPerProcess, "maxFilesPerProcess");
            this.maxFilesPerProcess = maxFilesPerProcess;
            return this;
        }

        /**
         * Sets the maximum number of buckets 
         */
        public Builder pgStatMonitorPgsmMaxBuckets(long pgStatMonitorPgsmMaxBuckets) {
            Utils.checkNotNull(pgStatMonitorPgsmMaxBuckets, "pgStatMonitorPgsmMaxBuckets");
            this.pgStatMonitorPgsmMaxBuckets = Optional.ofNullable(pgStatMonitorPgsmMaxBuckets);
            return this;
        }

        /**
         * Sets the maximum number of buckets 
         */
        public Builder pgStatMonitorPgsmMaxBuckets(Optional<? extends Long> pgStatMonitorPgsmMaxBuckets) {
            Utils.checkNotNull(pgStatMonitorPgsmMaxBuckets, "pgStatMonitorPgsmMaxBuckets");
            this.pgStatMonitorPgsmMaxBuckets = pgStatMonitorPgsmMaxBuckets;
            return this;
        }

        public Builder wal(WriteAheadLogWALSettings wal) {
            Utils.checkNotNull(wal, "wal");
            this.wal = Optional.ofNullable(wal);
            return this;
        }

        public Builder wal(Optional<? extends WriteAheadLogWALSettings> wal) {
            Utils.checkNotNull(wal, "wal");
            this.wal = wal;
            return this;
        }

        /**
         * Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
         */
        public Builder defaultToastCompression(DefaultToastCompression defaultToastCompression) {
            Utils.checkNotNull(defaultToastCompression, "defaultToastCompression");
            this.defaultToastCompression = Optional.ofNullable(defaultToastCompression);
            return this;
        }

        /**
         * Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
         */
        public Builder defaultToastCompression(Optional<? extends DefaultToastCompression> defaultToastCompression) {
            Utils.checkNotNull(defaultToastCompression, "defaultToastCompression");
            this.defaultToastCompression = defaultToastCompression;
            return this;
        }

        /**
         * This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
         */
        public Builder deadlockTimeout(long deadlockTimeout) {
            Utils.checkNotNull(deadlockTimeout, "deadlockTimeout");
            this.deadlockTimeout = Optional.ofNullable(deadlockTimeout);
            return this;
        }

        /**
         * This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
         */
        public Builder deadlockTimeout(Optional<? extends Long> deadlockTimeout) {
            Utils.checkNotNull(deadlockTimeout, "deadlockTimeout");
            this.deadlockTimeout = deadlockTimeout;
            return this;
        }

        /**
         * Time out sessions with open transactions after this number of milliseconds
         */
        public Builder idleInTransactionSessionTimeout(long idleInTransactionSessionTimeout) {
            Utils.checkNotNull(idleInTransactionSessionTimeout, "idleInTransactionSessionTimeout");
            this.idleInTransactionSessionTimeout = Optional.ofNullable(idleInTransactionSessionTimeout);
            return this;
        }

        /**
         * Time out sessions with open transactions after this number of milliseconds
         */
        public Builder idleInTransactionSessionTimeout(Optional<? extends Long> idleInTransactionSessionTimeout) {
            Utils.checkNotNull(idleInTransactionSessionTimeout, "idleInTransactionSessionTimeout");
            this.idleInTransactionSessionTimeout = idleInTransactionSessionTimeout;
            return this;
        }

        /**
         * PostgreSQL maximum predicate locks per transaction
         */
        public Builder maxPredLocksPerTransaction(long maxPredLocksPerTransaction) {
            Utils.checkNotNull(maxPredLocksPerTransaction, "maxPredLocksPerTransaction");
            this.maxPredLocksPerTransaction = Optional.ofNullable(maxPredLocksPerTransaction);
            return this;
        }

        /**
         * PostgreSQL maximum predicate locks per transaction
         */
        public Builder maxPredLocksPerTransaction(Optional<? extends Long> maxPredLocksPerTransaction) {
            Utils.checkNotNull(maxPredLocksPerTransaction, "maxPredLocksPerTransaction");
            this.maxPredLocksPerTransaction = maxPredLocksPerTransaction;
            return this;
        }

        /**
         * PostgreSQL maximum replication slots
         */
        public Builder maxReplicationSlots(long maxReplicationSlots) {
            Utils.checkNotNull(maxReplicationSlots, "maxReplicationSlots");
            this.maxReplicationSlots = Optional.ofNullable(maxReplicationSlots);
            return this;
        }

        /**
         * PostgreSQL maximum replication slots
         */
        public Builder maxReplicationSlots(Optional<? extends Long> maxReplicationSlots) {
            Utils.checkNotNull(maxReplicationSlots, "maxReplicationSlots");
            this.maxReplicationSlots = maxReplicationSlots;
            return this;
        }

        public Builder autovacuum(AutovacuumSettings autovacuum) {
            Utils.checkNotNull(autovacuum, "autovacuum");
            this.autovacuum = Optional.ofNullable(autovacuum);
            return this;
        }

        public Builder autovacuum(Optional<? extends AutovacuumSettings> autovacuum) {
            Utils.checkNotNull(autovacuum, "autovacuum");
            this.autovacuum = autovacuum;
            return this;
        }

        /**
         * Sets the maximum number of workers that can be started by a single Gather or Gather Merge node
         */
        public Builder maxParallelWorkersPerGather(long maxParallelWorkersPerGather) {
            Utils.checkNotNull(maxParallelWorkersPerGather, "maxParallelWorkersPerGather");
            this.maxParallelWorkersPerGather = Optional.ofNullable(maxParallelWorkersPerGather);
            return this;
        }

        /**
         * Sets the maximum number of workers that can be started by a single Gather or Gather Merge node
         */
        public Builder maxParallelWorkersPerGather(Optional<? extends Long> maxParallelWorkersPerGather) {
            Utils.checkNotNull(maxParallelWorkersPerGather, "maxParallelWorkersPerGather");
            this.maxParallelWorkersPerGather = maxParallelWorkersPerGather;
            return this;
        }

        /**
         * Sets the time interval to run pg_partman's scheduled tasks
         */
        public Builder pgPartmanBgwInterval(long pgPartmanBgwInterval) {
            Utils.checkNotNull(pgPartmanBgwInterval, "pgPartmanBgwInterval");
            this.pgPartmanBgwInterval = Optional.ofNullable(pgPartmanBgwInterval);
            return this;
        }

        /**
         * Sets the time interval to run pg_partman's scheduled tasks
         */
        public Builder pgPartmanBgwInterval(Optional<? extends Long> pgPartmanBgwInterval) {
            Utils.checkNotNull(pgPartmanBgwInterval, "pgPartmanBgwInterval");
            this.pgPartmanBgwInterval = pgPartmanBgwInterval;
            return this;
        }

        /**
         * Choose from one of the available log-formats. These can support popular log analyzers like pgbadger, pganalyze etc.
         */
        public Builder logLinePrefix(LogLinePrefix logLinePrefix) {
            Utils.checkNotNull(logLinePrefix, "logLinePrefix");
            this.logLinePrefix = Optional.ofNullable(logLinePrefix);
            return this;
        }

        /**
         * Choose from one of the available log-formats. These can support popular log analyzers like pgbadger, pganalyze etc.
         */
        public Builder logLinePrefix(Optional<? extends LogLinePrefix> logLinePrefix) {
            Utils.checkNotNull(logLinePrefix, "logLinePrefix");
            this.logLinePrefix = logLinePrefix;
            return this;
        }

        /**
         * Log statements for each temporary file created larger than this number of kilobytes, -1 disables
         */
        public Builder logTempFiles(long logTempFiles) {
            Utils.checkNotNull(logTempFiles, "logTempFiles");
            this.logTempFiles = Optional.ofNullable(logTempFiles);
            return this;
        }

        /**
         * Log statements for each temporary file created larger than this number of kilobytes, -1 disables
         */
        public Builder logTempFiles(Optional<? extends Long> logTempFiles) {
            Utils.checkNotNull(logTempFiles, "logTempFiles");
            this.logTempFiles = logTempFiles;
            return this;
        }

        /**
         * PostgreSQL maximum locks per transaction
         */
        public Builder maxLocksPerTransaction(long maxLocksPerTransaction) {
            Utils.checkNotNull(maxLocksPerTransaction, "maxLocksPerTransaction");
            this.maxLocksPerTransaction = Optional.ofNullable(maxLocksPerTransaction);
            return this;
        }

        /**
         * PostgreSQL maximum locks per transaction
         */
        public Builder maxLocksPerTransaction(Optional<? extends Long> maxLocksPerTransaction) {
            Utils.checkNotNull(maxLocksPerTransaction, "maxLocksPerTransaction");
            this.maxLocksPerTransaction = maxLocksPerTransaction;
            return this;
        }

        /**
         * Record commit time of transactions.
         */
        public Builder trackCommitTimestamp(TrackCommitTimestamp trackCommitTimestamp) {
            Utils.checkNotNull(trackCommitTimestamp, "trackCommitTimestamp");
            this.trackCommitTimestamp = Optional.ofNullable(trackCommitTimestamp);
            return this;
        }

        /**
         * Record commit time of transactions.
         */
        public Builder trackCommitTimestamp(Optional<? extends TrackCommitTimestamp> trackCommitTimestamp) {
            Utils.checkNotNull(trackCommitTimestamp, "trackCommitTimestamp");
            this.trackCommitTimestamp = trackCommitTimestamp;
            return this;
        }

        /**
         * Enables tracking of function call counts and time used.
         */
        public Builder trackFunctions(TrackFunctions trackFunctions) {
            Utils.checkNotNull(trackFunctions, "trackFunctions");
            this.trackFunctions = Optional.ofNullable(trackFunctions);
            return this;
        }

        /**
         * Enables tracking of function call counts and time used.
         */
        public Builder trackFunctions(Optional<? extends TrackFunctions> trackFunctions) {
            Utils.checkNotNull(trackFunctions, "trackFunctions");
            this.trackFunctions = trackFunctions;
            return this;
        }

        /**
         * Maximum depth of the stack in bytes
         */
        public Builder maxStackDepth(long maxStackDepth) {
            Utils.checkNotNull(maxStackDepth, "maxStackDepth");
            this.maxStackDepth = Optional.ofNullable(maxStackDepth);
            return this;
        }

        /**
         * Maximum depth of the stack in bytes
         */
        public Builder maxStackDepth(Optional<? extends Long> maxStackDepth) {
            Utils.checkNotNull(maxStackDepth, "maxStackDepth");
            this.maxStackDepth = maxStackDepth;
            return this;
        }

        /**
         * Sets the maximum number of workers that the system can support for parallel queries
         */
        public Builder maxParallelWorkers(long maxParallelWorkers) {
            Utils.checkNotNull(maxParallelWorkers, "maxParallelWorkers");
            this.maxParallelWorkers = Optional.ofNullable(maxParallelWorkers);
            return this;
        }

        /**
         * Sets the maximum number of workers that the system can support for parallel queries
         */
        public Builder maxParallelWorkers(Optional<? extends Long> maxParallelWorkers) {
            Utils.checkNotNull(maxParallelWorkers, "maxParallelWorkers");
            this.maxParallelWorkers = maxParallelWorkers;
            return this;
        }

        /**
         * Controls which role to use for pg_partman's scheduled background tasks.
         */
        public Builder pgPartmanBgwRole(String pgPartmanBgwRole) {
            Utils.checkNotNull(pgPartmanBgwRole, "pgPartmanBgwRole");
            this.pgPartmanBgwRole = Optional.ofNullable(pgPartmanBgwRole);
            return this;
        }

        /**
         * Controls which role to use for pg_partman's scheduled background tasks.
         */
        public Builder pgPartmanBgwRole(Optional<? extends String> pgPartmanBgwRole) {
            Utils.checkNotNull(pgPartmanBgwRole, "pgPartmanBgwRole");
            this.pgPartmanBgwRole = pgPartmanBgwRole;
            return this;
        }

        /**
         * PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers)
         */
        public Builder maxLogicalReplicationWorkers(long maxLogicalReplicationWorkers) {
            Utils.checkNotNull(maxLogicalReplicationWorkers, "maxLogicalReplicationWorkers");
            this.maxLogicalReplicationWorkers = Optional.ofNullable(maxLogicalReplicationWorkers);
            return this;
        }

        /**
         * PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers)
         */
        public Builder maxLogicalReplicationWorkers(Optional<? extends Long> maxLogicalReplicationWorkers) {
            Utils.checkNotNull(maxLogicalReplicationWorkers, "maxLogicalReplicationWorkers");
            this.maxLogicalReplicationWorkers = maxLogicalReplicationWorkers;
            return this;
        }

        /**
         * PostgreSQL maximum prepared transactions
         */
        public Builder maxPreparedTransactions(long maxPreparedTransactions) {
            Utils.checkNotNull(maxPreparedTransactions, "maxPreparedTransactions");
            this.maxPreparedTransactions = Optional.ofNullable(maxPreparedTransactions);
            return this;
        }

        /**
         * PostgreSQL maximum prepared transactions
         */
        public Builder maxPreparedTransactions(Optional<? extends Long> maxPreparedTransactions) {
            Utils.checkNotNull(maxPreparedTransactions, "maxPreparedTransactions");
            this.maxPreparedTransactions = maxPreparedTransactions;
            return this;
        }

        /**
         * Sets the maximum number of background processes that the system can support
         */
        public Builder maxWorkerProcesses(long maxWorkerProcesses) {
            Utils.checkNotNull(maxWorkerProcesses, "maxWorkerProcesses");
            this.maxWorkerProcesses = Optional.ofNullable(maxWorkerProcesses);
            return this;
        }

        /**
         * Sets the maximum number of background processes that the system can support
         */
        public Builder maxWorkerProcesses(Optional<? extends Long> maxWorkerProcesses) {
            Utils.checkNotNull(maxWorkerProcesses, "maxWorkerProcesses");
            this.maxWorkerProcesses = maxWorkerProcesses;
            return this;
        }

        /**
         * Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
         */
        public Builder pgStatStatementsTrack(PgStatStatementsTrack pgStatStatementsTrack) {
            Utils.checkNotNull(pgStatStatementsTrack, "pgStatStatementsTrack");
            this.pgStatStatementsTrack = Optional.ofNullable(pgStatStatementsTrack);
            return this;
        }

        /**
         * Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
         */
        public Builder pgStatStatementsTrack(Optional<? extends PgStatStatementsTrack> pgStatStatementsTrack) {
            Utils.checkNotNull(pgStatStatementsTrack, "pgStatStatementsTrack");
            this.pgStatStatementsTrack = pgStatStatementsTrack;
            return this;
        }

        /**
         * PostgreSQL temporary file limit in KiB, -1 for unlimited
         */
        public Builder tempFileLimit(long tempFileLimit) {
            Utils.checkNotNull(tempFileLimit, "tempFileLimit");
            this.tempFileLimit = Optional.ofNullable(tempFileLimit);
            return this;
        }

        /**
         * PostgreSQL temporary file limit in KiB, -1 for unlimited
         */
        public Builder tempFileLimit(Optional<? extends Long> tempFileLimit) {
            Utils.checkNotNull(tempFileLimit, "tempFileLimit");
            this.tempFileLimit = tempFileLimit;
            return this;
        }

        /**
         * Controls the amount of detail written in the server log for each message that is logged.
         */
        public Builder logErrorVerbosity(LogErrorVerbosity logErrorVerbosity) {
            Utils.checkNotNull(logErrorVerbosity, "logErrorVerbosity");
            this.logErrorVerbosity = Optional.ofNullable(logErrorVerbosity);
            return this;
        }

        /**
         * Controls the amount of detail written in the server log for each message that is logged.
         */
        public Builder logErrorVerbosity(Optional<? extends LogErrorVerbosity> logErrorVerbosity) {
            Utils.checkNotNull(logErrorVerbosity, "logErrorVerbosity");
            this.logErrorVerbosity = logErrorVerbosity;
            return this;
        }

        /**
         * Log statements that take more than this number of milliseconds to run, -1 disables
         */
        public Builder logMinDurationStatement(long logMinDurationStatement) {
            Utils.checkNotNull(logMinDurationStatement, "logMinDurationStatement");
            this.logMinDurationStatement = Optional.ofNullable(logMinDurationStatement);
            return this;
        }

        /**
         * Log statements that take more than this number of milliseconds to run, -1 disables
         */
        public Builder logMinDurationStatement(Optional<? extends Long> logMinDurationStatement) {
            Utils.checkNotNull(logMinDurationStatement, "logMinDurationStatement");
            this.logMinDurationStatement = logMinDurationStatement;
            return this;
        }

        /**
         * Max standby streaming delay in milliseconds
         */
        public Builder maxStandbyStreamingDelay(long maxStandbyStreamingDelay) {
            Utils.checkNotNull(maxStandbyStreamingDelay, "maxStandbyStreamingDelay");
            this.maxStandbyStreamingDelay = Optional.ofNullable(maxStandbyStreamingDelay);
            return this;
        }

        /**
         * Max standby streaming delay in milliseconds
         */
        public Builder maxStandbyStreamingDelay(Optional<? extends Long> maxStandbyStreamingDelay) {
            Utils.checkNotNull(maxStandbyStreamingDelay, "maxStandbyStreamingDelay");
            this.maxStandbyStreamingDelay = maxStandbyStreamingDelay;
            return this;
        }

        /**
         * Controls system-wide use of Just-in-Time Compilation (JIT).
         */
        public Builder jit(boolean jit) {
            Utils.checkNotNull(jit, "jit");
            this.jit = Optional.ofNullable(jit);
            return this;
        }

        /**
         * Controls system-wide use of Just-in-Time Compilation (JIT).
         */
        public Builder jit(Optional<? extends Boolean> jit) {
            Utils.checkNotNull(jit, "jit");
            this.jit = jit;
            return this;
        }

        /**
         * Max standby archive delay in milliseconds
         */
        public Builder maxStandbyArchiveDelay(long maxStandbyArchiveDelay) {
            Utils.checkNotNull(maxStandbyArchiveDelay, "maxStandbyArchiveDelay");
            this.maxStandbyArchiveDelay = Optional.ofNullable(maxStandbyArchiveDelay);
            return this;
        }

        /**
         * Max standby archive delay in milliseconds
         */
        public Builder maxStandbyArchiveDelay(Optional<? extends Long> maxStandbyArchiveDelay) {
            Utils.checkNotNull(maxStandbyArchiveDelay, "maxStandbyArchiveDelay");
            this.maxStandbyArchiveDelay = maxStandbyArchiveDelay;
            return this;
        }

        public Builder bgWriter(BackgroundBGWriterSettings bgWriter) {
            Utils.checkNotNull(bgWriter, "bgWriter");
            this.bgWriter = Optional.ofNullable(bgWriter);
            return this;
        }

        public Builder bgWriter(Optional<? extends BackgroundBGWriterSettings> bgWriter) {
            Utils.checkNotNull(bgWriter, "bgWriter");
            this.bgWriter = bgWriter;
            return this;
        }
        
        public JsonSchemaPg build() {
            return new JsonSchemaPg(
                trackActivityQuerySize,
                timezone,
                trackIoTiming,
                pgStatMonitorPgsmEnableQueryPlan,
                maxFilesPerProcess,
                pgStatMonitorPgsmMaxBuckets,
                wal,
                defaultToastCompression,
                deadlockTimeout,
                idleInTransactionSessionTimeout,
                maxPredLocksPerTransaction,
                maxReplicationSlots,
                autovacuum,
                maxParallelWorkersPerGather,
                pgPartmanBgwInterval,
                logLinePrefix,
                logTempFiles,
                maxLocksPerTransaction,
                trackCommitTimestamp,
                trackFunctions,
                maxStackDepth,
                maxParallelWorkers,
                pgPartmanBgwRole,
                maxLogicalReplicationWorkers,
                maxPreparedTransactions,
                maxWorkerProcesses,
                pgStatStatementsTrack,
                tempFileLimit,
                logErrorVerbosity,
                logMinDurationStatement,
                maxStandbyStreamingDelay,
                jit,
                maxStandbyArchiveDelay,
                bgWriter);
        }
    }
}

