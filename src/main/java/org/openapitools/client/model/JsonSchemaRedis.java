/*
 * Exoscale Public API
 *  Infrastructure automation API, allowing programmatic access to all Exoscale products and services.  The [OpenAPI Specification](http://spec.openapis.org/oas/v3.0.3.html) source of this documentation can be obtained here:  * [JSON format](https://openapi-v2.exoscale.com/source.json) * [YAML format](https://openapi-v2.exoscale.com/source.yaml)
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: api@exoscale.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * JsonSchemaRedis
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-03-27T17:14:44.205710495Z[Etc/UTC]", comments = "Generator version: 7.5.0-SNAPSHOT")
public class JsonSchemaRedis {
  public static final String SERIALIZED_NAME_SSL = "ssl";
  @SerializedName(SERIALIZED_NAME_SSL)
  private Boolean ssl = true;

  public static final String SERIALIZED_NAME_LFU_LOG_FACTOR = "lfu_log_factor";
  @SerializedName(SERIALIZED_NAME_LFU_LOG_FACTOR)
  private Integer lfuLogFactor = 10;

  /**
   * Gets or Sets maxmemoryPolicy
   */
  @JsonAdapter(MaxmemoryPolicyEnum.Adapter.class)
  public enum MaxmemoryPolicyEnum {
    NOEVICTION("noeviction"),
    
    ALLKEYS_LRU("allkeys-lru"),
    
    VOLATILE_LRU("volatile-lru"),
    
    ALLKEYS_RANDOM("allkeys-random"),
    
    VOLATILE_RANDOM("volatile-random"),
    
    VOLATILE_TTL("volatile-ttl"),
    
    VOLATILE_LFU("volatile-lfu"),
    
    ALLKEYS_LFU("allkeys-lfu");

    private String value;

    MaxmemoryPolicyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MaxmemoryPolicyEnum fromValue(String value) {
      for (MaxmemoryPolicyEnum b : MaxmemoryPolicyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<MaxmemoryPolicyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MaxmemoryPolicyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MaxmemoryPolicyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MaxmemoryPolicyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      MaxmemoryPolicyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MAXMEMORY_POLICY = "maxmemory_policy";
  @SerializedName(SERIALIZED_NAME_MAXMEMORY_POLICY)
  private MaxmemoryPolicyEnum maxmemoryPolicy = MaxmemoryPolicyEnum.NOEVICTION;

  public static final String SERIALIZED_NAME_IO_THREADS = "io_threads";
  @SerializedName(SERIALIZED_NAME_IO_THREADS)
  private Integer ioThreads;

  public static final String SERIALIZED_NAME_LFU_DECAY_TIME = "lfu_decay_time";
  @SerializedName(SERIALIZED_NAME_LFU_DECAY_TIME)
  private Integer lfuDecayTime = 1;

  public static final String SERIALIZED_NAME_PUBSUB_CLIENT_OUTPUT_BUFFER_LIMIT = "pubsub_client_output_buffer_limit";
  @SerializedName(SERIALIZED_NAME_PUBSUB_CLIENT_OUTPUT_BUFFER_LIMIT)
  private Integer pubsubClientOutputBufferLimit;

  public static final String SERIALIZED_NAME_NOTIFY_KEYSPACE_EVENTS = "notify_keyspace_events";
  @SerializedName(SERIALIZED_NAME_NOTIFY_KEYSPACE_EVENTS)
  private String notifyKeyspaceEvents = "";

  /**
   * When persistence is &#39;rdb&#39;, Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is &#39;off&#39;, no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can&#39;t be forked.
   */
  @JsonAdapter(PersistenceEnum.Adapter.class)
  public enum PersistenceEnum {
    OFF("off"),
    
    RDB("rdb");

    private String value;

    PersistenceEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PersistenceEnum fromValue(String value) {
      for (PersistenceEnum b : PersistenceEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PersistenceEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PersistenceEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PersistenceEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PersistenceEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PersistenceEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PERSISTENCE = "persistence";
  @SerializedName(SERIALIZED_NAME_PERSISTENCE)
  private PersistenceEnum persistence;

  public static final String SERIALIZED_NAME_TIMEOUT = "timeout";
  @SerializedName(SERIALIZED_NAME_TIMEOUT)
  private Integer timeout = 300;

  /**
   * Determines default pub/sub channels&#39; ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn&#39;t affect Redis configuration acl-pubsub-default.
   */
  @JsonAdapter(AclChannelsDefaultEnum.Adapter.class)
  public enum AclChannelsDefaultEnum {
    ALLCHANNELS("allchannels"),
    
    RESETCHANNELS("resetchannels");

    private String value;

    AclChannelsDefaultEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AclChannelsDefaultEnum fromValue(String value) {
      for (AclChannelsDefaultEnum b : AclChannelsDefaultEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AclChannelsDefaultEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AclChannelsDefaultEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AclChannelsDefaultEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AclChannelsDefaultEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AclChannelsDefaultEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ACL_CHANNELS_DEFAULT = "acl_channels_default";
  @SerializedName(SERIALIZED_NAME_ACL_CHANNELS_DEFAULT)
  private AclChannelsDefaultEnum aclChannelsDefault;

  public static final String SERIALIZED_NAME_NUMBER_OF_DATABASES = "number_of_databases";
  @SerializedName(SERIALIZED_NAME_NUMBER_OF_DATABASES)
  private Integer numberOfDatabases;

  public JsonSchemaRedis() {
  }

  public JsonSchemaRedis ssl(Boolean ssl) {
    this.ssl = ssl;
    return this;
  }

   /**
   * Get ssl
   * @return ssl
  **/
  @javax.annotation.Nullable
  public Boolean getSsl() {
    return ssl;
  }

  public void setSsl(Boolean ssl) {
    this.ssl = ssl;
  }


  public JsonSchemaRedis lfuLogFactor(Integer lfuLogFactor) {
    this.lfuLogFactor = lfuLogFactor;
    return this;
  }

   /**
   * Get lfuLogFactor
   * minimum: 0
   * maximum: 100
   * @return lfuLogFactor
  **/
  @javax.annotation.Nullable
  public Integer getLfuLogFactor() {
    return lfuLogFactor;
  }

  public void setLfuLogFactor(Integer lfuLogFactor) {
    this.lfuLogFactor = lfuLogFactor;
  }


  public JsonSchemaRedis maxmemoryPolicy(MaxmemoryPolicyEnum maxmemoryPolicy) {
    this.maxmemoryPolicy = maxmemoryPolicy;
    return this;
  }

   /**
   * Get maxmemoryPolicy
   * @return maxmemoryPolicy
  **/
  @javax.annotation.Nullable
  public MaxmemoryPolicyEnum getMaxmemoryPolicy() {
    return maxmemoryPolicy;
  }

  public void setMaxmemoryPolicy(MaxmemoryPolicyEnum maxmemoryPolicy) {
    this.maxmemoryPolicy = maxmemoryPolicy;
  }


  public JsonSchemaRedis ioThreads(Integer ioThreads) {
    this.ioThreads = ioThreads;
    return this;
  }

   /**
   * Set Redis IO thread count. Changing this will cause a restart of the Redis service.
   * minimum: 1
   * maximum: 32
   * @return ioThreads
  **/
  @javax.annotation.Nullable
  public Integer getIoThreads() {
    return ioThreads;
  }

  public void setIoThreads(Integer ioThreads) {
    this.ioThreads = ioThreads;
  }


  public JsonSchemaRedis lfuDecayTime(Integer lfuDecayTime) {
    this.lfuDecayTime = lfuDecayTime;
    return this;
  }

   /**
   * Get lfuDecayTime
   * minimum: 1
   * maximum: 120
   * @return lfuDecayTime
  **/
  @javax.annotation.Nullable
  public Integer getLfuDecayTime() {
    return lfuDecayTime;
  }

  public void setLfuDecayTime(Integer lfuDecayTime) {
    this.lfuDecayTime = lfuDecayTime;
  }


  public JsonSchemaRedis pubsubClientOutputBufferLimit(Integer pubsubClientOutputBufferLimit) {
    this.pubsubClientOutputBufferLimit = pubsubClientOutputBufferLimit;
    return this;
  }

   /**
   * Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
   * minimum: 32
   * maximum: 512
   * @return pubsubClientOutputBufferLimit
  **/
  @javax.annotation.Nullable
  public Integer getPubsubClientOutputBufferLimit() {
    return pubsubClientOutputBufferLimit;
  }

  public void setPubsubClientOutputBufferLimit(Integer pubsubClientOutputBufferLimit) {
    this.pubsubClientOutputBufferLimit = pubsubClientOutputBufferLimit;
  }


  public JsonSchemaRedis notifyKeyspaceEvents(String notifyKeyspaceEvents) {
    this.notifyKeyspaceEvents = notifyKeyspaceEvents;
    return this;
  }

   /**
   * Get notifyKeyspaceEvents
   * @return notifyKeyspaceEvents
  **/
  @javax.annotation.Nullable
  public String getNotifyKeyspaceEvents() {
    return notifyKeyspaceEvents;
  }

  public void setNotifyKeyspaceEvents(String notifyKeyspaceEvents) {
    this.notifyKeyspaceEvents = notifyKeyspaceEvents;
  }


  public JsonSchemaRedis persistence(PersistenceEnum persistence) {
    this.persistence = persistence;
    return this;
  }

   /**
   * When persistence is &#39;rdb&#39;, Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is &#39;off&#39;, no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can&#39;t be forked.
   * @return persistence
  **/
  @javax.annotation.Nullable
  public PersistenceEnum getPersistence() {
    return persistence;
  }

  public void setPersistence(PersistenceEnum persistence) {
    this.persistence = persistence;
  }


  public JsonSchemaRedis timeout(Integer timeout) {
    this.timeout = timeout;
    return this;
  }

   /**
   * Get timeout
   * minimum: 0
   * maximum: 31536000
   * @return timeout
  **/
  @javax.annotation.Nullable
  public Integer getTimeout() {
    return timeout;
  }

  public void setTimeout(Integer timeout) {
    this.timeout = timeout;
  }


  public JsonSchemaRedis aclChannelsDefault(AclChannelsDefaultEnum aclChannelsDefault) {
    this.aclChannelsDefault = aclChannelsDefault;
    return this;
  }

   /**
   * Determines default pub/sub channels&#39; ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn&#39;t affect Redis configuration acl-pubsub-default.
   * @return aclChannelsDefault
  **/
  @javax.annotation.Nullable
  public AclChannelsDefaultEnum getAclChannelsDefault() {
    return aclChannelsDefault;
  }

  public void setAclChannelsDefault(AclChannelsDefaultEnum aclChannelsDefault) {
    this.aclChannelsDefault = aclChannelsDefault;
  }


  public JsonSchemaRedis numberOfDatabases(Integer numberOfDatabases) {
    this.numberOfDatabases = numberOfDatabases;
    return this;
  }

   /**
   * Set number of Redis databases. Changing this will cause a restart of the Redis service.
   * minimum: 1
   * maximum: 128
   * @return numberOfDatabases
  **/
  @javax.annotation.Nullable
  public Integer getNumberOfDatabases() {
    return numberOfDatabases;
  }

  public void setNumberOfDatabases(Integer numberOfDatabases) {
    this.numberOfDatabases = numberOfDatabases;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    JsonSchemaRedis jsonSchemaRedis = (JsonSchemaRedis) o;
    return Objects.equals(this.ssl, jsonSchemaRedis.ssl) &&
        Objects.equals(this.lfuLogFactor, jsonSchemaRedis.lfuLogFactor) &&
        Objects.equals(this.maxmemoryPolicy, jsonSchemaRedis.maxmemoryPolicy) &&
        Objects.equals(this.ioThreads, jsonSchemaRedis.ioThreads) &&
        Objects.equals(this.lfuDecayTime, jsonSchemaRedis.lfuDecayTime) &&
        Objects.equals(this.pubsubClientOutputBufferLimit, jsonSchemaRedis.pubsubClientOutputBufferLimit) &&
        Objects.equals(this.notifyKeyspaceEvents, jsonSchemaRedis.notifyKeyspaceEvents) &&
        Objects.equals(this.persistence, jsonSchemaRedis.persistence) &&
        Objects.equals(this.timeout, jsonSchemaRedis.timeout) &&
        Objects.equals(this.aclChannelsDefault, jsonSchemaRedis.aclChannelsDefault) &&
        Objects.equals(this.numberOfDatabases, jsonSchemaRedis.numberOfDatabases);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(ssl, lfuLogFactor, maxmemoryPolicy, ioThreads, lfuDecayTime, pubsubClientOutputBufferLimit, notifyKeyspaceEvents, persistence, timeout, aclChannelsDefault, numberOfDatabases);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class JsonSchemaRedis {\n");
    sb.append("    ssl: ").append(toIndentedString(ssl)).append("\n");
    sb.append("    lfuLogFactor: ").append(toIndentedString(lfuLogFactor)).append("\n");
    sb.append("    maxmemoryPolicy: ").append(toIndentedString(maxmemoryPolicy)).append("\n");
    sb.append("    ioThreads: ").append(toIndentedString(ioThreads)).append("\n");
    sb.append("    lfuDecayTime: ").append(toIndentedString(lfuDecayTime)).append("\n");
    sb.append("    pubsubClientOutputBufferLimit: ").append(toIndentedString(pubsubClientOutputBufferLimit)).append("\n");
    sb.append("    notifyKeyspaceEvents: ").append(toIndentedString(notifyKeyspaceEvents)).append("\n");
    sb.append("    persistence: ").append(toIndentedString(persistence)).append("\n");
    sb.append("    timeout: ").append(toIndentedString(timeout)).append("\n");
    sb.append("    aclChannelsDefault: ").append(toIndentedString(aclChannelsDefault)).append("\n");
    sb.append("    numberOfDatabases: ").append(toIndentedString(numberOfDatabases)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ssl");
    openapiFields.add("lfu_log_factor");
    openapiFields.add("maxmemory_policy");
    openapiFields.add("io_threads");
    openapiFields.add("lfu_decay_time");
    openapiFields.add("pubsub_client_output_buffer_limit");
    openapiFields.add("notify_keyspace_events");
    openapiFields.add("persistence");
    openapiFields.add("timeout");
    openapiFields.add("acl_channels_default");
    openapiFields.add("number_of_databases");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to JsonSchemaRedis
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!JsonSchemaRedis.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in JsonSchemaRedis is not found in the empty JSON string", JsonSchemaRedis.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!JsonSchemaRedis.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `JsonSchemaRedis` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("maxmemory_policy") != null && !jsonObj.get("maxmemory_policy").isJsonNull()) && !jsonObj.get("maxmemory_policy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxmemory_policy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxmemory_policy").toString()));
      }
      // validate the optional field `maxmemory_policy`
      if (jsonObj.get("maxmemory_policy") != null && !jsonObj.get("maxmemory_policy").isJsonNull()) {
        MaxmemoryPolicyEnum.validateJsonElement(jsonObj.get("maxmemory_policy"));
      }
      if ((jsonObj.get("notify_keyspace_events") != null && !jsonObj.get("notify_keyspace_events").isJsonNull()) && !jsonObj.get("notify_keyspace_events").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `notify_keyspace_events` to be a primitive type in the JSON string but got `%s`", jsonObj.get("notify_keyspace_events").toString()));
      }
      if ((jsonObj.get("persistence") != null && !jsonObj.get("persistence").isJsonNull()) && !jsonObj.get("persistence").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `persistence` to be a primitive type in the JSON string but got `%s`", jsonObj.get("persistence").toString()));
      }
      // validate the optional field `persistence`
      if (jsonObj.get("persistence") != null && !jsonObj.get("persistence").isJsonNull()) {
        PersistenceEnum.validateJsonElement(jsonObj.get("persistence"));
      }
      if ((jsonObj.get("acl_channels_default") != null && !jsonObj.get("acl_channels_default").isJsonNull()) && !jsonObj.get("acl_channels_default").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `acl_channels_default` to be a primitive type in the JSON string but got `%s`", jsonObj.get("acl_channels_default").toString()));
      }
      // validate the optional field `acl_channels_default`
      if (jsonObj.get("acl_channels_default") != null && !jsonObj.get("acl_channels_default").isJsonNull()) {
        AclChannelsDefaultEnum.validateJsonElement(jsonObj.get("acl_channels_default"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!JsonSchemaRedis.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'JsonSchemaRedis' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<JsonSchemaRedis> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(JsonSchemaRedis.class));

       return (TypeAdapter<T>) new TypeAdapter<JsonSchemaRedis>() {
           @Override
           public void write(JsonWriter out, JsonSchemaRedis value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public JsonSchemaRedis read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of JsonSchemaRedis given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of JsonSchemaRedis
  * @throws IOException if the JSON string is invalid with respect to JsonSchemaRedis
  */
  public static JsonSchemaRedis fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, JsonSchemaRedis.class);
  }

 /**
  * Convert an instance of JsonSchemaRedis to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

