/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.exoscale.api.models.components;

import com.exoscale.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;


public class IPAddressRateLimitingSettings {

    /**
     * The type of rate limiting
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("type")
    private Optional<? extends IpRateLimitingType> type;

    /**
     * The number of login attempts allowed before login is blocked
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("allowed_tries")
    private Optional<? extends Long> allowedTries;

    /**
     * The window of time in which the value for `allowed_tries` is enforced
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("time_window_seconds")
    private Optional<? extends Long> timeWindowSeconds;

    /**
     * The duration of time that login remains blocked after a failed login
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("block_expiry_seconds")
    private Optional<? extends Long> blockExpirySeconds;

    /**
     * The maximum number of blocked IP addresses
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max_blocked_clients")
    private Optional<? extends Long> maxBlockedClients;

    /**
     * The maximum number of tracked IP addresses that have failed login
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max_tracked_clients")
    private Optional<? extends Long> maxTrackedClients;

    public IPAddressRateLimitingSettings(
            @JsonProperty("type") Optional<? extends IpRateLimitingType> type,
            @JsonProperty("allowed_tries") Optional<? extends Long> allowedTries,
            @JsonProperty("time_window_seconds") Optional<? extends Long> timeWindowSeconds,
            @JsonProperty("block_expiry_seconds") Optional<? extends Long> blockExpirySeconds,
            @JsonProperty("max_blocked_clients") Optional<? extends Long> maxBlockedClients,
            @JsonProperty("max_tracked_clients") Optional<? extends Long> maxTrackedClients) {
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(allowedTries, "allowedTries");
        Utils.checkNotNull(timeWindowSeconds, "timeWindowSeconds");
        Utils.checkNotNull(blockExpirySeconds, "blockExpirySeconds");
        Utils.checkNotNull(maxBlockedClients, "maxBlockedClients");
        Utils.checkNotNull(maxTrackedClients, "maxTrackedClients");
        this.type = type;
        this.allowedTries = allowedTries;
        this.timeWindowSeconds = timeWindowSeconds;
        this.blockExpirySeconds = blockExpirySeconds;
        this.maxBlockedClients = maxBlockedClients;
        this.maxTrackedClients = maxTrackedClients;
    }

    /**
     * The type of rate limiting
     */
    public Optional<? extends IpRateLimitingType> type() {
        return type;
    }

    /**
     * The number of login attempts allowed before login is blocked
     */
    public Optional<? extends Long> allowedTries() {
        return allowedTries;
    }

    /**
     * The window of time in which the value for `allowed_tries` is enforced
     */
    public Optional<? extends Long> timeWindowSeconds() {
        return timeWindowSeconds;
    }

    /**
     * The duration of time that login remains blocked after a failed login
     */
    public Optional<? extends Long> blockExpirySeconds() {
        return blockExpirySeconds;
    }

    /**
     * The maximum number of blocked IP addresses
     */
    public Optional<? extends Long> maxBlockedClients() {
        return maxBlockedClients;
    }

    /**
     * The maximum number of tracked IP addresses that have failed login
     */
    public Optional<? extends Long> maxTrackedClients() {
        return maxTrackedClients;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The type of rate limiting
     */
    public IPAddressRateLimitingSettings withType(IpRateLimitingType type) {
        Utils.checkNotNull(type, "type");
        this.type = Optional.ofNullable(type);
        return this;
    }

    /**
     * The type of rate limiting
     */
    public IPAddressRateLimitingSettings withType(Optional<? extends IpRateLimitingType> type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    /**
     * The number of login attempts allowed before login is blocked
     */
    public IPAddressRateLimitingSettings withAllowedTries(long allowedTries) {
        Utils.checkNotNull(allowedTries, "allowedTries");
        this.allowedTries = Optional.ofNullable(allowedTries);
        return this;
    }

    /**
     * The number of login attempts allowed before login is blocked
     */
    public IPAddressRateLimitingSettings withAllowedTries(Optional<? extends Long> allowedTries) {
        Utils.checkNotNull(allowedTries, "allowedTries");
        this.allowedTries = allowedTries;
        return this;
    }

    /**
     * The window of time in which the value for `allowed_tries` is enforced
     */
    public IPAddressRateLimitingSettings withTimeWindowSeconds(long timeWindowSeconds) {
        Utils.checkNotNull(timeWindowSeconds, "timeWindowSeconds");
        this.timeWindowSeconds = Optional.ofNullable(timeWindowSeconds);
        return this;
    }

    /**
     * The window of time in which the value for `allowed_tries` is enforced
     */
    public IPAddressRateLimitingSettings withTimeWindowSeconds(Optional<? extends Long> timeWindowSeconds) {
        Utils.checkNotNull(timeWindowSeconds, "timeWindowSeconds");
        this.timeWindowSeconds = timeWindowSeconds;
        return this;
    }

    /**
     * The duration of time that login remains blocked after a failed login
     */
    public IPAddressRateLimitingSettings withBlockExpirySeconds(long blockExpirySeconds) {
        Utils.checkNotNull(blockExpirySeconds, "blockExpirySeconds");
        this.blockExpirySeconds = Optional.ofNullable(blockExpirySeconds);
        return this;
    }

    /**
     * The duration of time that login remains blocked after a failed login
     */
    public IPAddressRateLimitingSettings withBlockExpirySeconds(Optional<? extends Long> blockExpirySeconds) {
        Utils.checkNotNull(blockExpirySeconds, "blockExpirySeconds");
        this.blockExpirySeconds = blockExpirySeconds;
        return this;
    }

    /**
     * The maximum number of blocked IP addresses
     */
    public IPAddressRateLimitingSettings withMaxBlockedClients(long maxBlockedClients) {
        Utils.checkNotNull(maxBlockedClients, "maxBlockedClients");
        this.maxBlockedClients = Optional.ofNullable(maxBlockedClients);
        return this;
    }

    /**
     * The maximum number of blocked IP addresses
     */
    public IPAddressRateLimitingSettings withMaxBlockedClients(Optional<? extends Long> maxBlockedClients) {
        Utils.checkNotNull(maxBlockedClients, "maxBlockedClients");
        this.maxBlockedClients = maxBlockedClients;
        return this;
    }

    /**
     * The maximum number of tracked IP addresses that have failed login
     */
    public IPAddressRateLimitingSettings withMaxTrackedClients(long maxTrackedClients) {
        Utils.checkNotNull(maxTrackedClients, "maxTrackedClients");
        this.maxTrackedClients = Optional.ofNullable(maxTrackedClients);
        return this;
    }

    /**
     * The maximum number of tracked IP addresses that have failed login
     */
    public IPAddressRateLimitingSettings withMaxTrackedClients(Optional<? extends Long> maxTrackedClients) {
        Utils.checkNotNull(maxTrackedClients, "maxTrackedClients");
        this.maxTrackedClients = maxTrackedClients;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        IPAddressRateLimitingSettings other = (IPAddressRateLimitingSettings) o;
        return 
            java.util.Objects.deepEquals(this.type, other.type) &&
            java.util.Objects.deepEquals(this.allowedTries, other.allowedTries) &&
            java.util.Objects.deepEquals(this.timeWindowSeconds, other.timeWindowSeconds) &&
            java.util.Objects.deepEquals(this.blockExpirySeconds, other.blockExpirySeconds) &&
            java.util.Objects.deepEquals(this.maxBlockedClients, other.maxBlockedClients) &&
            java.util.Objects.deepEquals(this.maxTrackedClients, other.maxTrackedClients);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            type,
            allowedTries,
            timeWindowSeconds,
            blockExpirySeconds,
            maxBlockedClients,
            maxTrackedClients);
    }
    
    @Override
    public String toString() {
        return Utils.toString(IPAddressRateLimitingSettings.class,
                "type", type,
                "allowedTries", allowedTries,
                "timeWindowSeconds", timeWindowSeconds,
                "blockExpirySeconds", blockExpirySeconds,
                "maxBlockedClients", maxBlockedClients,
                "maxTrackedClients", maxTrackedClients);
    }
    
    public final static class Builder {
 
        private Optional<? extends IpRateLimitingType> type = Optional.empty();
 
        private Optional<? extends Long> allowedTries = Optional.empty();
 
        private Optional<? extends Long> timeWindowSeconds = Optional.empty();
 
        private Optional<? extends Long> blockExpirySeconds = Optional.empty();
 
        private Optional<? extends Long> maxBlockedClients = Optional.empty();
 
        private Optional<? extends Long> maxTrackedClients = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The type of rate limiting
         */
        public Builder type(IpRateLimitingType type) {
            Utils.checkNotNull(type, "type");
            this.type = Optional.ofNullable(type);
            return this;
        }

        /**
         * The type of rate limiting
         */
        public Builder type(Optional<? extends IpRateLimitingType> type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }

        /**
         * The number of login attempts allowed before login is blocked
         */
        public Builder allowedTries(long allowedTries) {
            Utils.checkNotNull(allowedTries, "allowedTries");
            this.allowedTries = Optional.ofNullable(allowedTries);
            return this;
        }

        /**
         * The number of login attempts allowed before login is blocked
         */
        public Builder allowedTries(Optional<? extends Long> allowedTries) {
            Utils.checkNotNull(allowedTries, "allowedTries");
            this.allowedTries = allowedTries;
            return this;
        }

        /**
         * The window of time in which the value for `allowed_tries` is enforced
         */
        public Builder timeWindowSeconds(long timeWindowSeconds) {
            Utils.checkNotNull(timeWindowSeconds, "timeWindowSeconds");
            this.timeWindowSeconds = Optional.ofNullable(timeWindowSeconds);
            return this;
        }

        /**
         * The window of time in which the value for `allowed_tries` is enforced
         */
        public Builder timeWindowSeconds(Optional<? extends Long> timeWindowSeconds) {
            Utils.checkNotNull(timeWindowSeconds, "timeWindowSeconds");
            this.timeWindowSeconds = timeWindowSeconds;
            return this;
        }

        /**
         * The duration of time that login remains blocked after a failed login
         */
        public Builder blockExpirySeconds(long blockExpirySeconds) {
            Utils.checkNotNull(blockExpirySeconds, "blockExpirySeconds");
            this.blockExpirySeconds = Optional.ofNullable(blockExpirySeconds);
            return this;
        }

        /**
         * The duration of time that login remains blocked after a failed login
         */
        public Builder blockExpirySeconds(Optional<? extends Long> blockExpirySeconds) {
            Utils.checkNotNull(blockExpirySeconds, "blockExpirySeconds");
            this.blockExpirySeconds = blockExpirySeconds;
            return this;
        }

        /**
         * The maximum number of blocked IP addresses
         */
        public Builder maxBlockedClients(long maxBlockedClients) {
            Utils.checkNotNull(maxBlockedClients, "maxBlockedClients");
            this.maxBlockedClients = Optional.ofNullable(maxBlockedClients);
            return this;
        }

        /**
         * The maximum number of blocked IP addresses
         */
        public Builder maxBlockedClients(Optional<? extends Long> maxBlockedClients) {
            Utils.checkNotNull(maxBlockedClients, "maxBlockedClients");
            this.maxBlockedClients = maxBlockedClients;
            return this;
        }

        /**
         * The maximum number of tracked IP addresses that have failed login
         */
        public Builder maxTrackedClients(long maxTrackedClients) {
            Utils.checkNotNull(maxTrackedClients, "maxTrackedClients");
            this.maxTrackedClients = Optional.ofNullable(maxTrackedClients);
            return this;
        }

        /**
         * The maximum number of tracked IP addresses that have failed login
         */
        public Builder maxTrackedClients(Optional<? extends Long> maxTrackedClients) {
            Utils.checkNotNull(maxTrackedClients, "maxTrackedClients");
            this.maxTrackedClients = maxTrackedClients;
            return this;
        }
        
        public IPAddressRateLimitingSettings build() {
            return new IPAddressRateLimitingSettings(
                type,
                allowedTries,
                timeWindowSeconds,
                blockExpirySeconds,
                maxBlockedClients,
                maxTrackedClients);
        }
    }
}

