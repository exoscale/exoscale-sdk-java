/*
 * Exoscale Public API
 *  Infrastructure automation API, allowing programmatic access to all Exoscale products and services.  The [OpenAPI Specification](http://spec.openapis.org/oas/v3.0.3.html) source of this documentation can be obtained here:  * [JSON format](https://openapi-v2.exoscale.com/source.json) * [YAML format](https://openapi-v2.exoscale.com/source.yaml)
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: api@exoscale.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * BackgroundBGWriterSettings
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-03-27T17:14:44.205710495Z[Etc/UTC]", comments = "Generator version: 7.5.0-SNAPSHOT")
public class BackgroundBGWriterSettings {
  public static final String SERIALIZED_NAME_BGWRITER_DELAY = "bgwriter_delay";
  @SerializedName(SERIALIZED_NAME_BGWRITER_DELAY)
  private Integer bgwriterDelay;

  public static final String SERIALIZED_NAME_BGWRITER_FLUSH_AFTER = "bgwriter_flush_after";
  @SerializedName(SERIALIZED_NAME_BGWRITER_FLUSH_AFTER)
  private Integer bgwriterFlushAfter;

  public static final String SERIALIZED_NAME_BGWRITER_LRU_MULTIPLIER = "bgwriter_lru_multiplier";
  @SerializedName(SERIALIZED_NAME_BGWRITER_LRU_MULTIPLIER)
  private BigDecimal bgwriterLruMultiplier;

  public static final String SERIALIZED_NAME_BGWRITER_LRU_MAXPAGES = "bgwriter_lru_maxpages";
  @SerializedName(SERIALIZED_NAME_BGWRITER_LRU_MAXPAGES)
  private Integer bgwriterLruMaxpages;

  public BackgroundBGWriterSettings() {
  }

  public BackgroundBGWriterSettings bgwriterDelay(Integer bgwriterDelay) {
    this.bgwriterDelay = bgwriterDelay;
    return this;
  }

   /**
   * Specifies the delay between activity rounds for the background writer in milliseconds. Default is 200.
   * minimum: 10
   * maximum: 10000
   * @return bgwriterDelay
  **/
  @javax.annotation.Nullable
  public Integer getBgwriterDelay() {
    return bgwriterDelay;
  }

  public void setBgwriterDelay(Integer bgwriterDelay) {
    this.bgwriterDelay = bgwriterDelay;
  }


  public BackgroundBGWriterSettings bgwriterFlushAfter(Integer bgwriterFlushAfter) {
    this.bgwriterFlushAfter = bgwriterFlushAfter;
    return this;
  }

   /**
   * Whenever more than bgwriter_flush_after bytes have been written by the background writer, attempt to force the OS to issue these writes to the underlying storage. Specified in kilobytes, default is 512. Setting of 0 disables forced writeback.
   * minimum: 0
   * maximum: 2048
   * @return bgwriterFlushAfter
  **/
  @javax.annotation.Nullable
  public Integer getBgwriterFlushAfter() {
    return bgwriterFlushAfter;
  }

  public void setBgwriterFlushAfter(Integer bgwriterFlushAfter) {
    this.bgwriterFlushAfter = bgwriterFlushAfter;
  }


  public BackgroundBGWriterSettings bgwriterLruMultiplier(BigDecimal bgwriterLruMultiplier) {
    this.bgwriterLruMultiplier = bgwriterLruMultiplier;
    return this;
  }

   /**
   * The average recent need for new buffers is multiplied by bgwriter_lru_multiplier to arrive at an estimate of the number that will be needed during the next round, (up to bgwriter_lru_maxpages). 1.0 represents a “just in time” policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0.
   * minimum: 0
   * maximum: 10
   * @return bgwriterLruMultiplier
  **/
  @javax.annotation.Nullable
  public BigDecimal getBgwriterLruMultiplier() {
    return bgwriterLruMultiplier;
  }

  public void setBgwriterLruMultiplier(BigDecimal bgwriterLruMultiplier) {
    this.bgwriterLruMultiplier = bgwriterLruMultiplier;
  }


  public BackgroundBGWriterSettings bgwriterLruMaxpages(Integer bgwriterLruMaxpages) {
    this.bgwriterLruMaxpages = bgwriterLruMaxpages;
    return this;
  }

   /**
   * In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. Default is 100.
   * minimum: 0
   * maximum: 1073741823
   * @return bgwriterLruMaxpages
  **/
  @javax.annotation.Nullable
  public Integer getBgwriterLruMaxpages() {
    return bgwriterLruMaxpages;
  }

  public void setBgwriterLruMaxpages(Integer bgwriterLruMaxpages) {
    this.bgwriterLruMaxpages = bgwriterLruMaxpages;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BackgroundBGWriterSettings backgroundBGWriterSettings = (BackgroundBGWriterSettings) o;
    return Objects.equals(this.bgwriterDelay, backgroundBGWriterSettings.bgwriterDelay) &&
        Objects.equals(this.bgwriterFlushAfter, backgroundBGWriterSettings.bgwriterFlushAfter) &&
        Objects.equals(this.bgwriterLruMultiplier, backgroundBGWriterSettings.bgwriterLruMultiplier) &&
        Objects.equals(this.bgwriterLruMaxpages, backgroundBGWriterSettings.bgwriterLruMaxpages);
  }

  @Override
  public int hashCode() {
    return Objects.hash(bgwriterDelay, bgwriterFlushAfter, bgwriterLruMultiplier, bgwriterLruMaxpages);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BackgroundBGWriterSettings {\n");
    sb.append("    bgwriterDelay: ").append(toIndentedString(bgwriterDelay)).append("\n");
    sb.append("    bgwriterFlushAfter: ").append(toIndentedString(bgwriterFlushAfter)).append("\n");
    sb.append("    bgwriterLruMultiplier: ").append(toIndentedString(bgwriterLruMultiplier)).append("\n");
    sb.append("    bgwriterLruMaxpages: ").append(toIndentedString(bgwriterLruMaxpages)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("bgwriter_delay");
    openapiFields.add("bgwriter_flush_after");
    openapiFields.add("bgwriter_lru_multiplier");
    openapiFields.add("bgwriter_lru_maxpages");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to BackgroundBGWriterSettings
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BackgroundBGWriterSettings.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BackgroundBGWriterSettings is not found in the empty JSON string", BackgroundBGWriterSettings.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BackgroundBGWriterSettings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BackgroundBGWriterSettings` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BackgroundBGWriterSettings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BackgroundBGWriterSettings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BackgroundBGWriterSettings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BackgroundBGWriterSettings.class));

       return (TypeAdapter<T>) new TypeAdapter<BackgroundBGWriterSettings>() {
           @Override
           public void write(JsonWriter out, BackgroundBGWriterSettings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BackgroundBGWriterSettings read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of BackgroundBGWriterSettings given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of BackgroundBGWriterSettings
  * @throws IOException if the JSON string is invalid with respect to BackgroundBGWriterSettings
  */
  public static BackgroundBGWriterSettings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BackgroundBGWriterSettings.class);
  }

 /**
  * Convert an instance of BackgroundBGWriterSettings to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

