/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.exoscale.api.models.components;

import com.exoscale.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;


public class AutovacuumSettings {

    /**
     * Causes each action executed by autovacuum to be logged if it ran for at least the specified number of milliseconds. Setting this to zero logs all autovacuum actions. Minus-one (the default) disables logging autovacuum actions.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("log_autovacuum_min_duration")
    private Optional<? extends Long> logAutovacuumMinDuration;

    /**
     * Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("autovacuum_vacuum_cost_limit")
    private Optional<? extends Long> autovacuumVacuumCostLimit;

    /**
     * Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("autovacuum_max_workers")
    private Optional<? extends Long> autovacuumMaxWorkers;

    /**
     * Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("autovacuum_vacuum_threshold")
    private Optional<? extends Long> autovacuumVacuumThreshold;

    /**
     * Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("autovacuum_naptime")
    private Optional<? extends Long> autovacuumNaptime;

    /**
     * Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("autovacuum_vacuum_scale_factor")
    private Optional<? extends Double> autovacuumVacuumScaleFactor;

    /**
     * Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("autovacuum_vacuum_cost_delay")
    private Optional<? extends Long> autovacuumVacuumCostDelay;

    /**
     * Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("autovacuum_analyze_scale_factor")
    private Optional<? extends Double> autovacuumAnalyzeScaleFactor;

    /**
     * Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an  ANALYZE in any one table. The default is 50 tuples.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("autovacuum_analyze_threshold")
    private Optional<? extends Long> autovacuumAnalyzeThreshold;

    /**
     * Specifies the maximum age (in transactions) that a table's pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent transaction ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will cause the server to be restarted.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("autovacuum_freeze_max_age")
    private Optional<? extends Long> autovacuumFreezeMaxAge;

    public AutovacuumSettings(
            @JsonProperty("log_autovacuum_min_duration") Optional<? extends Long> logAutovacuumMinDuration,
            @JsonProperty("autovacuum_vacuum_cost_limit") Optional<? extends Long> autovacuumVacuumCostLimit,
            @JsonProperty("autovacuum_max_workers") Optional<? extends Long> autovacuumMaxWorkers,
            @JsonProperty("autovacuum_vacuum_threshold") Optional<? extends Long> autovacuumVacuumThreshold,
            @JsonProperty("autovacuum_naptime") Optional<? extends Long> autovacuumNaptime,
            @JsonProperty("autovacuum_vacuum_scale_factor") Optional<? extends Double> autovacuumVacuumScaleFactor,
            @JsonProperty("autovacuum_vacuum_cost_delay") Optional<? extends Long> autovacuumVacuumCostDelay,
            @JsonProperty("autovacuum_analyze_scale_factor") Optional<? extends Double> autovacuumAnalyzeScaleFactor,
            @JsonProperty("autovacuum_analyze_threshold") Optional<? extends Long> autovacuumAnalyzeThreshold,
            @JsonProperty("autovacuum_freeze_max_age") Optional<? extends Long> autovacuumFreezeMaxAge) {
        Utils.checkNotNull(logAutovacuumMinDuration, "logAutovacuumMinDuration");
        Utils.checkNotNull(autovacuumVacuumCostLimit, "autovacuumVacuumCostLimit");
        Utils.checkNotNull(autovacuumMaxWorkers, "autovacuumMaxWorkers");
        Utils.checkNotNull(autovacuumVacuumThreshold, "autovacuumVacuumThreshold");
        Utils.checkNotNull(autovacuumNaptime, "autovacuumNaptime");
        Utils.checkNotNull(autovacuumVacuumScaleFactor, "autovacuumVacuumScaleFactor");
        Utils.checkNotNull(autovacuumVacuumCostDelay, "autovacuumVacuumCostDelay");
        Utils.checkNotNull(autovacuumAnalyzeScaleFactor, "autovacuumAnalyzeScaleFactor");
        Utils.checkNotNull(autovacuumAnalyzeThreshold, "autovacuumAnalyzeThreshold");
        Utils.checkNotNull(autovacuumFreezeMaxAge, "autovacuumFreezeMaxAge");
        this.logAutovacuumMinDuration = logAutovacuumMinDuration;
        this.autovacuumVacuumCostLimit = autovacuumVacuumCostLimit;
        this.autovacuumMaxWorkers = autovacuumMaxWorkers;
        this.autovacuumVacuumThreshold = autovacuumVacuumThreshold;
        this.autovacuumNaptime = autovacuumNaptime;
        this.autovacuumVacuumScaleFactor = autovacuumVacuumScaleFactor;
        this.autovacuumVacuumCostDelay = autovacuumVacuumCostDelay;
        this.autovacuumAnalyzeScaleFactor = autovacuumAnalyzeScaleFactor;
        this.autovacuumAnalyzeThreshold = autovacuumAnalyzeThreshold;
        this.autovacuumFreezeMaxAge = autovacuumFreezeMaxAge;
    }

    /**
     * Causes each action executed by autovacuum to be logged if it ran for at least the specified number of milliseconds. Setting this to zero logs all autovacuum actions. Minus-one (the default) disables logging autovacuum actions.
     */
    public Optional<? extends Long> logAutovacuumMinDuration() {
        return logAutovacuumMinDuration;
    }

    /**
     * Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
     */
    public Optional<? extends Long> autovacuumVacuumCostLimit() {
        return autovacuumVacuumCostLimit;
    }

    /**
     * Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
     */
    public Optional<? extends Long> autovacuumMaxWorkers() {
        return autovacuumMaxWorkers;
    }

    /**
     * Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples
     */
    public Optional<? extends Long> autovacuumVacuumThreshold() {
        return autovacuumVacuumThreshold;
    }

    /**
     * Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute
     */
    public Optional<? extends Long> autovacuumNaptime() {
        return autovacuumNaptime;
    }

    /**
     * Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size)
     */
    public Optional<? extends Double> autovacuumVacuumScaleFactor() {
        return autovacuumVacuumScaleFactor;
    }

    /**
     * Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds
     */
    public Optional<? extends Long> autovacuumVacuumCostDelay() {
        return autovacuumVacuumCostDelay;
    }

    /**
     * Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size)
     */
    public Optional<? extends Double> autovacuumAnalyzeScaleFactor() {
        return autovacuumAnalyzeScaleFactor;
    }

    /**
     * Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an  ANALYZE in any one table. The default is 50 tuples.
     */
    public Optional<? extends Long> autovacuumAnalyzeThreshold() {
        return autovacuumAnalyzeThreshold;
    }

    /**
     * Specifies the maximum age (in transactions) that a table's pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent transaction ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will cause the server to be restarted.
     */
    public Optional<? extends Long> autovacuumFreezeMaxAge() {
        return autovacuumFreezeMaxAge;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Causes each action executed by autovacuum to be logged if it ran for at least the specified number of milliseconds. Setting this to zero logs all autovacuum actions. Minus-one (the default) disables logging autovacuum actions.
     */
    public AutovacuumSettings withLogAutovacuumMinDuration(long logAutovacuumMinDuration) {
        Utils.checkNotNull(logAutovacuumMinDuration, "logAutovacuumMinDuration");
        this.logAutovacuumMinDuration = Optional.ofNullable(logAutovacuumMinDuration);
        return this;
    }

    /**
     * Causes each action executed by autovacuum to be logged if it ran for at least the specified number of milliseconds. Setting this to zero logs all autovacuum actions. Minus-one (the default) disables logging autovacuum actions.
     */
    public AutovacuumSettings withLogAutovacuumMinDuration(Optional<? extends Long> logAutovacuumMinDuration) {
        Utils.checkNotNull(logAutovacuumMinDuration, "logAutovacuumMinDuration");
        this.logAutovacuumMinDuration = logAutovacuumMinDuration;
        return this;
    }

    /**
     * Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
     */
    public AutovacuumSettings withAutovacuumVacuumCostLimit(long autovacuumVacuumCostLimit) {
        Utils.checkNotNull(autovacuumVacuumCostLimit, "autovacuumVacuumCostLimit");
        this.autovacuumVacuumCostLimit = Optional.ofNullable(autovacuumVacuumCostLimit);
        return this;
    }

    /**
     * Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
     */
    public AutovacuumSettings withAutovacuumVacuumCostLimit(Optional<? extends Long> autovacuumVacuumCostLimit) {
        Utils.checkNotNull(autovacuumVacuumCostLimit, "autovacuumVacuumCostLimit");
        this.autovacuumVacuumCostLimit = autovacuumVacuumCostLimit;
        return this;
    }

    /**
     * Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
     */
    public AutovacuumSettings withAutovacuumMaxWorkers(long autovacuumMaxWorkers) {
        Utils.checkNotNull(autovacuumMaxWorkers, "autovacuumMaxWorkers");
        this.autovacuumMaxWorkers = Optional.ofNullable(autovacuumMaxWorkers);
        return this;
    }

    /**
     * Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
     */
    public AutovacuumSettings withAutovacuumMaxWorkers(Optional<? extends Long> autovacuumMaxWorkers) {
        Utils.checkNotNull(autovacuumMaxWorkers, "autovacuumMaxWorkers");
        this.autovacuumMaxWorkers = autovacuumMaxWorkers;
        return this;
    }

    /**
     * Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples
     */
    public AutovacuumSettings withAutovacuumVacuumThreshold(long autovacuumVacuumThreshold) {
        Utils.checkNotNull(autovacuumVacuumThreshold, "autovacuumVacuumThreshold");
        this.autovacuumVacuumThreshold = Optional.ofNullable(autovacuumVacuumThreshold);
        return this;
    }

    /**
     * Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples
     */
    public AutovacuumSettings withAutovacuumVacuumThreshold(Optional<? extends Long> autovacuumVacuumThreshold) {
        Utils.checkNotNull(autovacuumVacuumThreshold, "autovacuumVacuumThreshold");
        this.autovacuumVacuumThreshold = autovacuumVacuumThreshold;
        return this;
    }

    /**
     * Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute
     */
    public AutovacuumSettings withAutovacuumNaptime(long autovacuumNaptime) {
        Utils.checkNotNull(autovacuumNaptime, "autovacuumNaptime");
        this.autovacuumNaptime = Optional.ofNullable(autovacuumNaptime);
        return this;
    }

    /**
     * Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute
     */
    public AutovacuumSettings withAutovacuumNaptime(Optional<? extends Long> autovacuumNaptime) {
        Utils.checkNotNull(autovacuumNaptime, "autovacuumNaptime");
        this.autovacuumNaptime = autovacuumNaptime;
        return this;
    }

    /**
     * Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size)
     */
    public AutovacuumSettings withAutovacuumVacuumScaleFactor(double autovacuumVacuumScaleFactor) {
        Utils.checkNotNull(autovacuumVacuumScaleFactor, "autovacuumVacuumScaleFactor");
        this.autovacuumVacuumScaleFactor = Optional.ofNullable(autovacuumVacuumScaleFactor);
        return this;
    }

    /**
     * Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size)
     */
    public AutovacuumSettings withAutovacuumVacuumScaleFactor(Optional<? extends Double> autovacuumVacuumScaleFactor) {
        Utils.checkNotNull(autovacuumVacuumScaleFactor, "autovacuumVacuumScaleFactor");
        this.autovacuumVacuumScaleFactor = autovacuumVacuumScaleFactor;
        return this;
    }

    /**
     * Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds
     */
    public AutovacuumSettings withAutovacuumVacuumCostDelay(long autovacuumVacuumCostDelay) {
        Utils.checkNotNull(autovacuumVacuumCostDelay, "autovacuumVacuumCostDelay");
        this.autovacuumVacuumCostDelay = Optional.ofNullable(autovacuumVacuumCostDelay);
        return this;
    }

    /**
     * Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds
     */
    public AutovacuumSettings withAutovacuumVacuumCostDelay(Optional<? extends Long> autovacuumVacuumCostDelay) {
        Utils.checkNotNull(autovacuumVacuumCostDelay, "autovacuumVacuumCostDelay");
        this.autovacuumVacuumCostDelay = autovacuumVacuumCostDelay;
        return this;
    }

    /**
     * Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size)
     */
    public AutovacuumSettings withAutovacuumAnalyzeScaleFactor(double autovacuumAnalyzeScaleFactor) {
        Utils.checkNotNull(autovacuumAnalyzeScaleFactor, "autovacuumAnalyzeScaleFactor");
        this.autovacuumAnalyzeScaleFactor = Optional.ofNullable(autovacuumAnalyzeScaleFactor);
        return this;
    }

    /**
     * Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size)
     */
    public AutovacuumSettings withAutovacuumAnalyzeScaleFactor(Optional<? extends Double> autovacuumAnalyzeScaleFactor) {
        Utils.checkNotNull(autovacuumAnalyzeScaleFactor, "autovacuumAnalyzeScaleFactor");
        this.autovacuumAnalyzeScaleFactor = autovacuumAnalyzeScaleFactor;
        return this;
    }

    /**
     * Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an  ANALYZE in any one table. The default is 50 tuples.
     */
    public AutovacuumSettings withAutovacuumAnalyzeThreshold(long autovacuumAnalyzeThreshold) {
        Utils.checkNotNull(autovacuumAnalyzeThreshold, "autovacuumAnalyzeThreshold");
        this.autovacuumAnalyzeThreshold = Optional.ofNullable(autovacuumAnalyzeThreshold);
        return this;
    }

    /**
     * Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an  ANALYZE in any one table. The default is 50 tuples.
     */
    public AutovacuumSettings withAutovacuumAnalyzeThreshold(Optional<? extends Long> autovacuumAnalyzeThreshold) {
        Utils.checkNotNull(autovacuumAnalyzeThreshold, "autovacuumAnalyzeThreshold");
        this.autovacuumAnalyzeThreshold = autovacuumAnalyzeThreshold;
        return this;
    }

    /**
     * Specifies the maximum age (in transactions) that a table's pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent transaction ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will cause the server to be restarted.
     */
    public AutovacuumSettings withAutovacuumFreezeMaxAge(long autovacuumFreezeMaxAge) {
        Utils.checkNotNull(autovacuumFreezeMaxAge, "autovacuumFreezeMaxAge");
        this.autovacuumFreezeMaxAge = Optional.ofNullable(autovacuumFreezeMaxAge);
        return this;
    }

    /**
     * Specifies the maximum age (in transactions) that a table's pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent transaction ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will cause the server to be restarted.
     */
    public AutovacuumSettings withAutovacuumFreezeMaxAge(Optional<? extends Long> autovacuumFreezeMaxAge) {
        Utils.checkNotNull(autovacuumFreezeMaxAge, "autovacuumFreezeMaxAge");
        this.autovacuumFreezeMaxAge = autovacuumFreezeMaxAge;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        AutovacuumSettings other = (AutovacuumSettings) o;
        return 
            java.util.Objects.deepEquals(this.logAutovacuumMinDuration, other.logAutovacuumMinDuration) &&
            java.util.Objects.deepEquals(this.autovacuumVacuumCostLimit, other.autovacuumVacuumCostLimit) &&
            java.util.Objects.deepEquals(this.autovacuumMaxWorkers, other.autovacuumMaxWorkers) &&
            java.util.Objects.deepEquals(this.autovacuumVacuumThreshold, other.autovacuumVacuumThreshold) &&
            java.util.Objects.deepEquals(this.autovacuumNaptime, other.autovacuumNaptime) &&
            java.util.Objects.deepEquals(this.autovacuumVacuumScaleFactor, other.autovacuumVacuumScaleFactor) &&
            java.util.Objects.deepEquals(this.autovacuumVacuumCostDelay, other.autovacuumVacuumCostDelay) &&
            java.util.Objects.deepEquals(this.autovacuumAnalyzeScaleFactor, other.autovacuumAnalyzeScaleFactor) &&
            java.util.Objects.deepEquals(this.autovacuumAnalyzeThreshold, other.autovacuumAnalyzeThreshold) &&
            java.util.Objects.deepEquals(this.autovacuumFreezeMaxAge, other.autovacuumFreezeMaxAge);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            logAutovacuumMinDuration,
            autovacuumVacuumCostLimit,
            autovacuumMaxWorkers,
            autovacuumVacuumThreshold,
            autovacuumNaptime,
            autovacuumVacuumScaleFactor,
            autovacuumVacuumCostDelay,
            autovacuumAnalyzeScaleFactor,
            autovacuumAnalyzeThreshold,
            autovacuumFreezeMaxAge);
    }
    
    @Override
    public String toString() {
        return Utils.toString(AutovacuumSettings.class,
                "logAutovacuumMinDuration", logAutovacuumMinDuration,
                "autovacuumVacuumCostLimit", autovacuumVacuumCostLimit,
                "autovacuumMaxWorkers", autovacuumMaxWorkers,
                "autovacuumVacuumThreshold", autovacuumVacuumThreshold,
                "autovacuumNaptime", autovacuumNaptime,
                "autovacuumVacuumScaleFactor", autovacuumVacuumScaleFactor,
                "autovacuumVacuumCostDelay", autovacuumVacuumCostDelay,
                "autovacuumAnalyzeScaleFactor", autovacuumAnalyzeScaleFactor,
                "autovacuumAnalyzeThreshold", autovacuumAnalyzeThreshold,
                "autovacuumFreezeMaxAge", autovacuumFreezeMaxAge);
    }
    
    public final static class Builder {
 
        private Optional<? extends Long> logAutovacuumMinDuration = Optional.empty();
 
        private Optional<? extends Long> autovacuumVacuumCostLimit = Optional.empty();
 
        private Optional<? extends Long> autovacuumMaxWorkers = Optional.empty();
 
        private Optional<? extends Long> autovacuumVacuumThreshold = Optional.empty();
 
        private Optional<? extends Long> autovacuumNaptime = Optional.empty();
 
        private Optional<? extends Double> autovacuumVacuumScaleFactor = Optional.empty();
 
        private Optional<? extends Long> autovacuumVacuumCostDelay = Optional.empty();
 
        private Optional<? extends Double> autovacuumAnalyzeScaleFactor = Optional.empty();
 
        private Optional<? extends Long> autovacuumAnalyzeThreshold = Optional.empty();
 
        private Optional<? extends Long> autovacuumFreezeMaxAge = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Causes each action executed by autovacuum to be logged if it ran for at least the specified number of milliseconds. Setting this to zero logs all autovacuum actions. Minus-one (the default) disables logging autovacuum actions.
         */
        public Builder logAutovacuumMinDuration(long logAutovacuumMinDuration) {
            Utils.checkNotNull(logAutovacuumMinDuration, "logAutovacuumMinDuration");
            this.logAutovacuumMinDuration = Optional.ofNullable(logAutovacuumMinDuration);
            return this;
        }

        /**
         * Causes each action executed by autovacuum to be logged if it ran for at least the specified number of milliseconds. Setting this to zero logs all autovacuum actions. Minus-one (the default) disables logging autovacuum actions.
         */
        public Builder logAutovacuumMinDuration(Optional<? extends Long> logAutovacuumMinDuration) {
            Utils.checkNotNull(logAutovacuumMinDuration, "logAutovacuumMinDuration");
            this.logAutovacuumMinDuration = logAutovacuumMinDuration;
            return this;
        }

        /**
         * Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
         */
        public Builder autovacuumVacuumCostLimit(long autovacuumVacuumCostLimit) {
            Utils.checkNotNull(autovacuumVacuumCostLimit, "autovacuumVacuumCostLimit");
            this.autovacuumVacuumCostLimit = Optional.ofNullable(autovacuumVacuumCostLimit);
            return this;
        }

        /**
         * Specifies the cost limit value that will be used in automatic VACUUM operations. If -1 is specified (which is the default), the regular vacuum_cost_limit value will be used.
         */
        public Builder autovacuumVacuumCostLimit(Optional<? extends Long> autovacuumVacuumCostLimit) {
            Utils.checkNotNull(autovacuumVacuumCostLimit, "autovacuumVacuumCostLimit");
            this.autovacuumVacuumCostLimit = autovacuumVacuumCostLimit;
            return this;
        }

        /**
         * Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
         */
        public Builder autovacuumMaxWorkers(long autovacuumMaxWorkers) {
            Utils.checkNotNull(autovacuumMaxWorkers, "autovacuumMaxWorkers");
            this.autovacuumMaxWorkers = Optional.ofNullable(autovacuumMaxWorkers);
            return this;
        }

        /**
         * Specifies the maximum number of autovacuum processes (other than the autovacuum launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.
         */
        public Builder autovacuumMaxWorkers(Optional<? extends Long> autovacuumMaxWorkers) {
            Utils.checkNotNull(autovacuumMaxWorkers, "autovacuumMaxWorkers");
            this.autovacuumMaxWorkers = autovacuumMaxWorkers;
            return this;
        }

        /**
         * Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples
         */
        public Builder autovacuumVacuumThreshold(long autovacuumVacuumThreshold) {
            Utils.checkNotNull(autovacuumVacuumThreshold, "autovacuumVacuumThreshold");
            this.autovacuumVacuumThreshold = Optional.ofNullable(autovacuumVacuumThreshold);
            return this;
        }

        /**
         * Specifies the minimum number of updated or deleted tuples needed to trigger a VACUUM in any one table. The default is 50 tuples
         */
        public Builder autovacuumVacuumThreshold(Optional<? extends Long> autovacuumVacuumThreshold) {
            Utils.checkNotNull(autovacuumVacuumThreshold, "autovacuumVacuumThreshold");
            this.autovacuumVacuumThreshold = autovacuumVacuumThreshold;
            return this;
        }

        /**
         * Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute
         */
        public Builder autovacuumNaptime(long autovacuumNaptime) {
            Utils.checkNotNull(autovacuumNaptime, "autovacuumNaptime");
            this.autovacuumNaptime = Optional.ofNullable(autovacuumNaptime);
            return this;
        }

        /**
         * Specifies the minimum delay between autovacuum runs on any given database. The delay is measured in seconds, and the default is one minute
         */
        public Builder autovacuumNaptime(Optional<? extends Long> autovacuumNaptime) {
            Utils.checkNotNull(autovacuumNaptime, "autovacuumNaptime");
            this.autovacuumNaptime = autovacuumNaptime;
            return this;
        }

        /**
         * Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size)
         */
        public Builder autovacuumVacuumScaleFactor(double autovacuumVacuumScaleFactor) {
            Utils.checkNotNull(autovacuumVacuumScaleFactor, "autovacuumVacuumScaleFactor");
            this.autovacuumVacuumScaleFactor = Optional.ofNullable(autovacuumVacuumScaleFactor);
            return this;
        }

        /**
         * Specifies a fraction of the table size to add to autovacuum_vacuum_threshold when deciding whether to trigger a VACUUM. The default is 0.2 (20% of table size)
         */
        public Builder autovacuumVacuumScaleFactor(Optional<? extends Double> autovacuumVacuumScaleFactor) {
            Utils.checkNotNull(autovacuumVacuumScaleFactor, "autovacuumVacuumScaleFactor");
            this.autovacuumVacuumScaleFactor = autovacuumVacuumScaleFactor;
            return this;
        }

        /**
         * Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds
         */
        public Builder autovacuumVacuumCostDelay(long autovacuumVacuumCostDelay) {
            Utils.checkNotNull(autovacuumVacuumCostDelay, "autovacuumVacuumCostDelay");
            this.autovacuumVacuumCostDelay = Optional.ofNullable(autovacuumVacuumCostDelay);
            return this;
        }

        /**
         * Specifies the cost delay value that will be used in automatic VACUUM operations. If -1 is specified, the regular vacuum_cost_delay value will be used. The default value is 20 milliseconds
         */
        public Builder autovacuumVacuumCostDelay(Optional<? extends Long> autovacuumVacuumCostDelay) {
            Utils.checkNotNull(autovacuumVacuumCostDelay, "autovacuumVacuumCostDelay");
            this.autovacuumVacuumCostDelay = autovacuumVacuumCostDelay;
            return this;
        }

        /**
         * Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size)
         */
        public Builder autovacuumAnalyzeScaleFactor(double autovacuumAnalyzeScaleFactor) {
            Utils.checkNotNull(autovacuumAnalyzeScaleFactor, "autovacuumAnalyzeScaleFactor");
            this.autovacuumAnalyzeScaleFactor = Optional.ofNullable(autovacuumAnalyzeScaleFactor);
            return this;
        }

        /**
         * Specifies a fraction of the table size to add to autovacuum_analyze_threshold when deciding whether to trigger an ANALYZE. The default is 0.2 (20% of table size)
         */
        public Builder autovacuumAnalyzeScaleFactor(Optional<? extends Double> autovacuumAnalyzeScaleFactor) {
            Utils.checkNotNull(autovacuumAnalyzeScaleFactor, "autovacuumAnalyzeScaleFactor");
            this.autovacuumAnalyzeScaleFactor = autovacuumAnalyzeScaleFactor;
            return this;
        }

        /**
         * Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an  ANALYZE in any one table. The default is 50 tuples.
         */
        public Builder autovacuumAnalyzeThreshold(long autovacuumAnalyzeThreshold) {
            Utils.checkNotNull(autovacuumAnalyzeThreshold, "autovacuumAnalyzeThreshold");
            this.autovacuumAnalyzeThreshold = Optional.ofNullable(autovacuumAnalyzeThreshold);
            return this;
        }

        /**
         * Specifies the minimum number of inserted, updated or deleted tuples needed to trigger an  ANALYZE in any one table. The default is 50 tuples.
         */
        public Builder autovacuumAnalyzeThreshold(Optional<? extends Long> autovacuumAnalyzeThreshold) {
            Utils.checkNotNull(autovacuumAnalyzeThreshold, "autovacuumAnalyzeThreshold");
            this.autovacuumAnalyzeThreshold = autovacuumAnalyzeThreshold;
            return this;
        }

        /**
         * Specifies the maximum age (in transactions) that a table's pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent transaction ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will cause the server to be restarted.
         */
        public Builder autovacuumFreezeMaxAge(long autovacuumFreezeMaxAge) {
            Utils.checkNotNull(autovacuumFreezeMaxAge, "autovacuumFreezeMaxAge");
            this.autovacuumFreezeMaxAge = Optional.ofNullable(autovacuumFreezeMaxAge);
            return this;
        }

        /**
         * Specifies the maximum age (in transactions) that a table's pg_class.relfrozenxid field can attain before a VACUUM operation is forced to prevent transaction ID wraparound within the table. Note that the system will launch autovacuum processes to prevent wraparound even when autovacuum is otherwise disabled. This parameter will cause the server to be restarted.
         */
        public Builder autovacuumFreezeMaxAge(Optional<? extends Long> autovacuumFreezeMaxAge) {
            Utils.checkNotNull(autovacuumFreezeMaxAge, "autovacuumFreezeMaxAge");
            this.autovacuumFreezeMaxAge = autovacuumFreezeMaxAge;
            return this;
        }
        
        public AutovacuumSettings build() {
            return new AutovacuumSettings(
                logAutovacuumMinDuration,
                autovacuumVacuumCostLimit,
                autovacuumMaxWorkers,
                autovacuumVacuumThreshold,
                autovacuumNaptime,
                autovacuumVacuumScaleFactor,
                autovacuumVacuumCostDelay,
                autovacuumAnalyzeScaleFactor,
                autovacuumAnalyzeThreshold,
                autovacuumFreezeMaxAge);
        }
    }
}

