/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.exoscale.api.models.components;

import com.exoscale.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;

/**
 * ElasticIpHealthcheck - Elastic IP address healthcheck
 */

public class ElasticIpHealthcheck {

    /**
     * Number of attempts before considering the target healthy (default: 2)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("strikes-ok")
    private Optional<? extends Long> strikesOk;

    /**
     * Skip TLS verification
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tls-skip-verify")
    private Optional<? extends Boolean> tlsSkipVerify;

    /**
     * An optional domain or subdomain to check TLS against
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tls-sni")
    private Optional<? extends String> tlsSni;

    /**
     * Number of attempts before considering the target unhealthy (default: 3)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("strikes-fail")
    private Optional<? extends Long> strikesFail;

    /**
     * Health check mode
     */
    @JsonProperty("mode")
    private ElasticIpHealthcheckMode mode;

    /**
     * Health check port
     */
    @JsonProperty("port")
    private long port;

    /**
     * An endpoint to use for the health check, for example '/status'
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("uri")
    private Optional<? extends String> uri;

    /**
     * Interval between the checks in seconds (default: 10)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("interval")
    private Optional<? extends Long> interval;

    /**
     * Health check timeout value in seconds (default: 2)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timeout")
    private Optional<? extends Long> timeout;

    public ElasticIpHealthcheck(
            @JsonProperty("strikes-ok") Optional<? extends Long> strikesOk,
            @JsonProperty("tls-skip-verify") Optional<? extends Boolean> tlsSkipVerify,
            @JsonProperty("tls-sni") Optional<? extends String> tlsSni,
            @JsonProperty("strikes-fail") Optional<? extends Long> strikesFail,
            @JsonProperty("mode") ElasticIpHealthcheckMode mode,
            @JsonProperty("port") long port,
            @JsonProperty("uri") Optional<? extends String> uri,
            @JsonProperty("interval") Optional<? extends Long> interval,
            @JsonProperty("timeout") Optional<? extends Long> timeout) {
        Utils.checkNotNull(strikesOk, "strikesOk");
        Utils.checkNotNull(tlsSkipVerify, "tlsSkipVerify");
        Utils.checkNotNull(tlsSni, "tlsSni");
        Utils.checkNotNull(strikesFail, "strikesFail");
        Utils.checkNotNull(mode, "mode");
        Utils.checkNotNull(port, "port");
        Utils.checkNotNull(uri, "uri");
        Utils.checkNotNull(interval, "interval");
        Utils.checkNotNull(timeout, "timeout");
        this.strikesOk = strikesOk;
        this.tlsSkipVerify = tlsSkipVerify;
        this.tlsSni = tlsSni;
        this.strikesFail = strikesFail;
        this.mode = mode;
        this.port = port;
        this.uri = uri;
        this.interval = interval;
        this.timeout = timeout;
    }

    /**
     * Number of attempts before considering the target healthy (default: 2)
     */
    public Optional<? extends Long> strikesOk() {
        return strikesOk;
    }

    /**
     * Skip TLS verification
     */
    public Optional<? extends Boolean> tlsSkipVerify() {
        return tlsSkipVerify;
    }

    /**
     * An optional domain or subdomain to check TLS against
     */
    public Optional<? extends String> tlsSni() {
        return tlsSni;
    }

    /**
     * Number of attempts before considering the target unhealthy (default: 3)
     */
    public Optional<? extends Long> strikesFail() {
        return strikesFail;
    }

    /**
     * Health check mode
     */
    public ElasticIpHealthcheckMode mode() {
        return mode;
    }

    /**
     * Health check port
     */
    public long port() {
        return port;
    }

    /**
     * An endpoint to use for the health check, for example '/status'
     */
    public Optional<? extends String> uri() {
        return uri;
    }

    /**
     * Interval between the checks in seconds (default: 10)
     */
    public Optional<? extends Long> interval() {
        return interval;
    }

    /**
     * Health check timeout value in seconds (default: 2)
     */
    public Optional<? extends Long> timeout() {
        return timeout;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Number of attempts before considering the target healthy (default: 2)
     */
    public ElasticIpHealthcheck withStrikesOk(long strikesOk) {
        Utils.checkNotNull(strikesOk, "strikesOk");
        this.strikesOk = Optional.ofNullable(strikesOk);
        return this;
    }

    /**
     * Number of attempts before considering the target healthy (default: 2)
     */
    public ElasticIpHealthcheck withStrikesOk(Optional<? extends Long> strikesOk) {
        Utils.checkNotNull(strikesOk, "strikesOk");
        this.strikesOk = strikesOk;
        return this;
    }

    /**
     * Skip TLS verification
     */
    public ElasticIpHealthcheck withTlsSkipVerify(boolean tlsSkipVerify) {
        Utils.checkNotNull(tlsSkipVerify, "tlsSkipVerify");
        this.tlsSkipVerify = Optional.ofNullable(tlsSkipVerify);
        return this;
    }

    /**
     * Skip TLS verification
     */
    public ElasticIpHealthcheck withTlsSkipVerify(Optional<? extends Boolean> tlsSkipVerify) {
        Utils.checkNotNull(tlsSkipVerify, "tlsSkipVerify");
        this.tlsSkipVerify = tlsSkipVerify;
        return this;
    }

    /**
     * An optional domain or subdomain to check TLS against
     */
    public ElasticIpHealthcheck withTlsSni(String tlsSni) {
        Utils.checkNotNull(tlsSni, "tlsSni");
        this.tlsSni = Optional.ofNullable(tlsSni);
        return this;
    }

    /**
     * An optional domain or subdomain to check TLS against
     */
    public ElasticIpHealthcheck withTlsSni(Optional<? extends String> tlsSni) {
        Utils.checkNotNull(tlsSni, "tlsSni");
        this.tlsSni = tlsSni;
        return this;
    }

    /**
     * Number of attempts before considering the target unhealthy (default: 3)
     */
    public ElasticIpHealthcheck withStrikesFail(long strikesFail) {
        Utils.checkNotNull(strikesFail, "strikesFail");
        this.strikesFail = Optional.ofNullable(strikesFail);
        return this;
    }

    /**
     * Number of attempts before considering the target unhealthy (default: 3)
     */
    public ElasticIpHealthcheck withStrikesFail(Optional<? extends Long> strikesFail) {
        Utils.checkNotNull(strikesFail, "strikesFail");
        this.strikesFail = strikesFail;
        return this;
    }

    /**
     * Health check mode
     */
    public ElasticIpHealthcheck withMode(ElasticIpHealthcheckMode mode) {
        Utils.checkNotNull(mode, "mode");
        this.mode = mode;
        return this;
    }

    /**
     * Health check port
     */
    public ElasticIpHealthcheck withPort(long port) {
        Utils.checkNotNull(port, "port");
        this.port = port;
        return this;
    }

    /**
     * An endpoint to use for the health check, for example '/status'
     */
    public ElasticIpHealthcheck withUri(String uri) {
        Utils.checkNotNull(uri, "uri");
        this.uri = Optional.ofNullable(uri);
        return this;
    }

    /**
     * An endpoint to use for the health check, for example '/status'
     */
    public ElasticIpHealthcheck withUri(Optional<? extends String> uri) {
        Utils.checkNotNull(uri, "uri");
        this.uri = uri;
        return this;
    }

    /**
     * Interval between the checks in seconds (default: 10)
     */
    public ElasticIpHealthcheck withInterval(long interval) {
        Utils.checkNotNull(interval, "interval");
        this.interval = Optional.ofNullable(interval);
        return this;
    }

    /**
     * Interval between the checks in seconds (default: 10)
     */
    public ElasticIpHealthcheck withInterval(Optional<? extends Long> interval) {
        Utils.checkNotNull(interval, "interval");
        this.interval = interval;
        return this;
    }

    /**
     * Health check timeout value in seconds (default: 2)
     */
    public ElasticIpHealthcheck withTimeout(long timeout) {
        Utils.checkNotNull(timeout, "timeout");
        this.timeout = Optional.ofNullable(timeout);
        return this;
    }

    /**
     * Health check timeout value in seconds (default: 2)
     */
    public ElasticIpHealthcheck withTimeout(Optional<? extends Long> timeout) {
        Utils.checkNotNull(timeout, "timeout");
        this.timeout = timeout;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ElasticIpHealthcheck other = (ElasticIpHealthcheck) o;
        return 
            java.util.Objects.deepEquals(this.strikesOk, other.strikesOk) &&
            java.util.Objects.deepEquals(this.tlsSkipVerify, other.tlsSkipVerify) &&
            java.util.Objects.deepEquals(this.tlsSni, other.tlsSni) &&
            java.util.Objects.deepEquals(this.strikesFail, other.strikesFail) &&
            java.util.Objects.deepEquals(this.mode, other.mode) &&
            java.util.Objects.deepEquals(this.port, other.port) &&
            java.util.Objects.deepEquals(this.uri, other.uri) &&
            java.util.Objects.deepEquals(this.interval, other.interval) &&
            java.util.Objects.deepEquals(this.timeout, other.timeout);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            strikesOk,
            tlsSkipVerify,
            tlsSni,
            strikesFail,
            mode,
            port,
            uri,
            interval,
            timeout);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ElasticIpHealthcheck.class,
                "strikesOk", strikesOk,
                "tlsSkipVerify", tlsSkipVerify,
                "tlsSni", tlsSni,
                "strikesFail", strikesFail,
                "mode", mode,
                "port", port,
                "uri", uri,
                "interval", interval,
                "timeout", timeout);
    }
    
    public final static class Builder {
 
        private Optional<? extends Long> strikesOk = Optional.empty();
 
        private Optional<? extends Boolean> tlsSkipVerify = Optional.empty();
 
        private Optional<? extends String> tlsSni = Optional.empty();
 
        private Optional<? extends Long> strikesFail = Optional.empty();
 
        private ElasticIpHealthcheckMode mode;
 
        private Long port;
 
        private Optional<? extends String> uri = Optional.empty();
 
        private Optional<? extends Long> interval = Optional.empty();
 
        private Optional<? extends Long> timeout = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Number of attempts before considering the target healthy (default: 2)
         */
        public Builder strikesOk(long strikesOk) {
            Utils.checkNotNull(strikesOk, "strikesOk");
            this.strikesOk = Optional.ofNullable(strikesOk);
            return this;
        }

        /**
         * Number of attempts before considering the target healthy (default: 2)
         */
        public Builder strikesOk(Optional<? extends Long> strikesOk) {
            Utils.checkNotNull(strikesOk, "strikesOk");
            this.strikesOk = strikesOk;
            return this;
        }

        /**
         * Skip TLS verification
         */
        public Builder tlsSkipVerify(boolean tlsSkipVerify) {
            Utils.checkNotNull(tlsSkipVerify, "tlsSkipVerify");
            this.tlsSkipVerify = Optional.ofNullable(tlsSkipVerify);
            return this;
        }

        /**
         * Skip TLS verification
         */
        public Builder tlsSkipVerify(Optional<? extends Boolean> tlsSkipVerify) {
            Utils.checkNotNull(tlsSkipVerify, "tlsSkipVerify");
            this.tlsSkipVerify = tlsSkipVerify;
            return this;
        }

        /**
         * An optional domain or subdomain to check TLS against
         */
        public Builder tlsSni(String tlsSni) {
            Utils.checkNotNull(tlsSni, "tlsSni");
            this.tlsSni = Optional.ofNullable(tlsSni);
            return this;
        }

        /**
         * An optional domain or subdomain to check TLS against
         */
        public Builder tlsSni(Optional<? extends String> tlsSni) {
            Utils.checkNotNull(tlsSni, "tlsSni");
            this.tlsSni = tlsSni;
            return this;
        }

        /**
         * Number of attempts before considering the target unhealthy (default: 3)
         */
        public Builder strikesFail(long strikesFail) {
            Utils.checkNotNull(strikesFail, "strikesFail");
            this.strikesFail = Optional.ofNullable(strikesFail);
            return this;
        }

        /**
         * Number of attempts before considering the target unhealthy (default: 3)
         */
        public Builder strikesFail(Optional<? extends Long> strikesFail) {
            Utils.checkNotNull(strikesFail, "strikesFail");
            this.strikesFail = strikesFail;
            return this;
        }

        /**
         * Health check mode
         */
        public Builder mode(ElasticIpHealthcheckMode mode) {
            Utils.checkNotNull(mode, "mode");
            this.mode = mode;
            return this;
        }

        /**
         * Health check port
         */
        public Builder port(long port) {
            Utils.checkNotNull(port, "port");
            this.port = port;
            return this;
        }

        /**
         * An endpoint to use for the health check, for example '/status'
         */
        public Builder uri(String uri) {
            Utils.checkNotNull(uri, "uri");
            this.uri = Optional.ofNullable(uri);
            return this;
        }

        /**
         * An endpoint to use for the health check, for example '/status'
         */
        public Builder uri(Optional<? extends String> uri) {
            Utils.checkNotNull(uri, "uri");
            this.uri = uri;
            return this;
        }

        /**
         * Interval between the checks in seconds (default: 10)
         */
        public Builder interval(long interval) {
            Utils.checkNotNull(interval, "interval");
            this.interval = Optional.ofNullable(interval);
            return this;
        }

        /**
         * Interval between the checks in seconds (default: 10)
         */
        public Builder interval(Optional<? extends Long> interval) {
            Utils.checkNotNull(interval, "interval");
            this.interval = interval;
            return this;
        }

        /**
         * Health check timeout value in seconds (default: 2)
         */
        public Builder timeout(long timeout) {
            Utils.checkNotNull(timeout, "timeout");
            this.timeout = Optional.ofNullable(timeout);
            return this;
        }

        /**
         * Health check timeout value in seconds (default: 2)
         */
        public Builder timeout(Optional<? extends Long> timeout) {
            Utils.checkNotNull(timeout, "timeout");
            this.timeout = timeout;
            return this;
        }
        
        public ElasticIpHealthcheck build() {
            return new ElasticIpHealthcheck(
                strikesOk,
                tlsSkipVerify,
                tlsSni,
                strikesFail,
                mode,
                port,
                uri,
                interval,
                timeout);
        }
    }
}

