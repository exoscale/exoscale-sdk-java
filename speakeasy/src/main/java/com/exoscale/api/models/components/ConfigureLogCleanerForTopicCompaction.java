/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.exoscale.api.models.components;

import com.exoscale.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;


public class ConfigureLogCleanerForTopicCompaction {

    /**
     * How long are delete records retained?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("log_cleaner_delete_retention_ms")
    private Optional<? extends Long> logCleanerDeleteRetentionMs;

    /**
     * The maximum amount of time message will remain uncompacted. Only applicable for logs that are being compacted
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("log_cleaner_max_compaction_lag_ms")
    private Optional<? extends Long> logCleanerMaxCompactionLagMs;

    /**
     * Controls log compactor frequency. Larger value means more frequent compactions but also more space wasted for logs. Consider setting log.cleaner.max.compaction.lag.ms to enforce compactions sooner, instead of setting a very high value for this option.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("log_cleaner_min_cleanable_ratio")
    private Optional<? extends Double> logCleanerMinCleanableRatio;

    /**
     * The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("log_cleaner_min_compaction_lag_ms")
    private Optional<? extends Long> logCleanerMinCompactionLagMs;

    /**
     * The default cleanup policy for segments beyond the retention window
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("log_cleanup_policy")
    private Optional<? extends LogCleanupPolicy> logCleanupPolicy;

    public ConfigureLogCleanerForTopicCompaction(
            @JsonProperty("log_cleaner_delete_retention_ms") Optional<? extends Long> logCleanerDeleteRetentionMs,
            @JsonProperty("log_cleaner_max_compaction_lag_ms") Optional<? extends Long> logCleanerMaxCompactionLagMs,
            @JsonProperty("log_cleaner_min_cleanable_ratio") Optional<? extends Double> logCleanerMinCleanableRatio,
            @JsonProperty("log_cleaner_min_compaction_lag_ms") Optional<? extends Long> logCleanerMinCompactionLagMs,
            @JsonProperty("log_cleanup_policy") Optional<? extends LogCleanupPolicy> logCleanupPolicy) {
        Utils.checkNotNull(logCleanerDeleteRetentionMs, "logCleanerDeleteRetentionMs");
        Utils.checkNotNull(logCleanerMaxCompactionLagMs, "logCleanerMaxCompactionLagMs");
        Utils.checkNotNull(logCleanerMinCleanableRatio, "logCleanerMinCleanableRatio");
        Utils.checkNotNull(logCleanerMinCompactionLagMs, "logCleanerMinCompactionLagMs");
        Utils.checkNotNull(logCleanupPolicy, "logCleanupPolicy");
        this.logCleanerDeleteRetentionMs = logCleanerDeleteRetentionMs;
        this.logCleanerMaxCompactionLagMs = logCleanerMaxCompactionLagMs;
        this.logCleanerMinCleanableRatio = logCleanerMinCleanableRatio;
        this.logCleanerMinCompactionLagMs = logCleanerMinCompactionLagMs;
        this.logCleanupPolicy = logCleanupPolicy;
    }

    /**
     * How long are delete records retained?
     */
    public Optional<? extends Long> logCleanerDeleteRetentionMs() {
        return logCleanerDeleteRetentionMs;
    }

    /**
     * The maximum amount of time message will remain uncompacted. Only applicable for logs that are being compacted
     */
    public Optional<? extends Long> logCleanerMaxCompactionLagMs() {
        return logCleanerMaxCompactionLagMs;
    }

    /**
     * Controls log compactor frequency. Larger value means more frequent compactions but also more space wasted for logs. Consider setting log.cleaner.max.compaction.lag.ms to enforce compactions sooner, instead of setting a very high value for this option.
     */
    public Optional<? extends Double> logCleanerMinCleanableRatio() {
        return logCleanerMinCleanableRatio;
    }

    /**
     * The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.
     */
    public Optional<? extends Long> logCleanerMinCompactionLagMs() {
        return logCleanerMinCompactionLagMs;
    }

    /**
     * The default cleanup policy for segments beyond the retention window
     */
    public Optional<? extends LogCleanupPolicy> logCleanupPolicy() {
        return logCleanupPolicy;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * How long are delete records retained?
     */
    public ConfigureLogCleanerForTopicCompaction withLogCleanerDeleteRetentionMs(long logCleanerDeleteRetentionMs) {
        Utils.checkNotNull(logCleanerDeleteRetentionMs, "logCleanerDeleteRetentionMs");
        this.logCleanerDeleteRetentionMs = Optional.ofNullable(logCleanerDeleteRetentionMs);
        return this;
    }

    /**
     * How long are delete records retained?
     */
    public ConfigureLogCleanerForTopicCompaction withLogCleanerDeleteRetentionMs(Optional<? extends Long> logCleanerDeleteRetentionMs) {
        Utils.checkNotNull(logCleanerDeleteRetentionMs, "logCleanerDeleteRetentionMs");
        this.logCleanerDeleteRetentionMs = logCleanerDeleteRetentionMs;
        return this;
    }

    /**
     * The maximum amount of time message will remain uncompacted. Only applicable for logs that are being compacted
     */
    public ConfigureLogCleanerForTopicCompaction withLogCleanerMaxCompactionLagMs(long logCleanerMaxCompactionLagMs) {
        Utils.checkNotNull(logCleanerMaxCompactionLagMs, "logCleanerMaxCompactionLagMs");
        this.logCleanerMaxCompactionLagMs = Optional.ofNullable(logCleanerMaxCompactionLagMs);
        return this;
    }

    /**
     * The maximum amount of time message will remain uncompacted. Only applicable for logs that are being compacted
     */
    public ConfigureLogCleanerForTopicCompaction withLogCleanerMaxCompactionLagMs(Optional<? extends Long> logCleanerMaxCompactionLagMs) {
        Utils.checkNotNull(logCleanerMaxCompactionLagMs, "logCleanerMaxCompactionLagMs");
        this.logCleanerMaxCompactionLagMs = logCleanerMaxCompactionLagMs;
        return this;
    }

    /**
     * Controls log compactor frequency. Larger value means more frequent compactions but also more space wasted for logs. Consider setting log.cleaner.max.compaction.lag.ms to enforce compactions sooner, instead of setting a very high value for this option.
     */
    public ConfigureLogCleanerForTopicCompaction withLogCleanerMinCleanableRatio(double logCleanerMinCleanableRatio) {
        Utils.checkNotNull(logCleanerMinCleanableRatio, "logCleanerMinCleanableRatio");
        this.logCleanerMinCleanableRatio = Optional.ofNullable(logCleanerMinCleanableRatio);
        return this;
    }

    /**
     * Controls log compactor frequency. Larger value means more frequent compactions but also more space wasted for logs. Consider setting log.cleaner.max.compaction.lag.ms to enforce compactions sooner, instead of setting a very high value for this option.
     */
    public ConfigureLogCleanerForTopicCompaction withLogCleanerMinCleanableRatio(Optional<? extends Double> logCleanerMinCleanableRatio) {
        Utils.checkNotNull(logCleanerMinCleanableRatio, "logCleanerMinCleanableRatio");
        this.logCleanerMinCleanableRatio = logCleanerMinCleanableRatio;
        return this;
    }

    /**
     * The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.
     */
    public ConfigureLogCleanerForTopicCompaction withLogCleanerMinCompactionLagMs(long logCleanerMinCompactionLagMs) {
        Utils.checkNotNull(logCleanerMinCompactionLagMs, "logCleanerMinCompactionLagMs");
        this.logCleanerMinCompactionLagMs = Optional.ofNullable(logCleanerMinCompactionLagMs);
        return this;
    }

    /**
     * The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.
     */
    public ConfigureLogCleanerForTopicCompaction withLogCleanerMinCompactionLagMs(Optional<? extends Long> logCleanerMinCompactionLagMs) {
        Utils.checkNotNull(logCleanerMinCompactionLagMs, "logCleanerMinCompactionLagMs");
        this.logCleanerMinCompactionLagMs = logCleanerMinCompactionLagMs;
        return this;
    }

    /**
     * The default cleanup policy for segments beyond the retention window
     */
    public ConfigureLogCleanerForTopicCompaction withLogCleanupPolicy(LogCleanupPolicy logCleanupPolicy) {
        Utils.checkNotNull(logCleanupPolicy, "logCleanupPolicy");
        this.logCleanupPolicy = Optional.ofNullable(logCleanupPolicy);
        return this;
    }

    /**
     * The default cleanup policy for segments beyond the retention window
     */
    public ConfigureLogCleanerForTopicCompaction withLogCleanupPolicy(Optional<? extends LogCleanupPolicy> logCleanupPolicy) {
        Utils.checkNotNull(logCleanupPolicy, "logCleanupPolicy");
        this.logCleanupPolicy = logCleanupPolicy;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ConfigureLogCleanerForTopicCompaction other = (ConfigureLogCleanerForTopicCompaction) o;
        return 
            java.util.Objects.deepEquals(this.logCleanerDeleteRetentionMs, other.logCleanerDeleteRetentionMs) &&
            java.util.Objects.deepEquals(this.logCleanerMaxCompactionLagMs, other.logCleanerMaxCompactionLagMs) &&
            java.util.Objects.deepEquals(this.logCleanerMinCleanableRatio, other.logCleanerMinCleanableRatio) &&
            java.util.Objects.deepEquals(this.logCleanerMinCompactionLagMs, other.logCleanerMinCompactionLagMs) &&
            java.util.Objects.deepEquals(this.logCleanupPolicy, other.logCleanupPolicy);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            logCleanerDeleteRetentionMs,
            logCleanerMaxCompactionLagMs,
            logCleanerMinCleanableRatio,
            logCleanerMinCompactionLagMs,
            logCleanupPolicy);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ConfigureLogCleanerForTopicCompaction.class,
                "logCleanerDeleteRetentionMs", logCleanerDeleteRetentionMs,
                "logCleanerMaxCompactionLagMs", logCleanerMaxCompactionLagMs,
                "logCleanerMinCleanableRatio", logCleanerMinCleanableRatio,
                "logCleanerMinCompactionLagMs", logCleanerMinCompactionLagMs,
                "logCleanupPolicy", logCleanupPolicy);
    }
    
    public final static class Builder {
 
        private Optional<? extends Long> logCleanerDeleteRetentionMs = Optional.empty();
 
        private Optional<? extends Long> logCleanerMaxCompactionLagMs = Optional.empty();
 
        private Optional<? extends Double> logCleanerMinCleanableRatio = Optional.empty();
 
        private Optional<? extends Long> logCleanerMinCompactionLagMs = Optional.empty();
 
        private Optional<? extends LogCleanupPolicy> logCleanupPolicy = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * How long are delete records retained?
         */
        public Builder logCleanerDeleteRetentionMs(long logCleanerDeleteRetentionMs) {
            Utils.checkNotNull(logCleanerDeleteRetentionMs, "logCleanerDeleteRetentionMs");
            this.logCleanerDeleteRetentionMs = Optional.ofNullable(logCleanerDeleteRetentionMs);
            return this;
        }

        /**
         * How long are delete records retained?
         */
        public Builder logCleanerDeleteRetentionMs(Optional<? extends Long> logCleanerDeleteRetentionMs) {
            Utils.checkNotNull(logCleanerDeleteRetentionMs, "logCleanerDeleteRetentionMs");
            this.logCleanerDeleteRetentionMs = logCleanerDeleteRetentionMs;
            return this;
        }

        /**
         * The maximum amount of time message will remain uncompacted. Only applicable for logs that are being compacted
         */
        public Builder logCleanerMaxCompactionLagMs(long logCleanerMaxCompactionLagMs) {
            Utils.checkNotNull(logCleanerMaxCompactionLagMs, "logCleanerMaxCompactionLagMs");
            this.logCleanerMaxCompactionLagMs = Optional.ofNullable(logCleanerMaxCompactionLagMs);
            return this;
        }

        /**
         * The maximum amount of time message will remain uncompacted. Only applicable for logs that are being compacted
         */
        public Builder logCleanerMaxCompactionLagMs(Optional<? extends Long> logCleanerMaxCompactionLagMs) {
            Utils.checkNotNull(logCleanerMaxCompactionLagMs, "logCleanerMaxCompactionLagMs");
            this.logCleanerMaxCompactionLagMs = logCleanerMaxCompactionLagMs;
            return this;
        }

        /**
         * Controls log compactor frequency. Larger value means more frequent compactions but also more space wasted for logs. Consider setting log.cleaner.max.compaction.lag.ms to enforce compactions sooner, instead of setting a very high value for this option.
         */
        public Builder logCleanerMinCleanableRatio(double logCleanerMinCleanableRatio) {
            Utils.checkNotNull(logCleanerMinCleanableRatio, "logCleanerMinCleanableRatio");
            this.logCleanerMinCleanableRatio = Optional.ofNullable(logCleanerMinCleanableRatio);
            return this;
        }

        /**
         * Controls log compactor frequency. Larger value means more frequent compactions but also more space wasted for logs. Consider setting log.cleaner.max.compaction.lag.ms to enforce compactions sooner, instead of setting a very high value for this option.
         */
        public Builder logCleanerMinCleanableRatio(Optional<? extends Double> logCleanerMinCleanableRatio) {
            Utils.checkNotNull(logCleanerMinCleanableRatio, "logCleanerMinCleanableRatio");
            this.logCleanerMinCleanableRatio = logCleanerMinCleanableRatio;
            return this;
        }

        /**
         * The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.
         */
        public Builder logCleanerMinCompactionLagMs(long logCleanerMinCompactionLagMs) {
            Utils.checkNotNull(logCleanerMinCompactionLagMs, "logCleanerMinCompactionLagMs");
            this.logCleanerMinCompactionLagMs = Optional.ofNullable(logCleanerMinCompactionLagMs);
            return this;
        }

        /**
         * The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.
         */
        public Builder logCleanerMinCompactionLagMs(Optional<? extends Long> logCleanerMinCompactionLagMs) {
            Utils.checkNotNull(logCleanerMinCompactionLagMs, "logCleanerMinCompactionLagMs");
            this.logCleanerMinCompactionLagMs = logCleanerMinCompactionLagMs;
            return this;
        }

        /**
         * The default cleanup policy for segments beyond the retention window
         */
        public Builder logCleanupPolicy(LogCleanupPolicy logCleanupPolicy) {
            Utils.checkNotNull(logCleanupPolicy, "logCleanupPolicy");
            this.logCleanupPolicy = Optional.ofNullable(logCleanupPolicy);
            return this;
        }

        /**
         * The default cleanup policy for segments beyond the retention window
         */
        public Builder logCleanupPolicy(Optional<? extends LogCleanupPolicy> logCleanupPolicy) {
            Utils.checkNotNull(logCleanupPolicy, "logCleanupPolicy");
            this.logCleanupPolicy = logCleanupPolicy;
            return this;
        }
        
        public ConfigureLogCleanerForTopicCompaction build() {
            return new ConfigureLogCleanerForTopicCompaction(
                logCleanerDeleteRetentionMs,
                logCleanerMaxCompactionLagMs,
                logCleanerMinCleanableRatio,
                logCleanerMinCompactionLagMs,
                logCleanupPolicy);
        }
    }
}

