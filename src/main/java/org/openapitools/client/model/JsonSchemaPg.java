/*
 * Exoscale Public API
 *  Infrastructure automation API, allowing programmatic access to all Exoscale products and services.  The [OpenAPI Specification](http://spec.openapis.org/oas/v3.0.3.html) source of this documentation can be obtained here:  * [JSON format](https://openapi-v2.exoscale.com/source.json) * [YAML format](https://openapi-v2.exoscale.com/source.yaml)
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: api@exoscale.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.AutovacuumSettings;
import org.openapitools.client.model.BackgroundBGWriterSettings;
import org.openapitools.client.model.WriteAheadLogWALSettings;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * JsonSchemaPg
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-03-27T17:14:44.205710495Z[Etc/UTC]", comments = "Generator version: 7.5.0-SNAPSHOT")
public class JsonSchemaPg {
  public static final String SERIALIZED_NAME_TRACK_ACTIVITY_QUERY_SIZE = "track_activity_query_size";
  @SerializedName(SERIALIZED_NAME_TRACK_ACTIVITY_QUERY_SIZE)
  private Integer trackActivityQuerySize;

  public static final String SERIALIZED_NAME_TIMEZONE = "timezone";
  @SerializedName(SERIALIZED_NAME_TIMEZONE)
  private String timezone;

  /**
   * Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
   */
  @JsonAdapter(TrackIoTimingEnum.Adapter.class)
  public enum TrackIoTimingEnum {
    OFF("off"),
    
    ON("on");

    private String value;

    TrackIoTimingEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TrackIoTimingEnum fromValue(String value) {
      for (TrackIoTimingEnum b : TrackIoTimingEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TrackIoTimingEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TrackIoTimingEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TrackIoTimingEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TrackIoTimingEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TrackIoTimingEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TRACK_IO_TIMING = "track_io_timing";
  @SerializedName(SERIALIZED_NAME_TRACK_IO_TIMING)
  private TrackIoTimingEnum trackIoTiming;

  public static final String SERIALIZED_NAME_PG_STAT_MONITOR_PGSM_ENABLE_QUERY_PLAN = "pg_stat_monitor.pgsm_enable_query_plan";
  @SerializedName(SERIALIZED_NAME_PG_STAT_MONITOR_PGSM_ENABLE_QUERY_PLAN)
  private Boolean pgStatMonitorPgsmEnableQueryPlan;

  public static final String SERIALIZED_NAME_MAX_FILES_PER_PROCESS = "max_files_per_process";
  @SerializedName(SERIALIZED_NAME_MAX_FILES_PER_PROCESS)
  private Integer maxFilesPerProcess;

  public static final String SERIALIZED_NAME_PG_STAT_MONITOR_PGSM_MAX_BUCKETS = "pg_stat_monitor.pgsm_max_buckets";
  @SerializedName(SERIALIZED_NAME_PG_STAT_MONITOR_PGSM_MAX_BUCKETS)
  private Integer pgStatMonitorPgsmMaxBuckets;

  public static final String SERIALIZED_NAME_WAL = "wal";
  @SerializedName(SERIALIZED_NAME_WAL)
  private WriteAheadLogWALSettings wal;

  /**
   * Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
   */
  @JsonAdapter(DefaultToastCompressionEnum.Adapter.class)
  public enum DefaultToastCompressionEnum {
    LZ4("lz4"),
    
    PGLZ("pglz");

    private String value;

    DefaultToastCompressionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DefaultToastCompressionEnum fromValue(String value) {
      for (DefaultToastCompressionEnum b : DefaultToastCompressionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DefaultToastCompressionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DefaultToastCompressionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DefaultToastCompressionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DefaultToastCompressionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DefaultToastCompressionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DEFAULT_TOAST_COMPRESSION = "default_toast_compression";
  @SerializedName(SERIALIZED_NAME_DEFAULT_TOAST_COMPRESSION)
  private DefaultToastCompressionEnum defaultToastCompression;

  public static final String SERIALIZED_NAME_DEADLOCK_TIMEOUT = "deadlock_timeout";
  @SerializedName(SERIALIZED_NAME_DEADLOCK_TIMEOUT)
  private Integer deadlockTimeout;

  public static final String SERIALIZED_NAME_IDLE_IN_TRANSACTION_SESSION_TIMEOUT = "idle_in_transaction_session_timeout";
  @SerializedName(SERIALIZED_NAME_IDLE_IN_TRANSACTION_SESSION_TIMEOUT)
  private Integer idleInTransactionSessionTimeout;

  public static final String SERIALIZED_NAME_MAX_PRED_LOCKS_PER_TRANSACTION = "max_pred_locks_per_transaction";
  @SerializedName(SERIALIZED_NAME_MAX_PRED_LOCKS_PER_TRANSACTION)
  private Integer maxPredLocksPerTransaction;

  public static final String SERIALIZED_NAME_MAX_REPLICATION_SLOTS = "max_replication_slots";
  @SerializedName(SERIALIZED_NAME_MAX_REPLICATION_SLOTS)
  private Integer maxReplicationSlots;

  public static final String SERIALIZED_NAME_AUTOVACUUM = "autovacuum";
  @SerializedName(SERIALIZED_NAME_AUTOVACUUM)
  private AutovacuumSettings autovacuum;

  public static final String SERIALIZED_NAME_MAX_PARALLEL_WORKERS_PER_GATHER = "max_parallel_workers_per_gather";
  @SerializedName(SERIALIZED_NAME_MAX_PARALLEL_WORKERS_PER_GATHER)
  private Integer maxParallelWorkersPerGather;

  public static final String SERIALIZED_NAME_PG_PARTMAN_BGW_INTERVAL = "pg_partman_bgw.interval";
  @SerializedName(SERIALIZED_NAME_PG_PARTMAN_BGW_INTERVAL)
  private Integer pgPartmanBgwInterval;

  /**
   * Choose from one of the available log-formats. These can support popular log analyzers like pgbadger, pganalyze etc.
   */
  @JsonAdapter(LogLinePrefixEnum.Adapter.class)
  public enum LogLinePrefixEnum {
    PID_P_USER_U_DB_D_APP_A_CLIENT_H_("'pid=%p,user=%u,db=%d,app=%a,client=%h '"),
    
    _T_P_L_1_USER_U_DB_D_APP_A_CLIENT_H_("'%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '"),
    
    _M_P_Q_USER_U_DB_D_APP_A_("'%m [%p] %q[user=%u,db=%d,app=%a] '");

    private String value;

    LogLinePrefixEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LogLinePrefixEnum fromValue(String value) {
      for (LogLinePrefixEnum b : LogLinePrefixEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LogLinePrefixEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LogLinePrefixEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LogLinePrefixEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LogLinePrefixEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LogLinePrefixEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LOG_LINE_PREFIX = "log_line_prefix";
  @SerializedName(SERIALIZED_NAME_LOG_LINE_PREFIX)
  private LogLinePrefixEnum logLinePrefix;

  public static final String SERIALIZED_NAME_LOG_TEMP_FILES = "log_temp_files";
  @SerializedName(SERIALIZED_NAME_LOG_TEMP_FILES)
  private Integer logTempFiles;

  public static final String SERIALIZED_NAME_MAX_LOCKS_PER_TRANSACTION = "max_locks_per_transaction";
  @SerializedName(SERIALIZED_NAME_MAX_LOCKS_PER_TRANSACTION)
  private Integer maxLocksPerTransaction;

  /**
   * Record commit time of transactions.
   */
  @JsonAdapter(TrackCommitTimestampEnum.Adapter.class)
  public enum TrackCommitTimestampEnum {
    OFF("off"),
    
    ON("on");

    private String value;

    TrackCommitTimestampEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TrackCommitTimestampEnum fromValue(String value) {
      for (TrackCommitTimestampEnum b : TrackCommitTimestampEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TrackCommitTimestampEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TrackCommitTimestampEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TrackCommitTimestampEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TrackCommitTimestampEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TrackCommitTimestampEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TRACK_COMMIT_TIMESTAMP = "track_commit_timestamp";
  @SerializedName(SERIALIZED_NAME_TRACK_COMMIT_TIMESTAMP)
  private TrackCommitTimestampEnum trackCommitTimestamp;

  /**
   * Enables tracking of function call counts and time used.
   */
  @JsonAdapter(TrackFunctionsEnum.Adapter.class)
  public enum TrackFunctionsEnum {
    ALL("all"),
    
    PL("pl"),
    
    NONE("none");

    private String value;

    TrackFunctionsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TrackFunctionsEnum fromValue(String value) {
      for (TrackFunctionsEnum b : TrackFunctionsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TrackFunctionsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TrackFunctionsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TrackFunctionsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TrackFunctionsEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TrackFunctionsEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TRACK_FUNCTIONS = "track_functions";
  @SerializedName(SERIALIZED_NAME_TRACK_FUNCTIONS)
  private TrackFunctionsEnum trackFunctions;

  public static final String SERIALIZED_NAME_MAX_STACK_DEPTH = "max_stack_depth";
  @SerializedName(SERIALIZED_NAME_MAX_STACK_DEPTH)
  private Integer maxStackDepth;

  public static final String SERIALIZED_NAME_MAX_PARALLEL_WORKERS = "max_parallel_workers";
  @SerializedName(SERIALIZED_NAME_MAX_PARALLEL_WORKERS)
  private Integer maxParallelWorkers;

  public static final String SERIALIZED_NAME_PG_PARTMAN_BGW_ROLE = "pg_partman_bgw.role";
  @SerializedName(SERIALIZED_NAME_PG_PARTMAN_BGW_ROLE)
  private String pgPartmanBgwRole;

  public static final String SERIALIZED_NAME_MAX_LOGICAL_REPLICATION_WORKERS = "max_logical_replication_workers";
  @SerializedName(SERIALIZED_NAME_MAX_LOGICAL_REPLICATION_WORKERS)
  private Integer maxLogicalReplicationWorkers;

  public static final String SERIALIZED_NAME_MAX_PREPARED_TRANSACTIONS = "max_prepared_transactions";
  @SerializedName(SERIALIZED_NAME_MAX_PREPARED_TRANSACTIONS)
  private Integer maxPreparedTransactions;

  public static final String SERIALIZED_NAME_MAX_WORKER_PROCESSES = "max_worker_processes";
  @SerializedName(SERIALIZED_NAME_MAX_WORKER_PROCESSES)
  private Integer maxWorkerProcesses;

  /**
   * Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
   */
  @JsonAdapter(PgStatStatementsTrackEnum.Adapter.class)
  public enum PgStatStatementsTrackEnum {
    ALL("all"),
    
    TOP("top"),
    
    NONE("none");

    private String value;

    PgStatStatementsTrackEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PgStatStatementsTrackEnum fromValue(String value) {
      for (PgStatStatementsTrackEnum b : PgStatStatementsTrackEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PgStatStatementsTrackEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PgStatStatementsTrackEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PgStatStatementsTrackEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PgStatStatementsTrackEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PgStatStatementsTrackEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PG_STAT_STATEMENTS_TRACK = "pg_stat_statements.track";
  @SerializedName(SERIALIZED_NAME_PG_STAT_STATEMENTS_TRACK)
  private PgStatStatementsTrackEnum pgStatStatementsTrack;

  public static final String SERIALIZED_NAME_TEMP_FILE_LIMIT = "temp_file_limit";
  @SerializedName(SERIALIZED_NAME_TEMP_FILE_LIMIT)
  private Integer tempFileLimit;

  /**
   * Controls the amount of detail written in the server log for each message that is logged.
   */
  @JsonAdapter(LogErrorVerbosityEnum.Adapter.class)
  public enum LogErrorVerbosityEnum {
    TERSE("TERSE"),
    
    DEFAULT("DEFAULT"),
    
    VERBOSE("VERBOSE");

    private String value;

    LogErrorVerbosityEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LogErrorVerbosityEnum fromValue(String value) {
      for (LogErrorVerbosityEnum b : LogErrorVerbosityEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LogErrorVerbosityEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LogErrorVerbosityEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LogErrorVerbosityEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LogErrorVerbosityEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LogErrorVerbosityEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LOG_ERROR_VERBOSITY = "log_error_verbosity";
  @SerializedName(SERIALIZED_NAME_LOG_ERROR_VERBOSITY)
  private LogErrorVerbosityEnum logErrorVerbosity;

  public static final String SERIALIZED_NAME_LOG_MIN_DURATION_STATEMENT = "log_min_duration_statement";
  @SerializedName(SERIALIZED_NAME_LOG_MIN_DURATION_STATEMENT)
  private Integer logMinDurationStatement;

  public static final String SERIALIZED_NAME_MAX_STANDBY_STREAMING_DELAY = "max_standby_streaming_delay";
  @SerializedName(SERIALIZED_NAME_MAX_STANDBY_STREAMING_DELAY)
  private Integer maxStandbyStreamingDelay;

  public static final String SERIALIZED_NAME_JIT = "jit";
  @SerializedName(SERIALIZED_NAME_JIT)
  private Boolean jit;

  public static final String SERIALIZED_NAME_MAX_STANDBY_ARCHIVE_DELAY = "max_standby_archive_delay";
  @SerializedName(SERIALIZED_NAME_MAX_STANDBY_ARCHIVE_DELAY)
  private Integer maxStandbyArchiveDelay;

  public static final String SERIALIZED_NAME_BG_WRITER = "bg-writer";
  @SerializedName(SERIALIZED_NAME_BG_WRITER)
  private BackgroundBGWriterSettings bgWriter;

  public JsonSchemaPg() {
  }

  public JsonSchemaPg trackActivityQuerySize(Integer trackActivityQuerySize) {
    this.trackActivityQuerySize = trackActivityQuerySize;
    return this;
  }

   /**
   * Specifies the number of bytes reserved to track the currently executing command for each active session.
   * minimum: 1024
   * maximum: 10240
   * @return trackActivityQuerySize
  **/
  @javax.annotation.Nullable
  public Integer getTrackActivityQuerySize() {
    return trackActivityQuerySize;
  }

  public void setTrackActivityQuerySize(Integer trackActivityQuerySize) {
    this.trackActivityQuerySize = trackActivityQuerySize;
  }


  public JsonSchemaPg timezone(String timezone) {
    this.timezone = timezone;
    return this;
  }

   /**
   * PostgreSQL service timezone
   * @return timezone
  **/
  @javax.annotation.Nullable
  public String getTimezone() {
    return timezone;
  }

  public void setTimezone(String timezone) {
    this.timezone = timezone;
  }


  public JsonSchemaPg trackIoTiming(TrackIoTimingEnum trackIoTiming) {
    this.trackIoTiming = trackIoTiming;
    return this;
  }

   /**
   * Enables timing of database I/O calls. This parameter is off by default, because it will repeatedly query the operating system for the current time, which may cause significant overhead on some platforms.
   * @return trackIoTiming
  **/
  @javax.annotation.Nullable
  public TrackIoTimingEnum getTrackIoTiming() {
    return trackIoTiming;
  }

  public void setTrackIoTiming(TrackIoTimingEnum trackIoTiming) {
    this.trackIoTiming = trackIoTiming;
  }


  public JsonSchemaPg pgStatMonitorPgsmEnableQueryPlan(Boolean pgStatMonitorPgsmEnableQueryPlan) {
    this.pgStatMonitorPgsmEnableQueryPlan = pgStatMonitorPgsmEnableQueryPlan;
    return this;
  }

   /**
   * Enables or disables query plan monitoring
   * @return pgStatMonitorPgsmEnableQueryPlan
  **/
  @javax.annotation.Nullable
  public Boolean getPgStatMonitorPgsmEnableQueryPlan() {
    return pgStatMonitorPgsmEnableQueryPlan;
  }

  public void setPgStatMonitorPgsmEnableQueryPlan(Boolean pgStatMonitorPgsmEnableQueryPlan) {
    this.pgStatMonitorPgsmEnableQueryPlan = pgStatMonitorPgsmEnableQueryPlan;
  }


  public JsonSchemaPg maxFilesPerProcess(Integer maxFilesPerProcess) {
    this.maxFilesPerProcess = maxFilesPerProcess;
    return this;
  }

   /**
   * PostgreSQL maximum number of files that can be open per process
   * minimum: 1000
   * maximum: 4096
   * @return maxFilesPerProcess
  **/
  @javax.annotation.Nullable
  public Integer getMaxFilesPerProcess() {
    return maxFilesPerProcess;
  }

  public void setMaxFilesPerProcess(Integer maxFilesPerProcess) {
    this.maxFilesPerProcess = maxFilesPerProcess;
  }


  public JsonSchemaPg pgStatMonitorPgsmMaxBuckets(Integer pgStatMonitorPgsmMaxBuckets) {
    this.pgStatMonitorPgsmMaxBuckets = pgStatMonitorPgsmMaxBuckets;
    return this;
  }

   /**
   * Sets the maximum number of buckets 
   * minimum: 1
   * maximum: 10
   * @return pgStatMonitorPgsmMaxBuckets
  **/
  @javax.annotation.Nullable
  public Integer getPgStatMonitorPgsmMaxBuckets() {
    return pgStatMonitorPgsmMaxBuckets;
  }

  public void setPgStatMonitorPgsmMaxBuckets(Integer pgStatMonitorPgsmMaxBuckets) {
    this.pgStatMonitorPgsmMaxBuckets = pgStatMonitorPgsmMaxBuckets;
  }


  public JsonSchemaPg wal(WriteAheadLogWALSettings wal) {
    this.wal = wal;
    return this;
  }

   /**
   * Get wal
   * @return wal
  **/
  @javax.annotation.Nullable
  public WriteAheadLogWALSettings getWal() {
    return wal;
  }

  public void setWal(WriteAheadLogWALSettings wal) {
    this.wal = wal;
  }


  public JsonSchemaPg defaultToastCompression(DefaultToastCompressionEnum defaultToastCompression) {
    this.defaultToastCompression = defaultToastCompression;
    return this;
  }

   /**
   * Specifies the default TOAST compression method for values of compressible columns (the default is lz4).
   * @return defaultToastCompression
  **/
  @javax.annotation.Nullable
  public DefaultToastCompressionEnum getDefaultToastCompression() {
    return defaultToastCompression;
  }

  public void setDefaultToastCompression(DefaultToastCompressionEnum defaultToastCompression) {
    this.defaultToastCompression = defaultToastCompression;
  }


  public JsonSchemaPg deadlockTimeout(Integer deadlockTimeout) {
    this.deadlockTimeout = deadlockTimeout;
    return this;
  }

   /**
   * This is the amount of time, in milliseconds, to wait on a lock before checking to see if there is a deadlock condition.
   * minimum: 500
   * maximum: 1800000
   * @return deadlockTimeout
  **/
  @javax.annotation.Nullable
  public Integer getDeadlockTimeout() {
    return deadlockTimeout;
  }

  public void setDeadlockTimeout(Integer deadlockTimeout) {
    this.deadlockTimeout = deadlockTimeout;
  }


  public JsonSchemaPg idleInTransactionSessionTimeout(Integer idleInTransactionSessionTimeout) {
    this.idleInTransactionSessionTimeout = idleInTransactionSessionTimeout;
    return this;
  }

   /**
   * Time out sessions with open transactions after this number of milliseconds
   * minimum: 0
   * maximum: 604800000
   * @return idleInTransactionSessionTimeout
  **/
  @javax.annotation.Nullable
  public Integer getIdleInTransactionSessionTimeout() {
    return idleInTransactionSessionTimeout;
  }

  public void setIdleInTransactionSessionTimeout(Integer idleInTransactionSessionTimeout) {
    this.idleInTransactionSessionTimeout = idleInTransactionSessionTimeout;
  }


  public JsonSchemaPg maxPredLocksPerTransaction(Integer maxPredLocksPerTransaction) {
    this.maxPredLocksPerTransaction = maxPredLocksPerTransaction;
    return this;
  }

   /**
   * PostgreSQL maximum predicate locks per transaction
   * minimum: 64
   * maximum: 5120
   * @return maxPredLocksPerTransaction
  **/
  @javax.annotation.Nullable
  public Integer getMaxPredLocksPerTransaction() {
    return maxPredLocksPerTransaction;
  }

  public void setMaxPredLocksPerTransaction(Integer maxPredLocksPerTransaction) {
    this.maxPredLocksPerTransaction = maxPredLocksPerTransaction;
  }


  public JsonSchemaPg maxReplicationSlots(Integer maxReplicationSlots) {
    this.maxReplicationSlots = maxReplicationSlots;
    return this;
  }

   /**
   * PostgreSQL maximum replication slots
   * minimum: 8
   * maximum: 64
   * @return maxReplicationSlots
  **/
  @javax.annotation.Nullable
  public Integer getMaxReplicationSlots() {
    return maxReplicationSlots;
  }

  public void setMaxReplicationSlots(Integer maxReplicationSlots) {
    this.maxReplicationSlots = maxReplicationSlots;
  }


  public JsonSchemaPg autovacuum(AutovacuumSettings autovacuum) {
    this.autovacuum = autovacuum;
    return this;
  }

   /**
   * Get autovacuum
   * @return autovacuum
  **/
  @javax.annotation.Nullable
  public AutovacuumSettings getAutovacuum() {
    return autovacuum;
  }

  public void setAutovacuum(AutovacuumSettings autovacuum) {
    this.autovacuum = autovacuum;
  }


  public JsonSchemaPg maxParallelWorkersPerGather(Integer maxParallelWorkersPerGather) {
    this.maxParallelWorkersPerGather = maxParallelWorkersPerGather;
    return this;
  }

   /**
   * Sets the maximum number of workers that can be started by a single Gather or Gather Merge node
   * minimum: 0
   * maximum: 96
   * @return maxParallelWorkersPerGather
  **/
  @javax.annotation.Nullable
  public Integer getMaxParallelWorkersPerGather() {
    return maxParallelWorkersPerGather;
  }

  public void setMaxParallelWorkersPerGather(Integer maxParallelWorkersPerGather) {
    this.maxParallelWorkersPerGather = maxParallelWorkersPerGather;
  }


  public JsonSchemaPg pgPartmanBgwInterval(Integer pgPartmanBgwInterval) {
    this.pgPartmanBgwInterval = pgPartmanBgwInterval;
    return this;
  }

   /**
   * Sets the time interval to run pg_partman&#39;s scheduled tasks
   * minimum: 3600
   * maximum: 604800
   * @return pgPartmanBgwInterval
  **/
  @javax.annotation.Nullable
  public Integer getPgPartmanBgwInterval() {
    return pgPartmanBgwInterval;
  }

  public void setPgPartmanBgwInterval(Integer pgPartmanBgwInterval) {
    this.pgPartmanBgwInterval = pgPartmanBgwInterval;
  }


  public JsonSchemaPg logLinePrefix(LogLinePrefixEnum logLinePrefix) {
    this.logLinePrefix = logLinePrefix;
    return this;
  }

   /**
   * Choose from one of the available log-formats. These can support popular log analyzers like pgbadger, pganalyze etc.
   * @return logLinePrefix
  **/
  @javax.annotation.Nullable
  public LogLinePrefixEnum getLogLinePrefix() {
    return logLinePrefix;
  }

  public void setLogLinePrefix(LogLinePrefixEnum logLinePrefix) {
    this.logLinePrefix = logLinePrefix;
  }


  public JsonSchemaPg logTempFiles(Integer logTempFiles) {
    this.logTempFiles = logTempFiles;
    return this;
  }

   /**
   * Log statements for each temporary file created larger than this number of kilobytes, -1 disables
   * minimum: -1
   * maximum: 2147483647
   * @return logTempFiles
  **/
  @javax.annotation.Nullable
  public Integer getLogTempFiles() {
    return logTempFiles;
  }

  public void setLogTempFiles(Integer logTempFiles) {
    this.logTempFiles = logTempFiles;
  }


  public JsonSchemaPg maxLocksPerTransaction(Integer maxLocksPerTransaction) {
    this.maxLocksPerTransaction = maxLocksPerTransaction;
    return this;
  }

   /**
   * PostgreSQL maximum locks per transaction
   * minimum: 64
   * maximum: 6400
   * @return maxLocksPerTransaction
  **/
  @javax.annotation.Nullable
  public Integer getMaxLocksPerTransaction() {
    return maxLocksPerTransaction;
  }

  public void setMaxLocksPerTransaction(Integer maxLocksPerTransaction) {
    this.maxLocksPerTransaction = maxLocksPerTransaction;
  }


  public JsonSchemaPg trackCommitTimestamp(TrackCommitTimestampEnum trackCommitTimestamp) {
    this.trackCommitTimestamp = trackCommitTimestamp;
    return this;
  }

   /**
   * Record commit time of transactions.
   * @return trackCommitTimestamp
  **/
  @javax.annotation.Nullable
  public TrackCommitTimestampEnum getTrackCommitTimestamp() {
    return trackCommitTimestamp;
  }

  public void setTrackCommitTimestamp(TrackCommitTimestampEnum trackCommitTimestamp) {
    this.trackCommitTimestamp = trackCommitTimestamp;
  }


  public JsonSchemaPg trackFunctions(TrackFunctionsEnum trackFunctions) {
    this.trackFunctions = trackFunctions;
    return this;
  }

   /**
   * Enables tracking of function call counts and time used.
   * @return trackFunctions
  **/
  @javax.annotation.Nullable
  public TrackFunctionsEnum getTrackFunctions() {
    return trackFunctions;
  }

  public void setTrackFunctions(TrackFunctionsEnum trackFunctions) {
    this.trackFunctions = trackFunctions;
  }


  public JsonSchemaPg maxStackDepth(Integer maxStackDepth) {
    this.maxStackDepth = maxStackDepth;
    return this;
  }

   /**
   * Maximum depth of the stack in bytes
   * minimum: 2097152
   * maximum: 6291456
   * @return maxStackDepth
  **/
  @javax.annotation.Nullable
  public Integer getMaxStackDepth() {
    return maxStackDepth;
  }

  public void setMaxStackDepth(Integer maxStackDepth) {
    this.maxStackDepth = maxStackDepth;
  }


  public JsonSchemaPg maxParallelWorkers(Integer maxParallelWorkers) {
    this.maxParallelWorkers = maxParallelWorkers;
    return this;
  }

   /**
   * Sets the maximum number of workers that the system can support for parallel queries
   * minimum: 0
   * maximum: 96
   * @return maxParallelWorkers
  **/
  @javax.annotation.Nullable
  public Integer getMaxParallelWorkers() {
    return maxParallelWorkers;
  }

  public void setMaxParallelWorkers(Integer maxParallelWorkers) {
    this.maxParallelWorkers = maxParallelWorkers;
  }


  public JsonSchemaPg pgPartmanBgwRole(String pgPartmanBgwRole) {
    this.pgPartmanBgwRole = pgPartmanBgwRole;
    return this;
  }

   /**
   * Controls which role to use for pg_partman&#39;s scheduled background tasks.
   * @return pgPartmanBgwRole
  **/
  @javax.annotation.Nullable
  public String getPgPartmanBgwRole() {
    return pgPartmanBgwRole;
  }

  public void setPgPartmanBgwRole(String pgPartmanBgwRole) {
    this.pgPartmanBgwRole = pgPartmanBgwRole;
  }


  public JsonSchemaPg maxLogicalReplicationWorkers(Integer maxLogicalReplicationWorkers) {
    this.maxLogicalReplicationWorkers = maxLogicalReplicationWorkers;
    return this;
  }

   /**
   * PostgreSQL maximum logical replication workers (taken from the pool of max_parallel_workers)
   * minimum: 4
   * maximum: 64
   * @return maxLogicalReplicationWorkers
  **/
  @javax.annotation.Nullable
  public Integer getMaxLogicalReplicationWorkers() {
    return maxLogicalReplicationWorkers;
  }

  public void setMaxLogicalReplicationWorkers(Integer maxLogicalReplicationWorkers) {
    this.maxLogicalReplicationWorkers = maxLogicalReplicationWorkers;
  }


  public JsonSchemaPg maxPreparedTransactions(Integer maxPreparedTransactions) {
    this.maxPreparedTransactions = maxPreparedTransactions;
    return this;
  }

   /**
   * PostgreSQL maximum prepared transactions
   * minimum: 0
   * maximum: 10000
   * @return maxPreparedTransactions
  **/
  @javax.annotation.Nullable
  public Integer getMaxPreparedTransactions() {
    return maxPreparedTransactions;
  }

  public void setMaxPreparedTransactions(Integer maxPreparedTransactions) {
    this.maxPreparedTransactions = maxPreparedTransactions;
  }


  public JsonSchemaPg maxWorkerProcesses(Integer maxWorkerProcesses) {
    this.maxWorkerProcesses = maxWorkerProcesses;
    return this;
  }

   /**
   * Sets the maximum number of background processes that the system can support
   * minimum: 8
   * maximum: 96
   * @return maxWorkerProcesses
  **/
  @javax.annotation.Nullable
  public Integer getMaxWorkerProcesses() {
    return maxWorkerProcesses;
  }

  public void setMaxWorkerProcesses(Integer maxWorkerProcesses) {
    this.maxWorkerProcesses = maxWorkerProcesses;
  }


  public JsonSchemaPg pgStatStatementsTrack(PgStatStatementsTrackEnum pgStatStatementsTrack) {
    this.pgStatStatementsTrack = pgStatStatementsTrack;
    return this;
  }

   /**
   * Controls which statements are counted. Specify top to track top-level statements (those issued directly by clients), all to also track nested statements (such as statements invoked within functions), or none to disable statement statistics collection. The default value is top.
   * @return pgStatStatementsTrack
  **/
  @javax.annotation.Nullable
  public PgStatStatementsTrackEnum getPgStatStatementsTrack() {
    return pgStatStatementsTrack;
  }

  public void setPgStatStatementsTrack(PgStatStatementsTrackEnum pgStatStatementsTrack) {
    this.pgStatStatementsTrack = pgStatStatementsTrack;
  }


  public JsonSchemaPg tempFileLimit(Integer tempFileLimit) {
    this.tempFileLimit = tempFileLimit;
    return this;
  }

   /**
   * PostgreSQL temporary file limit in KiB, -1 for unlimited
   * minimum: -1
   * maximum: 2147483647
   * @return tempFileLimit
  **/
  @javax.annotation.Nullable
  public Integer getTempFileLimit() {
    return tempFileLimit;
  }

  public void setTempFileLimit(Integer tempFileLimit) {
    this.tempFileLimit = tempFileLimit;
  }


  public JsonSchemaPg logErrorVerbosity(LogErrorVerbosityEnum logErrorVerbosity) {
    this.logErrorVerbosity = logErrorVerbosity;
    return this;
  }

   /**
   * Controls the amount of detail written in the server log for each message that is logged.
   * @return logErrorVerbosity
  **/
  @javax.annotation.Nullable
  public LogErrorVerbosityEnum getLogErrorVerbosity() {
    return logErrorVerbosity;
  }

  public void setLogErrorVerbosity(LogErrorVerbosityEnum logErrorVerbosity) {
    this.logErrorVerbosity = logErrorVerbosity;
  }


  public JsonSchemaPg logMinDurationStatement(Integer logMinDurationStatement) {
    this.logMinDurationStatement = logMinDurationStatement;
    return this;
  }

   /**
   * Log statements that take more than this number of milliseconds to run, -1 disables
   * minimum: -1
   * maximum: 86400000
   * @return logMinDurationStatement
  **/
  @javax.annotation.Nullable
  public Integer getLogMinDurationStatement() {
    return logMinDurationStatement;
  }

  public void setLogMinDurationStatement(Integer logMinDurationStatement) {
    this.logMinDurationStatement = logMinDurationStatement;
  }


  public JsonSchemaPg maxStandbyStreamingDelay(Integer maxStandbyStreamingDelay) {
    this.maxStandbyStreamingDelay = maxStandbyStreamingDelay;
    return this;
  }

   /**
   * Max standby streaming delay in milliseconds
   * minimum: 1
   * maximum: 43200000
   * @return maxStandbyStreamingDelay
  **/
  @javax.annotation.Nullable
  public Integer getMaxStandbyStreamingDelay() {
    return maxStandbyStreamingDelay;
  }

  public void setMaxStandbyStreamingDelay(Integer maxStandbyStreamingDelay) {
    this.maxStandbyStreamingDelay = maxStandbyStreamingDelay;
  }


  public JsonSchemaPg jit(Boolean jit) {
    this.jit = jit;
    return this;
  }

   /**
   * Controls system-wide use of Just-in-Time Compilation (JIT).
   * @return jit
  **/
  @javax.annotation.Nullable
  public Boolean getJit() {
    return jit;
  }

  public void setJit(Boolean jit) {
    this.jit = jit;
  }


  public JsonSchemaPg maxStandbyArchiveDelay(Integer maxStandbyArchiveDelay) {
    this.maxStandbyArchiveDelay = maxStandbyArchiveDelay;
    return this;
  }

   /**
   * Max standby archive delay in milliseconds
   * minimum: 1
   * maximum: 43200000
   * @return maxStandbyArchiveDelay
  **/
  @javax.annotation.Nullable
  public Integer getMaxStandbyArchiveDelay() {
    return maxStandbyArchiveDelay;
  }

  public void setMaxStandbyArchiveDelay(Integer maxStandbyArchiveDelay) {
    this.maxStandbyArchiveDelay = maxStandbyArchiveDelay;
  }


  public JsonSchemaPg bgWriter(BackgroundBGWriterSettings bgWriter) {
    this.bgWriter = bgWriter;
    return this;
  }

   /**
   * Get bgWriter
   * @return bgWriter
  **/
  @javax.annotation.Nullable
  public BackgroundBGWriterSettings getBgWriter() {
    return bgWriter;
  }

  public void setBgWriter(BackgroundBGWriterSettings bgWriter) {
    this.bgWriter = bgWriter;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    JsonSchemaPg jsonSchemaPg = (JsonSchemaPg) o;
    return Objects.equals(this.trackActivityQuerySize, jsonSchemaPg.trackActivityQuerySize) &&
        Objects.equals(this.timezone, jsonSchemaPg.timezone) &&
        Objects.equals(this.trackIoTiming, jsonSchemaPg.trackIoTiming) &&
        Objects.equals(this.pgStatMonitorPgsmEnableQueryPlan, jsonSchemaPg.pgStatMonitorPgsmEnableQueryPlan) &&
        Objects.equals(this.maxFilesPerProcess, jsonSchemaPg.maxFilesPerProcess) &&
        Objects.equals(this.pgStatMonitorPgsmMaxBuckets, jsonSchemaPg.pgStatMonitorPgsmMaxBuckets) &&
        Objects.equals(this.wal, jsonSchemaPg.wal) &&
        Objects.equals(this.defaultToastCompression, jsonSchemaPg.defaultToastCompression) &&
        Objects.equals(this.deadlockTimeout, jsonSchemaPg.deadlockTimeout) &&
        Objects.equals(this.idleInTransactionSessionTimeout, jsonSchemaPg.idleInTransactionSessionTimeout) &&
        Objects.equals(this.maxPredLocksPerTransaction, jsonSchemaPg.maxPredLocksPerTransaction) &&
        Objects.equals(this.maxReplicationSlots, jsonSchemaPg.maxReplicationSlots) &&
        Objects.equals(this.autovacuum, jsonSchemaPg.autovacuum) &&
        Objects.equals(this.maxParallelWorkersPerGather, jsonSchemaPg.maxParallelWorkersPerGather) &&
        Objects.equals(this.pgPartmanBgwInterval, jsonSchemaPg.pgPartmanBgwInterval) &&
        Objects.equals(this.logLinePrefix, jsonSchemaPg.logLinePrefix) &&
        Objects.equals(this.logTempFiles, jsonSchemaPg.logTempFiles) &&
        Objects.equals(this.maxLocksPerTransaction, jsonSchemaPg.maxLocksPerTransaction) &&
        Objects.equals(this.trackCommitTimestamp, jsonSchemaPg.trackCommitTimestamp) &&
        Objects.equals(this.trackFunctions, jsonSchemaPg.trackFunctions) &&
        Objects.equals(this.maxStackDepth, jsonSchemaPg.maxStackDepth) &&
        Objects.equals(this.maxParallelWorkers, jsonSchemaPg.maxParallelWorkers) &&
        Objects.equals(this.pgPartmanBgwRole, jsonSchemaPg.pgPartmanBgwRole) &&
        Objects.equals(this.maxLogicalReplicationWorkers, jsonSchemaPg.maxLogicalReplicationWorkers) &&
        Objects.equals(this.maxPreparedTransactions, jsonSchemaPg.maxPreparedTransactions) &&
        Objects.equals(this.maxWorkerProcesses, jsonSchemaPg.maxWorkerProcesses) &&
        Objects.equals(this.pgStatStatementsTrack, jsonSchemaPg.pgStatStatementsTrack) &&
        Objects.equals(this.tempFileLimit, jsonSchemaPg.tempFileLimit) &&
        Objects.equals(this.logErrorVerbosity, jsonSchemaPg.logErrorVerbosity) &&
        Objects.equals(this.logMinDurationStatement, jsonSchemaPg.logMinDurationStatement) &&
        Objects.equals(this.maxStandbyStreamingDelay, jsonSchemaPg.maxStandbyStreamingDelay) &&
        Objects.equals(this.jit, jsonSchemaPg.jit) &&
        Objects.equals(this.maxStandbyArchiveDelay, jsonSchemaPg.maxStandbyArchiveDelay) &&
        Objects.equals(this.bgWriter, jsonSchemaPg.bgWriter);
  }

  @Override
  public int hashCode() {
    return Objects.hash(trackActivityQuerySize, timezone, trackIoTiming, pgStatMonitorPgsmEnableQueryPlan, maxFilesPerProcess, pgStatMonitorPgsmMaxBuckets, wal, defaultToastCompression, deadlockTimeout, idleInTransactionSessionTimeout, maxPredLocksPerTransaction, maxReplicationSlots, autovacuum, maxParallelWorkersPerGather, pgPartmanBgwInterval, logLinePrefix, logTempFiles, maxLocksPerTransaction, trackCommitTimestamp, trackFunctions, maxStackDepth, maxParallelWorkers, pgPartmanBgwRole, maxLogicalReplicationWorkers, maxPreparedTransactions, maxWorkerProcesses, pgStatStatementsTrack, tempFileLimit, logErrorVerbosity, logMinDurationStatement, maxStandbyStreamingDelay, jit, maxStandbyArchiveDelay, bgWriter);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class JsonSchemaPg {\n");
    sb.append("    trackActivityQuerySize: ").append(toIndentedString(trackActivityQuerySize)).append("\n");
    sb.append("    timezone: ").append(toIndentedString(timezone)).append("\n");
    sb.append("    trackIoTiming: ").append(toIndentedString(trackIoTiming)).append("\n");
    sb.append("    pgStatMonitorPgsmEnableQueryPlan: ").append(toIndentedString(pgStatMonitorPgsmEnableQueryPlan)).append("\n");
    sb.append("    maxFilesPerProcess: ").append(toIndentedString(maxFilesPerProcess)).append("\n");
    sb.append("    pgStatMonitorPgsmMaxBuckets: ").append(toIndentedString(pgStatMonitorPgsmMaxBuckets)).append("\n");
    sb.append("    wal: ").append(toIndentedString(wal)).append("\n");
    sb.append("    defaultToastCompression: ").append(toIndentedString(defaultToastCompression)).append("\n");
    sb.append("    deadlockTimeout: ").append(toIndentedString(deadlockTimeout)).append("\n");
    sb.append("    idleInTransactionSessionTimeout: ").append(toIndentedString(idleInTransactionSessionTimeout)).append("\n");
    sb.append("    maxPredLocksPerTransaction: ").append(toIndentedString(maxPredLocksPerTransaction)).append("\n");
    sb.append("    maxReplicationSlots: ").append(toIndentedString(maxReplicationSlots)).append("\n");
    sb.append("    autovacuum: ").append(toIndentedString(autovacuum)).append("\n");
    sb.append("    maxParallelWorkersPerGather: ").append(toIndentedString(maxParallelWorkersPerGather)).append("\n");
    sb.append("    pgPartmanBgwInterval: ").append(toIndentedString(pgPartmanBgwInterval)).append("\n");
    sb.append("    logLinePrefix: ").append(toIndentedString(logLinePrefix)).append("\n");
    sb.append("    logTempFiles: ").append(toIndentedString(logTempFiles)).append("\n");
    sb.append("    maxLocksPerTransaction: ").append(toIndentedString(maxLocksPerTransaction)).append("\n");
    sb.append("    trackCommitTimestamp: ").append(toIndentedString(trackCommitTimestamp)).append("\n");
    sb.append("    trackFunctions: ").append(toIndentedString(trackFunctions)).append("\n");
    sb.append("    maxStackDepth: ").append(toIndentedString(maxStackDepth)).append("\n");
    sb.append("    maxParallelWorkers: ").append(toIndentedString(maxParallelWorkers)).append("\n");
    sb.append("    pgPartmanBgwRole: ").append(toIndentedString(pgPartmanBgwRole)).append("\n");
    sb.append("    maxLogicalReplicationWorkers: ").append(toIndentedString(maxLogicalReplicationWorkers)).append("\n");
    sb.append("    maxPreparedTransactions: ").append(toIndentedString(maxPreparedTransactions)).append("\n");
    sb.append("    maxWorkerProcesses: ").append(toIndentedString(maxWorkerProcesses)).append("\n");
    sb.append("    pgStatStatementsTrack: ").append(toIndentedString(pgStatStatementsTrack)).append("\n");
    sb.append("    tempFileLimit: ").append(toIndentedString(tempFileLimit)).append("\n");
    sb.append("    logErrorVerbosity: ").append(toIndentedString(logErrorVerbosity)).append("\n");
    sb.append("    logMinDurationStatement: ").append(toIndentedString(logMinDurationStatement)).append("\n");
    sb.append("    maxStandbyStreamingDelay: ").append(toIndentedString(maxStandbyStreamingDelay)).append("\n");
    sb.append("    jit: ").append(toIndentedString(jit)).append("\n");
    sb.append("    maxStandbyArchiveDelay: ").append(toIndentedString(maxStandbyArchiveDelay)).append("\n");
    sb.append("    bgWriter: ").append(toIndentedString(bgWriter)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("track_activity_query_size");
    openapiFields.add("timezone");
    openapiFields.add("track_io_timing");
    openapiFields.add("pg_stat_monitor.pgsm_enable_query_plan");
    openapiFields.add("max_files_per_process");
    openapiFields.add("pg_stat_monitor.pgsm_max_buckets");
    openapiFields.add("wal");
    openapiFields.add("default_toast_compression");
    openapiFields.add("deadlock_timeout");
    openapiFields.add("idle_in_transaction_session_timeout");
    openapiFields.add("max_pred_locks_per_transaction");
    openapiFields.add("max_replication_slots");
    openapiFields.add("autovacuum");
    openapiFields.add("max_parallel_workers_per_gather");
    openapiFields.add("pg_partman_bgw.interval");
    openapiFields.add("log_line_prefix");
    openapiFields.add("log_temp_files");
    openapiFields.add("max_locks_per_transaction");
    openapiFields.add("track_commit_timestamp");
    openapiFields.add("track_functions");
    openapiFields.add("max_stack_depth");
    openapiFields.add("max_parallel_workers");
    openapiFields.add("pg_partman_bgw.role");
    openapiFields.add("max_logical_replication_workers");
    openapiFields.add("max_prepared_transactions");
    openapiFields.add("max_worker_processes");
    openapiFields.add("pg_stat_statements.track");
    openapiFields.add("temp_file_limit");
    openapiFields.add("log_error_verbosity");
    openapiFields.add("log_min_duration_statement");
    openapiFields.add("max_standby_streaming_delay");
    openapiFields.add("jit");
    openapiFields.add("max_standby_archive_delay");
    openapiFields.add("bg-writer");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to JsonSchemaPg
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!JsonSchemaPg.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in JsonSchemaPg is not found in the empty JSON string", JsonSchemaPg.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!JsonSchemaPg.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `JsonSchemaPg` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("timezone") != null && !jsonObj.get("timezone").isJsonNull()) && !jsonObj.get("timezone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timezone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timezone").toString()));
      }
      if ((jsonObj.get("track_io_timing") != null && !jsonObj.get("track_io_timing").isJsonNull()) && !jsonObj.get("track_io_timing").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `track_io_timing` to be a primitive type in the JSON string but got `%s`", jsonObj.get("track_io_timing").toString()));
      }
      // validate the optional field `track_io_timing`
      if (jsonObj.get("track_io_timing") != null && !jsonObj.get("track_io_timing").isJsonNull()) {
        TrackIoTimingEnum.validateJsonElement(jsonObj.get("track_io_timing"));
      }
      // validate the optional field `wal`
      if (jsonObj.get("wal") != null && !jsonObj.get("wal").isJsonNull()) {
        WriteAheadLogWALSettings.validateJsonElement(jsonObj.get("wal"));
      }
      if ((jsonObj.get("default_toast_compression") != null && !jsonObj.get("default_toast_compression").isJsonNull()) && !jsonObj.get("default_toast_compression").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `default_toast_compression` to be a primitive type in the JSON string but got `%s`", jsonObj.get("default_toast_compression").toString()));
      }
      // validate the optional field `default_toast_compression`
      if (jsonObj.get("default_toast_compression") != null && !jsonObj.get("default_toast_compression").isJsonNull()) {
        DefaultToastCompressionEnum.validateJsonElement(jsonObj.get("default_toast_compression"));
      }
      // validate the optional field `autovacuum`
      if (jsonObj.get("autovacuum") != null && !jsonObj.get("autovacuum").isJsonNull()) {
        AutovacuumSettings.validateJsonElement(jsonObj.get("autovacuum"));
      }
      if ((jsonObj.get("log_line_prefix") != null && !jsonObj.get("log_line_prefix").isJsonNull()) && !jsonObj.get("log_line_prefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `log_line_prefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("log_line_prefix").toString()));
      }
      // validate the optional field `log_line_prefix`
      if (jsonObj.get("log_line_prefix") != null && !jsonObj.get("log_line_prefix").isJsonNull()) {
        LogLinePrefixEnum.validateJsonElement(jsonObj.get("log_line_prefix"));
      }
      if ((jsonObj.get("track_commit_timestamp") != null && !jsonObj.get("track_commit_timestamp").isJsonNull()) && !jsonObj.get("track_commit_timestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `track_commit_timestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("track_commit_timestamp").toString()));
      }
      // validate the optional field `track_commit_timestamp`
      if (jsonObj.get("track_commit_timestamp") != null && !jsonObj.get("track_commit_timestamp").isJsonNull()) {
        TrackCommitTimestampEnum.validateJsonElement(jsonObj.get("track_commit_timestamp"));
      }
      if ((jsonObj.get("track_functions") != null && !jsonObj.get("track_functions").isJsonNull()) && !jsonObj.get("track_functions").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `track_functions` to be a primitive type in the JSON string but got `%s`", jsonObj.get("track_functions").toString()));
      }
      // validate the optional field `track_functions`
      if (jsonObj.get("track_functions") != null && !jsonObj.get("track_functions").isJsonNull()) {
        TrackFunctionsEnum.validateJsonElement(jsonObj.get("track_functions"));
      }
      if ((jsonObj.get("pg_partman_bgw.role") != null && !jsonObj.get("pg_partman_bgw.role").isJsonNull()) && !jsonObj.get("pg_partman_bgw.role").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pg_partman_bgw.role` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pg_partman_bgw.role").toString()));
      }
      if ((jsonObj.get("pg_stat_statements.track") != null && !jsonObj.get("pg_stat_statements.track").isJsonNull()) && !jsonObj.get("pg_stat_statements.track").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pg_stat_statements.track` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pg_stat_statements.track").toString()));
      }
      // validate the optional field `pg_stat_statements.track`
      if (jsonObj.get("pg_stat_statements.track") != null && !jsonObj.get("pg_stat_statements.track").isJsonNull()) {
        PgStatStatementsTrackEnum.validateJsonElement(jsonObj.get("pg_stat_statements.track"));
      }
      if ((jsonObj.get("log_error_verbosity") != null && !jsonObj.get("log_error_verbosity").isJsonNull()) && !jsonObj.get("log_error_verbosity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `log_error_verbosity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("log_error_verbosity").toString()));
      }
      // validate the optional field `log_error_verbosity`
      if (jsonObj.get("log_error_verbosity") != null && !jsonObj.get("log_error_verbosity").isJsonNull()) {
        LogErrorVerbosityEnum.validateJsonElement(jsonObj.get("log_error_verbosity"));
      }
      // validate the optional field `bg-writer`
      if (jsonObj.get("bg-writer") != null && !jsonObj.get("bg-writer").isJsonNull()) {
        BackgroundBGWriterSettings.validateJsonElement(jsonObj.get("bg-writer"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!JsonSchemaPg.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'JsonSchemaPg' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<JsonSchemaPg> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(JsonSchemaPg.class));

       return (TypeAdapter<T>) new TypeAdapter<JsonSchemaPg>() {
           @Override
           public void write(JsonWriter out, JsonSchemaPg value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public JsonSchemaPg read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of JsonSchemaPg given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of JsonSchemaPg
  * @throws IOException if the JSON string is invalid with respect to JsonSchemaPg
  */
  public static JsonSchemaPg fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, JsonSchemaPg.class);
  }

 /**
  * Convert an instance of JsonSchemaPg to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

