/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.exoscale.api.models.components;

import com.exoscale.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;


public class InternalAuthenticationBackendLimiting {

    /**
     * The type of rate limiting
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("type")
    private Optional<? extends InternalAuthenticationBackendLimitingType> type;

    /**
     * The internal backend. Enter `internal`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authentication_backend")
    private Optional<? extends InternalAuthenticationBackendLimitingAuthenticationBackend> authenticationBackend;

    /**
     * The number of login attempts allowed before login is blocked
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("allowed_tries")
    private Optional<? extends Long> allowedTries;

    /**
     * The window of time in which the value for `allowed_tries` is enforced
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("time_window_seconds")
    private Optional<? extends Long> timeWindowSeconds;

    /**
     * The duration of time that login remains blocked after a failed login
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("block_expiry_seconds")
    private Optional<? extends Long> blockExpirySeconds;

    /**
     * The maximum number of blocked IP addresses
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max_blocked_clients")
    private Optional<? extends Long> maxBlockedClients;

    /**
     * The maximum number of tracked IP addresses that have failed login
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max_tracked_clients")
    private Optional<? extends Long> maxTrackedClients;

    public InternalAuthenticationBackendLimiting(
            @JsonProperty("type") Optional<? extends InternalAuthenticationBackendLimitingType> type,
            @JsonProperty("authentication_backend") Optional<? extends InternalAuthenticationBackendLimitingAuthenticationBackend> authenticationBackend,
            @JsonProperty("allowed_tries") Optional<? extends Long> allowedTries,
            @JsonProperty("time_window_seconds") Optional<? extends Long> timeWindowSeconds,
            @JsonProperty("block_expiry_seconds") Optional<? extends Long> blockExpirySeconds,
            @JsonProperty("max_blocked_clients") Optional<? extends Long> maxBlockedClients,
            @JsonProperty("max_tracked_clients") Optional<? extends Long> maxTrackedClients) {
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(authenticationBackend, "authenticationBackend");
        Utils.checkNotNull(allowedTries, "allowedTries");
        Utils.checkNotNull(timeWindowSeconds, "timeWindowSeconds");
        Utils.checkNotNull(blockExpirySeconds, "blockExpirySeconds");
        Utils.checkNotNull(maxBlockedClients, "maxBlockedClients");
        Utils.checkNotNull(maxTrackedClients, "maxTrackedClients");
        this.type = type;
        this.authenticationBackend = authenticationBackend;
        this.allowedTries = allowedTries;
        this.timeWindowSeconds = timeWindowSeconds;
        this.blockExpirySeconds = blockExpirySeconds;
        this.maxBlockedClients = maxBlockedClients;
        this.maxTrackedClients = maxTrackedClients;
    }

    /**
     * The type of rate limiting
     */
    public Optional<? extends InternalAuthenticationBackendLimitingType> type() {
        return type;
    }

    /**
     * The internal backend. Enter `internal`
     */
    public Optional<? extends InternalAuthenticationBackendLimitingAuthenticationBackend> authenticationBackend() {
        return authenticationBackend;
    }

    /**
     * The number of login attempts allowed before login is blocked
     */
    public Optional<? extends Long> allowedTries() {
        return allowedTries;
    }

    /**
     * The window of time in which the value for `allowed_tries` is enforced
     */
    public Optional<? extends Long> timeWindowSeconds() {
        return timeWindowSeconds;
    }

    /**
     * The duration of time that login remains blocked after a failed login
     */
    public Optional<? extends Long> blockExpirySeconds() {
        return blockExpirySeconds;
    }

    /**
     * The maximum number of blocked IP addresses
     */
    public Optional<? extends Long> maxBlockedClients() {
        return maxBlockedClients;
    }

    /**
     * The maximum number of tracked IP addresses that have failed login
     */
    public Optional<? extends Long> maxTrackedClients() {
        return maxTrackedClients;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The type of rate limiting
     */
    public InternalAuthenticationBackendLimiting withType(InternalAuthenticationBackendLimitingType type) {
        Utils.checkNotNull(type, "type");
        this.type = Optional.ofNullable(type);
        return this;
    }

    /**
     * The type of rate limiting
     */
    public InternalAuthenticationBackendLimiting withType(Optional<? extends InternalAuthenticationBackendLimitingType> type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    /**
     * The internal backend. Enter `internal`
     */
    public InternalAuthenticationBackendLimiting withAuthenticationBackend(InternalAuthenticationBackendLimitingAuthenticationBackend authenticationBackend) {
        Utils.checkNotNull(authenticationBackend, "authenticationBackend");
        this.authenticationBackend = Optional.ofNullable(authenticationBackend);
        return this;
    }

    /**
     * The internal backend. Enter `internal`
     */
    public InternalAuthenticationBackendLimiting withAuthenticationBackend(Optional<? extends InternalAuthenticationBackendLimitingAuthenticationBackend> authenticationBackend) {
        Utils.checkNotNull(authenticationBackend, "authenticationBackend");
        this.authenticationBackend = authenticationBackend;
        return this;
    }

    /**
     * The number of login attempts allowed before login is blocked
     */
    public InternalAuthenticationBackendLimiting withAllowedTries(long allowedTries) {
        Utils.checkNotNull(allowedTries, "allowedTries");
        this.allowedTries = Optional.ofNullable(allowedTries);
        return this;
    }

    /**
     * The number of login attempts allowed before login is blocked
     */
    public InternalAuthenticationBackendLimiting withAllowedTries(Optional<? extends Long> allowedTries) {
        Utils.checkNotNull(allowedTries, "allowedTries");
        this.allowedTries = allowedTries;
        return this;
    }

    /**
     * The window of time in which the value for `allowed_tries` is enforced
     */
    public InternalAuthenticationBackendLimiting withTimeWindowSeconds(long timeWindowSeconds) {
        Utils.checkNotNull(timeWindowSeconds, "timeWindowSeconds");
        this.timeWindowSeconds = Optional.ofNullable(timeWindowSeconds);
        return this;
    }

    /**
     * The window of time in which the value for `allowed_tries` is enforced
     */
    public InternalAuthenticationBackendLimiting withTimeWindowSeconds(Optional<? extends Long> timeWindowSeconds) {
        Utils.checkNotNull(timeWindowSeconds, "timeWindowSeconds");
        this.timeWindowSeconds = timeWindowSeconds;
        return this;
    }

    /**
     * The duration of time that login remains blocked after a failed login
     */
    public InternalAuthenticationBackendLimiting withBlockExpirySeconds(long blockExpirySeconds) {
        Utils.checkNotNull(blockExpirySeconds, "blockExpirySeconds");
        this.blockExpirySeconds = Optional.ofNullable(blockExpirySeconds);
        return this;
    }

    /**
     * The duration of time that login remains blocked after a failed login
     */
    public InternalAuthenticationBackendLimiting withBlockExpirySeconds(Optional<? extends Long> blockExpirySeconds) {
        Utils.checkNotNull(blockExpirySeconds, "blockExpirySeconds");
        this.blockExpirySeconds = blockExpirySeconds;
        return this;
    }

    /**
     * The maximum number of blocked IP addresses
     */
    public InternalAuthenticationBackendLimiting withMaxBlockedClients(long maxBlockedClients) {
        Utils.checkNotNull(maxBlockedClients, "maxBlockedClients");
        this.maxBlockedClients = Optional.ofNullable(maxBlockedClients);
        return this;
    }

    /**
     * The maximum number of blocked IP addresses
     */
    public InternalAuthenticationBackendLimiting withMaxBlockedClients(Optional<? extends Long> maxBlockedClients) {
        Utils.checkNotNull(maxBlockedClients, "maxBlockedClients");
        this.maxBlockedClients = maxBlockedClients;
        return this;
    }

    /**
     * The maximum number of tracked IP addresses that have failed login
     */
    public InternalAuthenticationBackendLimiting withMaxTrackedClients(long maxTrackedClients) {
        Utils.checkNotNull(maxTrackedClients, "maxTrackedClients");
        this.maxTrackedClients = Optional.ofNullable(maxTrackedClients);
        return this;
    }

    /**
     * The maximum number of tracked IP addresses that have failed login
     */
    public InternalAuthenticationBackendLimiting withMaxTrackedClients(Optional<? extends Long> maxTrackedClients) {
        Utils.checkNotNull(maxTrackedClients, "maxTrackedClients");
        this.maxTrackedClients = maxTrackedClients;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        InternalAuthenticationBackendLimiting other = (InternalAuthenticationBackendLimiting) o;
        return 
            java.util.Objects.deepEquals(this.type, other.type) &&
            java.util.Objects.deepEquals(this.authenticationBackend, other.authenticationBackend) &&
            java.util.Objects.deepEquals(this.allowedTries, other.allowedTries) &&
            java.util.Objects.deepEquals(this.timeWindowSeconds, other.timeWindowSeconds) &&
            java.util.Objects.deepEquals(this.blockExpirySeconds, other.blockExpirySeconds) &&
            java.util.Objects.deepEquals(this.maxBlockedClients, other.maxBlockedClients) &&
            java.util.Objects.deepEquals(this.maxTrackedClients, other.maxTrackedClients);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            type,
            authenticationBackend,
            allowedTries,
            timeWindowSeconds,
            blockExpirySeconds,
            maxBlockedClients,
            maxTrackedClients);
    }
    
    @Override
    public String toString() {
        return Utils.toString(InternalAuthenticationBackendLimiting.class,
                "type", type,
                "authenticationBackend", authenticationBackend,
                "allowedTries", allowedTries,
                "timeWindowSeconds", timeWindowSeconds,
                "blockExpirySeconds", blockExpirySeconds,
                "maxBlockedClients", maxBlockedClients,
                "maxTrackedClients", maxTrackedClients);
    }
    
    public final static class Builder {
 
        private Optional<? extends InternalAuthenticationBackendLimitingType> type = Optional.empty();
 
        private Optional<? extends InternalAuthenticationBackendLimitingAuthenticationBackend> authenticationBackend = Optional.empty();
 
        private Optional<? extends Long> allowedTries = Optional.empty();
 
        private Optional<? extends Long> timeWindowSeconds = Optional.empty();
 
        private Optional<? extends Long> blockExpirySeconds = Optional.empty();
 
        private Optional<? extends Long> maxBlockedClients = Optional.empty();
 
        private Optional<? extends Long> maxTrackedClients = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The type of rate limiting
         */
        public Builder type(InternalAuthenticationBackendLimitingType type) {
            Utils.checkNotNull(type, "type");
            this.type = Optional.ofNullable(type);
            return this;
        }

        /**
         * The type of rate limiting
         */
        public Builder type(Optional<? extends InternalAuthenticationBackendLimitingType> type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }

        /**
         * The internal backend. Enter `internal`
         */
        public Builder authenticationBackend(InternalAuthenticationBackendLimitingAuthenticationBackend authenticationBackend) {
            Utils.checkNotNull(authenticationBackend, "authenticationBackend");
            this.authenticationBackend = Optional.ofNullable(authenticationBackend);
            return this;
        }

        /**
         * The internal backend. Enter `internal`
         */
        public Builder authenticationBackend(Optional<? extends InternalAuthenticationBackendLimitingAuthenticationBackend> authenticationBackend) {
            Utils.checkNotNull(authenticationBackend, "authenticationBackend");
            this.authenticationBackend = authenticationBackend;
            return this;
        }

        /**
         * The number of login attempts allowed before login is blocked
         */
        public Builder allowedTries(long allowedTries) {
            Utils.checkNotNull(allowedTries, "allowedTries");
            this.allowedTries = Optional.ofNullable(allowedTries);
            return this;
        }

        /**
         * The number of login attempts allowed before login is blocked
         */
        public Builder allowedTries(Optional<? extends Long> allowedTries) {
            Utils.checkNotNull(allowedTries, "allowedTries");
            this.allowedTries = allowedTries;
            return this;
        }

        /**
         * The window of time in which the value for `allowed_tries` is enforced
         */
        public Builder timeWindowSeconds(long timeWindowSeconds) {
            Utils.checkNotNull(timeWindowSeconds, "timeWindowSeconds");
            this.timeWindowSeconds = Optional.ofNullable(timeWindowSeconds);
            return this;
        }

        /**
         * The window of time in which the value for `allowed_tries` is enforced
         */
        public Builder timeWindowSeconds(Optional<? extends Long> timeWindowSeconds) {
            Utils.checkNotNull(timeWindowSeconds, "timeWindowSeconds");
            this.timeWindowSeconds = timeWindowSeconds;
            return this;
        }

        /**
         * The duration of time that login remains blocked after a failed login
         */
        public Builder blockExpirySeconds(long blockExpirySeconds) {
            Utils.checkNotNull(blockExpirySeconds, "blockExpirySeconds");
            this.blockExpirySeconds = Optional.ofNullable(blockExpirySeconds);
            return this;
        }

        /**
         * The duration of time that login remains blocked after a failed login
         */
        public Builder blockExpirySeconds(Optional<? extends Long> blockExpirySeconds) {
            Utils.checkNotNull(blockExpirySeconds, "blockExpirySeconds");
            this.blockExpirySeconds = blockExpirySeconds;
            return this;
        }

        /**
         * The maximum number of blocked IP addresses
         */
        public Builder maxBlockedClients(long maxBlockedClients) {
            Utils.checkNotNull(maxBlockedClients, "maxBlockedClients");
            this.maxBlockedClients = Optional.ofNullable(maxBlockedClients);
            return this;
        }

        /**
         * The maximum number of blocked IP addresses
         */
        public Builder maxBlockedClients(Optional<? extends Long> maxBlockedClients) {
            Utils.checkNotNull(maxBlockedClients, "maxBlockedClients");
            this.maxBlockedClients = maxBlockedClients;
            return this;
        }

        /**
         * The maximum number of tracked IP addresses that have failed login
         */
        public Builder maxTrackedClients(long maxTrackedClients) {
            Utils.checkNotNull(maxTrackedClients, "maxTrackedClients");
            this.maxTrackedClients = Optional.ofNullable(maxTrackedClients);
            return this;
        }

        /**
         * The maximum number of tracked IP addresses that have failed login
         */
        public Builder maxTrackedClients(Optional<? extends Long> maxTrackedClients) {
            Utils.checkNotNull(maxTrackedClients, "maxTrackedClients");
            this.maxTrackedClients = maxTrackedClients;
            return this;
        }
        
        public InternalAuthenticationBackendLimiting build() {
            return new InternalAuthenticationBackendLimiting(
                type,
                authenticationBackend,
                allowedTries,
                timeWindowSeconds,
                blockExpirySeconds,
                maxBlockedClients,
                maxTrackedClients);
        }
    }
}

