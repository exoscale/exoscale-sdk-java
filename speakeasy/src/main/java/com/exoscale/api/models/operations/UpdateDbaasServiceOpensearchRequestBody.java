/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.exoscale.api.models.operations;

import com.exoscale.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;


public class UpdateDbaasServiceOpensearchRequestBody {

    /**
     * Maximum number of indexes to keep before deleting the oldest one
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max-index-count")
    private Optional<? extends Long> maxIndexCount;

    /**
     * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("keep-index-refresh-interval")
    private Optional<? extends Boolean> keepIndexRefreshInterval;

    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ip-filter")
    private Optional<? extends java.util.List<String>> ipFilter;

    /**
     * Service is protected against termination and powering off
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("termination-protection")
    private Optional<? extends Boolean> terminationProtection;

    /**
     * Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("index-patterns")
    private Optional<? extends java.util.List<UpdateDbaasServiceOpensearchIndexPatterns>> indexPatterns;

    /**
     * Automatic maintenance settings
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maintenance")
    private Optional<? extends UpdateDbaasServiceOpensearchMaintenance> maintenance;

    /**
     * Template settings for all new indexes
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("index-template")
    private Optional<? extends UpdateDbaasServiceOpensearchIndexTemplate> indexTemplate;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("opensearch-settings")
    private Optional<? extends com.exoscale.api.models.components.JsonSchemaOpensearch> opensearchSettings;

    /**
     * Version
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("version")
    private Optional<? extends String> version;

    /**
     * Subscription plan
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("plan")
    private Optional<? extends String> plan;

    /**
     * OpenSearch Dashboards settings
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("opensearch-dashboards")
    private Optional<? extends UpdateDbaasServiceOpensearchOpensearchDashboards> opensearchDashboards;

    public UpdateDbaasServiceOpensearchRequestBody(
            @JsonProperty("max-index-count") Optional<? extends Long> maxIndexCount,
            @JsonProperty("keep-index-refresh-interval") Optional<? extends Boolean> keepIndexRefreshInterval,
            @JsonProperty("ip-filter") Optional<? extends java.util.List<String>> ipFilter,
            @JsonProperty("termination-protection") Optional<? extends Boolean> terminationProtection,
            @JsonProperty("index-patterns") Optional<? extends java.util.List<UpdateDbaasServiceOpensearchIndexPatterns>> indexPatterns,
            @JsonProperty("maintenance") Optional<? extends UpdateDbaasServiceOpensearchMaintenance> maintenance,
            @JsonProperty("index-template") Optional<? extends UpdateDbaasServiceOpensearchIndexTemplate> indexTemplate,
            @JsonProperty("opensearch-settings") Optional<? extends com.exoscale.api.models.components.JsonSchemaOpensearch> opensearchSettings,
            @JsonProperty("version") Optional<? extends String> version,
            @JsonProperty("plan") Optional<? extends String> plan,
            @JsonProperty("opensearch-dashboards") Optional<? extends UpdateDbaasServiceOpensearchOpensearchDashboards> opensearchDashboards) {
        Utils.checkNotNull(maxIndexCount, "maxIndexCount");
        Utils.checkNotNull(keepIndexRefreshInterval, "keepIndexRefreshInterval");
        Utils.checkNotNull(ipFilter, "ipFilter");
        Utils.checkNotNull(terminationProtection, "terminationProtection");
        Utils.checkNotNull(indexPatterns, "indexPatterns");
        Utils.checkNotNull(maintenance, "maintenance");
        Utils.checkNotNull(indexTemplate, "indexTemplate");
        Utils.checkNotNull(opensearchSettings, "opensearchSettings");
        Utils.checkNotNull(version, "version");
        Utils.checkNotNull(plan, "plan");
        Utils.checkNotNull(opensearchDashboards, "opensearchDashboards");
        this.maxIndexCount = maxIndexCount;
        this.keepIndexRefreshInterval = keepIndexRefreshInterval;
        this.ipFilter = ipFilter;
        this.terminationProtection = terminationProtection;
        this.indexPatterns = indexPatterns;
        this.maintenance = maintenance;
        this.indexTemplate = indexTemplate;
        this.opensearchSettings = opensearchSettings;
        this.version = version;
        this.plan = plan;
        this.opensearchDashboards = opensearchDashboards;
    }

    /**
     * Maximum number of indexes to keep before deleting the oldest one
     */
    public Optional<? extends Long> maxIndexCount() {
        return maxIndexCount;
    }

    /**
     * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
     */
    public Optional<? extends Boolean> keepIndexRefreshInterval() {
        return keepIndexRefreshInterval;
    }

    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    public Optional<? extends java.util.List<String>> ipFilter() {
        return ipFilter;
    }

    /**
     * Service is protected against termination and powering off
     */
    public Optional<? extends Boolean> terminationProtection() {
        return terminationProtection;
    }

    /**
     * Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
     */
    public Optional<? extends java.util.List<UpdateDbaasServiceOpensearchIndexPatterns>> indexPatterns() {
        return indexPatterns;
    }

    /**
     * Automatic maintenance settings
     */
    public Optional<? extends UpdateDbaasServiceOpensearchMaintenance> maintenance() {
        return maintenance;
    }

    /**
     * Template settings for all new indexes
     */
    public Optional<? extends UpdateDbaasServiceOpensearchIndexTemplate> indexTemplate() {
        return indexTemplate;
    }

    public Optional<? extends com.exoscale.api.models.components.JsonSchemaOpensearch> opensearchSettings() {
        return opensearchSettings;
    }

    /**
     * Version
     */
    public Optional<? extends String> version() {
        return version;
    }

    /**
     * Subscription plan
     */
    public Optional<? extends String> plan() {
        return plan;
    }

    /**
     * OpenSearch Dashboards settings
     */
    public Optional<? extends UpdateDbaasServiceOpensearchOpensearchDashboards> opensearchDashboards() {
        return opensearchDashboards;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Maximum number of indexes to keep before deleting the oldest one
     */
    public UpdateDbaasServiceOpensearchRequestBody withMaxIndexCount(long maxIndexCount) {
        Utils.checkNotNull(maxIndexCount, "maxIndexCount");
        this.maxIndexCount = Optional.ofNullable(maxIndexCount);
        return this;
    }

    /**
     * Maximum number of indexes to keep before deleting the oldest one
     */
    public UpdateDbaasServiceOpensearchRequestBody withMaxIndexCount(Optional<? extends Long> maxIndexCount) {
        Utils.checkNotNull(maxIndexCount, "maxIndexCount");
        this.maxIndexCount = maxIndexCount;
        return this;
    }

    /**
     * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
     */
    public UpdateDbaasServiceOpensearchRequestBody withKeepIndexRefreshInterval(boolean keepIndexRefreshInterval) {
        Utils.checkNotNull(keepIndexRefreshInterval, "keepIndexRefreshInterval");
        this.keepIndexRefreshInterval = Optional.ofNullable(keepIndexRefreshInterval);
        return this;
    }

    /**
     * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
     */
    public UpdateDbaasServiceOpensearchRequestBody withKeepIndexRefreshInterval(Optional<? extends Boolean> keepIndexRefreshInterval) {
        Utils.checkNotNull(keepIndexRefreshInterval, "keepIndexRefreshInterval");
        this.keepIndexRefreshInterval = keepIndexRefreshInterval;
        return this;
    }

    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    public UpdateDbaasServiceOpensearchRequestBody withIpFilter(java.util.List<String> ipFilter) {
        Utils.checkNotNull(ipFilter, "ipFilter");
        this.ipFilter = Optional.ofNullable(ipFilter);
        return this;
    }

    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    public UpdateDbaasServiceOpensearchRequestBody withIpFilter(Optional<? extends java.util.List<String>> ipFilter) {
        Utils.checkNotNull(ipFilter, "ipFilter");
        this.ipFilter = ipFilter;
        return this;
    }

    /**
     * Service is protected against termination and powering off
     */
    public UpdateDbaasServiceOpensearchRequestBody withTerminationProtection(boolean terminationProtection) {
        Utils.checkNotNull(terminationProtection, "terminationProtection");
        this.terminationProtection = Optional.ofNullable(terminationProtection);
        return this;
    }

    /**
     * Service is protected against termination and powering off
     */
    public UpdateDbaasServiceOpensearchRequestBody withTerminationProtection(Optional<? extends Boolean> terminationProtection) {
        Utils.checkNotNull(terminationProtection, "terminationProtection");
        this.terminationProtection = terminationProtection;
        return this;
    }

    /**
     * Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
     */
    public UpdateDbaasServiceOpensearchRequestBody withIndexPatterns(java.util.List<UpdateDbaasServiceOpensearchIndexPatterns> indexPatterns) {
        Utils.checkNotNull(indexPatterns, "indexPatterns");
        this.indexPatterns = Optional.ofNullable(indexPatterns);
        return this;
    }

    /**
     * Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
     */
    public UpdateDbaasServiceOpensearchRequestBody withIndexPatterns(Optional<? extends java.util.List<UpdateDbaasServiceOpensearchIndexPatterns>> indexPatterns) {
        Utils.checkNotNull(indexPatterns, "indexPatterns");
        this.indexPatterns = indexPatterns;
        return this;
    }

    /**
     * Automatic maintenance settings
     */
    public UpdateDbaasServiceOpensearchRequestBody withMaintenance(UpdateDbaasServiceOpensearchMaintenance maintenance) {
        Utils.checkNotNull(maintenance, "maintenance");
        this.maintenance = Optional.ofNullable(maintenance);
        return this;
    }

    /**
     * Automatic maintenance settings
     */
    public UpdateDbaasServiceOpensearchRequestBody withMaintenance(Optional<? extends UpdateDbaasServiceOpensearchMaintenance> maintenance) {
        Utils.checkNotNull(maintenance, "maintenance");
        this.maintenance = maintenance;
        return this;
    }

    /**
     * Template settings for all new indexes
     */
    public UpdateDbaasServiceOpensearchRequestBody withIndexTemplate(UpdateDbaasServiceOpensearchIndexTemplate indexTemplate) {
        Utils.checkNotNull(indexTemplate, "indexTemplate");
        this.indexTemplate = Optional.ofNullable(indexTemplate);
        return this;
    }

    /**
     * Template settings for all new indexes
     */
    public UpdateDbaasServiceOpensearchRequestBody withIndexTemplate(Optional<? extends UpdateDbaasServiceOpensearchIndexTemplate> indexTemplate) {
        Utils.checkNotNull(indexTemplate, "indexTemplate");
        this.indexTemplate = indexTemplate;
        return this;
    }

    public UpdateDbaasServiceOpensearchRequestBody withOpensearchSettings(com.exoscale.api.models.components.JsonSchemaOpensearch opensearchSettings) {
        Utils.checkNotNull(opensearchSettings, "opensearchSettings");
        this.opensearchSettings = Optional.ofNullable(opensearchSettings);
        return this;
    }

    public UpdateDbaasServiceOpensearchRequestBody withOpensearchSettings(Optional<? extends com.exoscale.api.models.components.JsonSchemaOpensearch> opensearchSettings) {
        Utils.checkNotNull(opensearchSettings, "opensearchSettings");
        this.opensearchSettings = opensearchSettings;
        return this;
    }

    /**
     * Version
     */
    public UpdateDbaasServiceOpensearchRequestBody withVersion(String version) {
        Utils.checkNotNull(version, "version");
        this.version = Optional.ofNullable(version);
        return this;
    }

    /**
     * Version
     */
    public UpdateDbaasServiceOpensearchRequestBody withVersion(Optional<? extends String> version) {
        Utils.checkNotNull(version, "version");
        this.version = version;
        return this;
    }

    /**
     * Subscription plan
     */
    public UpdateDbaasServiceOpensearchRequestBody withPlan(String plan) {
        Utils.checkNotNull(plan, "plan");
        this.plan = Optional.ofNullable(plan);
        return this;
    }

    /**
     * Subscription plan
     */
    public UpdateDbaasServiceOpensearchRequestBody withPlan(Optional<? extends String> plan) {
        Utils.checkNotNull(plan, "plan");
        this.plan = plan;
        return this;
    }

    /**
     * OpenSearch Dashboards settings
     */
    public UpdateDbaasServiceOpensearchRequestBody withOpensearchDashboards(UpdateDbaasServiceOpensearchOpensearchDashboards opensearchDashboards) {
        Utils.checkNotNull(opensearchDashboards, "opensearchDashboards");
        this.opensearchDashboards = Optional.ofNullable(opensearchDashboards);
        return this;
    }

    /**
     * OpenSearch Dashboards settings
     */
    public UpdateDbaasServiceOpensearchRequestBody withOpensearchDashboards(Optional<? extends UpdateDbaasServiceOpensearchOpensearchDashboards> opensearchDashboards) {
        Utils.checkNotNull(opensearchDashboards, "opensearchDashboards");
        this.opensearchDashboards = opensearchDashboards;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        UpdateDbaasServiceOpensearchRequestBody other = (UpdateDbaasServiceOpensearchRequestBody) o;
        return 
            java.util.Objects.deepEquals(this.maxIndexCount, other.maxIndexCount) &&
            java.util.Objects.deepEquals(this.keepIndexRefreshInterval, other.keepIndexRefreshInterval) &&
            java.util.Objects.deepEquals(this.ipFilter, other.ipFilter) &&
            java.util.Objects.deepEquals(this.terminationProtection, other.terminationProtection) &&
            java.util.Objects.deepEquals(this.indexPatterns, other.indexPatterns) &&
            java.util.Objects.deepEquals(this.maintenance, other.maintenance) &&
            java.util.Objects.deepEquals(this.indexTemplate, other.indexTemplate) &&
            java.util.Objects.deepEquals(this.opensearchSettings, other.opensearchSettings) &&
            java.util.Objects.deepEquals(this.version, other.version) &&
            java.util.Objects.deepEquals(this.plan, other.plan) &&
            java.util.Objects.deepEquals(this.opensearchDashboards, other.opensearchDashboards);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            maxIndexCount,
            keepIndexRefreshInterval,
            ipFilter,
            terminationProtection,
            indexPatterns,
            maintenance,
            indexTemplate,
            opensearchSettings,
            version,
            plan,
            opensearchDashboards);
    }
    
    @Override
    public String toString() {
        return Utils.toString(UpdateDbaasServiceOpensearchRequestBody.class,
                "maxIndexCount", maxIndexCount,
                "keepIndexRefreshInterval", keepIndexRefreshInterval,
                "ipFilter", ipFilter,
                "terminationProtection", terminationProtection,
                "indexPatterns", indexPatterns,
                "maintenance", maintenance,
                "indexTemplate", indexTemplate,
                "opensearchSettings", opensearchSettings,
                "version", version,
                "plan", plan,
                "opensearchDashboards", opensearchDashboards);
    }
    
    public final static class Builder {
 
        private Optional<? extends Long> maxIndexCount = Optional.empty();
 
        private Optional<? extends Boolean> keepIndexRefreshInterval = Optional.empty();
 
        private Optional<? extends java.util.List<String>> ipFilter = Optional.empty();
 
        private Optional<? extends Boolean> terminationProtection = Optional.empty();
 
        private Optional<? extends java.util.List<UpdateDbaasServiceOpensearchIndexPatterns>> indexPatterns = Optional.empty();
 
        private Optional<? extends UpdateDbaasServiceOpensearchMaintenance> maintenance = Optional.empty();
 
        private Optional<? extends UpdateDbaasServiceOpensearchIndexTemplate> indexTemplate = Optional.empty();
 
        private Optional<? extends com.exoscale.api.models.components.JsonSchemaOpensearch> opensearchSettings = Optional.empty();
 
        private Optional<? extends String> version = Optional.empty();
 
        private Optional<? extends String> plan = Optional.empty();
 
        private Optional<? extends UpdateDbaasServiceOpensearchOpensearchDashboards> opensearchDashboards = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Maximum number of indexes to keep before deleting the oldest one
         */
        public Builder maxIndexCount(long maxIndexCount) {
            Utils.checkNotNull(maxIndexCount, "maxIndexCount");
            this.maxIndexCount = Optional.ofNullable(maxIndexCount);
            return this;
        }

        /**
         * Maximum number of indexes to keep before deleting the oldest one
         */
        public Builder maxIndexCount(Optional<? extends Long> maxIndexCount) {
            Utils.checkNotNull(maxIndexCount, "maxIndexCount");
            this.maxIndexCount = maxIndexCount;
            return this;
        }

        /**
         * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
         */
        public Builder keepIndexRefreshInterval(boolean keepIndexRefreshInterval) {
            Utils.checkNotNull(keepIndexRefreshInterval, "keepIndexRefreshInterval");
            this.keepIndexRefreshInterval = Optional.ofNullable(keepIndexRefreshInterval);
            return this;
        }

        /**
         * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
         */
        public Builder keepIndexRefreshInterval(Optional<? extends Boolean> keepIndexRefreshInterval) {
            Utils.checkNotNull(keepIndexRefreshInterval, "keepIndexRefreshInterval");
            this.keepIndexRefreshInterval = keepIndexRefreshInterval;
            return this;
        }

        /**
         * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
         */
        public Builder ipFilter(java.util.List<String> ipFilter) {
            Utils.checkNotNull(ipFilter, "ipFilter");
            this.ipFilter = Optional.ofNullable(ipFilter);
            return this;
        }

        /**
         * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
         */
        public Builder ipFilter(Optional<? extends java.util.List<String>> ipFilter) {
            Utils.checkNotNull(ipFilter, "ipFilter");
            this.ipFilter = ipFilter;
            return this;
        }

        /**
         * Service is protected against termination and powering off
         */
        public Builder terminationProtection(boolean terminationProtection) {
            Utils.checkNotNull(terminationProtection, "terminationProtection");
            this.terminationProtection = Optional.ofNullable(terminationProtection);
            return this;
        }

        /**
         * Service is protected against termination and powering off
         */
        public Builder terminationProtection(Optional<? extends Boolean> terminationProtection) {
            Utils.checkNotNull(terminationProtection, "terminationProtection");
            this.terminationProtection = terminationProtection;
            return this;
        }

        /**
         * Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
         */
        public Builder indexPatterns(java.util.List<UpdateDbaasServiceOpensearchIndexPatterns> indexPatterns) {
            Utils.checkNotNull(indexPatterns, "indexPatterns");
            this.indexPatterns = Optional.ofNullable(indexPatterns);
            return this;
        }

        /**
         * Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
         */
        public Builder indexPatterns(Optional<? extends java.util.List<UpdateDbaasServiceOpensearchIndexPatterns>> indexPatterns) {
            Utils.checkNotNull(indexPatterns, "indexPatterns");
            this.indexPatterns = indexPatterns;
            return this;
        }

        /**
         * Automatic maintenance settings
         */
        public Builder maintenance(UpdateDbaasServiceOpensearchMaintenance maintenance) {
            Utils.checkNotNull(maintenance, "maintenance");
            this.maintenance = Optional.ofNullable(maintenance);
            return this;
        }

        /**
         * Automatic maintenance settings
         */
        public Builder maintenance(Optional<? extends UpdateDbaasServiceOpensearchMaintenance> maintenance) {
            Utils.checkNotNull(maintenance, "maintenance");
            this.maintenance = maintenance;
            return this;
        }

        /**
         * Template settings for all new indexes
         */
        public Builder indexTemplate(UpdateDbaasServiceOpensearchIndexTemplate indexTemplate) {
            Utils.checkNotNull(indexTemplate, "indexTemplate");
            this.indexTemplate = Optional.ofNullable(indexTemplate);
            return this;
        }

        /**
         * Template settings for all new indexes
         */
        public Builder indexTemplate(Optional<? extends UpdateDbaasServiceOpensearchIndexTemplate> indexTemplate) {
            Utils.checkNotNull(indexTemplate, "indexTemplate");
            this.indexTemplate = indexTemplate;
            return this;
        }

        public Builder opensearchSettings(com.exoscale.api.models.components.JsonSchemaOpensearch opensearchSettings) {
            Utils.checkNotNull(opensearchSettings, "opensearchSettings");
            this.opensearchSettings = Optional.ofNullable(opensearchSettings);
            return this;
        }

        public Builder opensearchSettings(Optional<? extends com.exoscale.api.models.components.JsonSchemaOpensearch> opensearchSettings) {
            Utils.checkNotNull(opensearchSettings, "opensearchSettings");
            this.opensearchSettings = opensearchSettings;
            return this;
        }

        /**
         * Version
         */
        public Builder version(String version) {
            Utils.checkNotNull(version, "version");
            this.version = Optional.ofNullable(version);
            return this;
        }

        /**
         * Version
         */
        public Builder version(Optional<? extends String> version) {
            Utils.checkNotNull(version, "version");
            this.version = version;
            return this;
        }

        /**
         * Subscription plan
         */
        public Builder plan(String plan) {
            Utils.checkNotNull(plan, "plan");
            this.plan = Optional.ofNullable(plan);
            return this;
        }

        /**
         * Subscription plan
         */
        public Builder plan(Optional<? extends String> plan) {
            Utils.checkNotNull(plan, "plan");
            this.plan = plan;
            return this;
        }

        /**
         * OpenSearch Dashboards settings
         */
        public Builder opensearchDashboards(UpdateDbaasServiceOpensearchOpensearchDashboards opensearchDashboards) {
            Utils.checkNotNull(opensearchDashboards, "opensearchDashboards");
            this.opensearchDashboards = Optional.ofNullable(opensearchDashboards);
            return this;
        }

        /**
         * OpenSearch Dashboards settings
         */
        public Builder opensearchDashboards(Optional<? extends UpdateDbaasServiceOpensearchOpensearchDashboards> opensearchDashboards) {
            Utils.checkNotNull(opensearchDashboards, "opensearchDashboards");
            this.opensearchDashboards = opensearchDashboards;
            return this;
        }
        
        public UpdateDbaasServiceOpensearchRequestBody build() {
            return new UpdateDbaasServiceOpensearchRequestBody(
                maxIndexCount,
                keepIndexRefreshInterval,
                ipFilter,
                terminationProtection,
                indexPatterns,
                maintenance,
                indexTemplate,
                opensearchSettings,
                version,
                plan,
                opensearchDashboards);
        }
    }
}

