/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.exoscale.api.models.components;

import com.exoscale.api.utils.LazySingletonValue;
import com.exoscale.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class JsonSchemaOpensearch {

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thread_pool_search_throttled_size")
    private Optional<? extends Long> threadPoolSearchThrottledSize;

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thread_pool_analyze_size")
    private Optional<? extends Long> threadPoolAnalyzeSize;

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thread_pool_get_size")
    private Optional<? extends Long> threadPoolGetSize;

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thread_pool_get_queue_size")
    private Optional<? extends Long> threadPoolGetQueueSize;

    /**
     * Number of file chunks sent in parallel for each recovery. Defaults to 2.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("indices_recovery_max_concurrent_file_chunks")
    private Optional<? extends Long> indicesRecoveryMaxConcurrentFileChunks;

    /**
     * Percentage value. Default is 10%. Maximum amount of heap used for query cache. This is an expert setting. Too low value will decrease query performance and increase performance for other operations; too high value will cause issues with other OpenSearch functionality.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("indices_queries_cache_size")
    private Optional<? extends Long> indicesQueriesCacheSize;

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thread_pool_search_size")
    private Optional<? extends Long> threadPoolSearchSize;

    /**
     * Limits total inbound and outbound recovery traffic for each node. Applies to both peer recoveries as well as snapshot recoveries (i.e., restores from a snapshot). Defaults to 40mb
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("indices_recovery_max_bytes_per_sec")
    private Optional<? extends Long> indicesRecoveryMaxBytesPerSec;

    /**
     * The max length of an HTTP URL, in bytes
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("http_max_initial_line_length")
    private Optional<? extends Long> httpMaxInitialLineLength;

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thread_pool_write_queue_size")
    private Optional<? extends Long> threadPoolWriteQueueSize;

    /**
     * Script compilation circuit breaker limits the number of inline script compilations within a period of time. Default is use-context
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("script_max_compilations_rate")
    private Optional<? extends String> scriptMaxCompilationsRate;

    /**
     * Maximum number of aggregation buckets allowed in a single response. OpenSearch default value is used when this is not defined.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("search_max_buckets")
    private JsonNullable<? extends Long> searchMaxBuckets;

    /**
     * Whitelisted addresses for reindexing. Changing this value will cause all OpenSearch instances to restart.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("reindex_remote_whitelist")
    private JsonNullable<? extends java.util.List<String>> reindexRemoteWhitelist;

    /**
     * Compatibility mode sets OpenSearch to report its version as 7.10 so clients continue to work. Default is false
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("override_main_response_version")
    private Optional<? extends Boolean> overrideMainResponseVersion;

    /**
     * The max size of allowed headers, in bytes
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("http_max_header_size")
    private Optional<? extends Long> httpMaxHeaderSize;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("email-sender")
    private Optional<? extends OpensearchEmailSenderSettings> emailSender;

    /**
     * Relative amount. Maximum amount of heap memory used for field data cache. This is an expert setting; decreasing the value too much will increase overhead of loading field data; too much memory used for field data cache will decrease amount of heap available for other operations.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("indices_fielddata_cache_size")
    private JsonNullable<? extends Long> indicesFielddataCacheSize;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("action_destructive_requires_name")
    private JsonNullable<? extends Boolean> actionDestructiveRequiresName;

    /**
     * Percentage value. Default is 10%. Total amount of heap used for indexing buffer, before writing segments to disk. This is an expert setting. Too low value will slow down indexing; too high value will increase indexing performance but causes performance issues for query performance.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("indices_memory_index_buffer_size")
    private Optional<? extends Long> indicesMemoryIndexBufferSize;

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thread_pool_force_merge_size")
    private Optional<? extends Long> threadPoolForceMergeSize;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("auth_failure_listeners")
    private Optional<? extends OpensearchSecurityPluginSettings> authFailureListeners;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ism-history")
    private Optional<? extends OpensearchISMHistorySettings> ismHistory;

    /**
     * How many concurrent incoming/outgoing shard recoveries (normally replicas) are allowed to happen on a node. Defaults to 2.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cluster_routing_allocation_node_concurrent_recoveries")
    private Optional<? extends Long> clusterRoutingAllocationNodeConcurrentRecoveries;

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thread_pool_analyze_queue_size")
    private Optional<? extends Long> threadPoolAnalyzeQueueSize;

    /**
     * Explicitly allow or block automatic creation of indices. Defaults to true
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("action_auto_create_index_enabled")
    private Optional<? extends Boolean> actionAutoCreateIndexEnabled;

    /**
     * Maximum content length for HTTP requests to the OpenSearch HTTP API, in bytes.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("http_max_content_length")
    private Optional<? extends Long> httpMaxContentLength;

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thread_pool_write_size")
    private Optional<? extends Long> threadPoolWriteSize;

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thread_pool_search_queue_size")
    private Optional<? extends Long> threadPoolSearchQueueSize;

    /**
     * Maximum number of clauses Lucene BooleanQuery can have. The default value (1024) is relatively high, and increasing it may cause performance issues. Investigate other approaches first before increasing this value.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("indices_query_bool_max_clause_count")
    private Optional<? extends Long> indicesQueryBoolMaxClauseCount;

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("thread_pool_search_throttled_queue_size")
    private Optional<? extends Long> threadPoolSearchThrottledQueueSize;

    /**
     * Controls the number of shards allowed in the cluster per data node
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cluster_max_shards_per_node")
    private Optional<? extends Long> clusterMaxShardsPerNode;

    public JsonSchemaOpensearch(
            @JsonProperty("thread_pool_search_throttled_size") Optional<? extends Long> threadPoolSearchThrottledSize,
            @JsonProperty("thread_pool_analyze_size") Optional<? extends Long> threadPoolAnalyzeSize,
            @JsonProperty("thread_pool_get_size") Optional<? extends Long> threadPoolGetSize,
            @JsonProperty("thread_pool_get_queue_size") Optional<? extends Long> threadPoolGetQueueSize,
            @JsonProperty("indices_recovery_max_concurrent_file_chunks") Optional<? extends Long> indicesRecoveryMaxConcurrentFileChunks,
            @JsonProperty("indices_queries_cache_size") Optional<? extends Long> indicesQueriesCacheSize,
            @JsonProperty("thread_pool_search_size") Optional<? extends Long> threadPoolSearchSize,
            @JsonProperty("indices_recovery_max_bytes_per_sec") Optional<? extends Long> indicesRecoveryMaxBytesPerSec,
            @JsonProperty("http_max_initial_line_length") Optional<? extends Long> httpMaxInitialLineLength,
            @JsonProperty("thread_pool_write_queue_size") Optional<? extends Long> threadPoolWriteQueueSize,
            @JsonProperty("script_max_compilations_rate") Optional<? extends String> scriptMaxCompilationsRate,
            @JsonProperty("search_max_buckets") JsonNullable<? extends Long> searchMaxBuckets,
            @JsonProperty("reindex_remote_whitelist") JsonNullable<? extends java.util.List<String>> reindexRemoteWhitelist,
            @JsonProperty("override_main_response_version") Optional<? extends Boolean> overrideMainResponseVersion,
            @JsonProperty("http_max_header_size") Optional<? extends Long> httpMaxHeaderSize,
            @JsonProperty("email-sender") Optional<? extends OpensearchEmailSenderSettings> emailSender,
            @JsonProperty("indices_fielddata_cache_size") JsonNullable<? extends Long> indicesFielddataCacheSize,
            @JsonProperty("action_destructive_requires_name") JsonNullable<? extends Boolean> actionDestructiveRequiresName,
            @JsonProperty("indices_memory_index_buffer_size") Optional<? extends Long> indicesMemoryIndexBufferSize,
            @JsonProperty("thread_pool_force_merge_size") Optional<? extends Long> threadPoolForceMergeSize,
            @JsonProperty("auth_failure_listeners") Optional<? extends OpensearchSecurityPluginSettings> authFailureListeners,
            @JsonProperty("ism-history") Optional<? extends OpensearchISMHistorySettings> ismHistory,
            @JsonProperty("cluster_routing_allocation_node_concurrent_recoveries") Optional<? extends Long> clusterRoutingAllocationNodeConcurrentRecoveries,
            @JsonProperty("thread_pool_analyze_queue_size") Optional<? extends Long> threadPoolAnalyzeQueueSize,
            @JsonProperty("action_auto_create_index_enabled") Optional<? extends Boolean> actionAutoCreateIndexEnabled,
            @JsonProperty("http_max_content_length") Optional<? extends Long> httpMaxContentLength,
            @JsonProperty("thread_pool_write_size") Optional<? extends Long> threadPoolWriteSize,
            @JsonProperty("thread_pool_search_queue_size") Optional<? extends Long> threadPoolSearchQueueSize,
            @JsonProperty("indices_query_bool_max_clause_count") Optional<? extends Long> indicesQueryBoolMaxClauseCount,
            @JsonProperty("thread_pool_search_throttled_queue_size") Optional<? extends Long> threadPoolSearchThrottledQueueSize,
            @JsonProperty("cluster_max_shards_per_node") Optional<? extends Long> clusterMaxShardsPerNode) {
        Utils.checkNotNull(threadPoolSearchThrottledSize, "threadPoolSearchThrottledSize");
        Utils.checkNotNull(threadPoolAnalyzeSize, "threadPoolAnalyzeSize");
        Utils.checkNotNull(threadPoolGetSize, "threadPoolGetSize");
        Utils.checkNotNull(threadPoolGetQueueSize, "threadPoolGetQueueSize");
        Utils.checkNotNull(indicesRecoveryMaxConcurrentFileChunks, "indicesRecoveryMaxConcurrentFileChunks");
        Utils.checkNotNull(indicesQueriesCacheSize, "indicesQueriesCacheSize");
        Utils.checkNotNull(threadPoolSearchSize, "threadPoolSearchSize");
        Utils.checkNotNull(indicesRecoveryMaxBytesPerSec, "indicesRecoveryMaxBytesPerSec");
        Utils.checkNotNull(httpMaxInitialLineLength, "httpMaxInitialLineLength");
        Utils.checkNotNull(threadPoolWriteQueueSize, "threadPoolWriteQueueSize");
        Utils.checkNotNull(scriptMaxCompilationsRate, "scriptMaxCompilationsRate");
        Utils.checkNotNull(searchMaxBuckets, "searchMaxBuckets");
        Utils.checkNotNull(reindexRemoteWhitelist, "reindexRemoteWhitelist");
        Utils.checkNotNull(overrideMainResponseVersion, "overrideMainResponseVersion");
        Utils.checkNotNull(httpMaxHeaderSize, "httpMaxHeaderSize");
        Utils.checkNotNull(emailSender, "emailSender");
        Utils.checkNotNull(indicesFielddataCacheSize, "indicesFielddataCacheSize");
        Utils.checkNotNull(actionDestructiveRequiresName, "actionDestructiveRequiresName");
        Utils.checkNotNull(indicesMemoryIndexBufferSize, "indicesMemoryIndexBufferSize");
        Utils.checkNotNull(threadPoolForceMergeSize, "threadPoolForceMergeSize");
        Utils.checkNotNull(authFailureListeners, "authFailureListeners");
        Utils.checkNotNull(ismHistory, "ismHistory");
        Utils.checkNotNull(clusterRoutingAllocationNodeConcurrentRecoveries, "clusterRoutingAllocationNodeConcurrentRecoveries");
        Utils.checkNotNull(threadPoolAnalyzeQueueSize, "threadPoolAnalyzeQueueSize");
        Utils.checkNotNull(actionAutoCreateIndexEnabled, "actionAutoCreateIndexEnabled");
        Utils.checkNotNull(httpMaxContentLength, "httpMaxContentLength");
        Utils.checkNotNull(threadPoolWriteSize, "threadPoolWriteSize");
        Utils.checkNotNull(threadPoolSearchQueueSize, "threadPoolSearchQueueSize");
        Utils.checkNotNull(indicesQueryBoolMaxClauseCount, "indicesQueryBoolMaxClauseCount");
        Utils.checkNotNull(threadPoolSearchThrottledQueueSize, "threadPoolSearchThrottledQueueSize");
        Utils.checkNotNull(clusterMaxShardsPerNode, "clusterMaxShardsPerNode");
        this.threadPoolSearchThrottledSize = threadPoolSearchThrottledSize;
        this.threadPoolAnalyzeSize = threadPoolAnalyzeSize;
        this.threadPoolGetSize = threadPoolGetSize;
        this.threadPoolGetQueueSize = threadPoolGetQueueSize;
        this.indicesRecoveryMaxConcurrentFileChunks = indicesRecoveryMaxConcurrentFileChunks;
        this.indicesQueriesCacheSize = indicesQueriesCacheSize;
        this.threadPoolSearchSize = threadPoolSearchSize;
        this.indicesRecoveryMaxBytesPerSec = indicesRecoveryMaxBytesPerSec;
        this.httpMaxInitialLineLength = httpMaxInitialLineLength;
        this.threadPoolWriteQueueSize = threadPoolWriteQueueSize;
        this.scriptMaxCompilationsRate = scriptMaxCompilationsRate;
        this.searchMaxBuckets = searchMaxBuckets;
        this.reindexRemoteWhitelist = reindexRemoteWhitelist;
        this.overrideMainResponseVersion = overrideMainResponseVersion;
        this.httpMaxHeaderSize = httpMaxHeaderSize;
        this.emailSender = emailSender;
        this.indicesFielddataCacheSize = indicesFielddataCacheSize;
        this.actionDestructiveRequiresName = actionDestructiveRequiresName;
        this.indicesMemoryIndexBufferSize = indicesMemoryIndexBufferSize;
        this.threadPoolForceMergeSize = threadPoolForceMergeSize;
        this.authFailureListeners = authFailureListeners;
        this.ismHistory = ismHistory;
        this.clusterRoutingAllocationNodeConcurrentRecoveries = clusterRoutingAllocationNodeConcurrentRecoveries;
        this.threadPoolAnalyzeQueueSize = threadPoolAnalyzeQueueSize;
        this.actionAutoCreateIndexEnabled = actionAutoCreateIndexEnabled;
        this.httpMaxContentLength = httpMaxContentLength;
        this.threadPoolWriteSize = threadPoolWriteSize;
        this.threadPoolSearchQueueSize = threadPoolSearchQueueSize;
        this.indicesQueryBoolMaxClauseCount = indicesQueryBoolMaxClauseCount;
        this.threadPoolSearchThrottledQueueSize = threadPoolSearchThrottledQueueSize;
        this.clusterMaxShardsPerNode = clusterMaxShardsPerNode;
    }

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    public Optional<? extends Long> threadPoolSearchThrottledSize() {
        return threadPoolSearchThrottledSize;
    }

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    public Optional<? extends Long> threadPoolAnalyzeSize() {
        return threadPoolAnalyzeSize;
    }

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    public Optional<? extends Long> threadPoolGetSize() {
        return threadPoolGetSize;
    }

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    public Optional<? extends Long> threadPoolGetQueueSize() {
        return threadPoolGetQueueSize;
    }

    /**
     * Number of file chunks sent in parallel for each recovery. Defaults to 2.
     */
    public Optional<? extends Long> indicesRecoveryMaxConcurrentFileChunks() {
        return indicesRecoveryMaxConcurrentFileChunks;
    }

    /**
     * Percentage value. Default is 10%. Maximum amount of heap used for query cache. This is an expert setting. Too low value will decrease query performance and increase performance for other operations; too high value will cause issues with other OpenSearch functionality.
     */
    public Optional<? extends Long> indicesQueriesCacheSize() {
        return indicesQueriesCacheSize;
    }

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    public Optional<? extends Long> threadPoolSearchSize() {
        return threadPoolSearchSize;
    }

    /**
     * Limits total inbound and outbound recovery traffic for each node. Applies to both peer recoveries as well as snapshot recoveries (i.e., restores from a snapshot). Defaults to 40mb
     */
    public Optional<? extends Long> indicesRecoveryMaxBytesPerSec() {
        return indicesRecoveryMaxBytesPerSec;
    }

    /**
     * The max length of an HTTP URL, in bytes
     */
    public Optional<? extends Long> httpMaxInitialLineLength() {
        return httpMaxInitialLineLength;
    }

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    public Optional<? extends Long> threadPoolWriteQueueSize() {
        return threadPoolWriteQueueSize;
    }

    /**
     * Script compilation circuit breaker limits the number of inline script compilations within a period of time. Default is use-context
     */
    public Optional<? extends String> scriptMaxCompilationsRate() {
        return scriptMaxCompilationsRate;
    }

    /**
     * Maximum number of aggregation buckets allowed in a single response. OpenSearch default value is used when this is not defined.
     */
    public JsonNullable<? extends Long> searchMaxBuckets() {
        return searchMaxBuckets;
    }

    /**
     * Whitelisted addresses for reindexing. Changing this value will cause all OpenSearch instances to restart.
     */
    public JsonNullable<? extends java.util.List<String>> reindexRemoteWhitelist() {
        return reindexRemoteWhitelist;
    }

    /**
     * Compatibility mode sets OpenSearch to report its version as 7.10 so clients continue to work. Default is false
     */
    public Optional<? extends Boolean> overrideMainResponseVersion() {
        return overrideMainResponseVersion;
    }

    /**
     * The max size of allowed headers, in bytes
     */
    public Optional<? extends Long> httpMaxHeaderSize() {
        return httpMaxHeaderSize;
    }

    public Optional<? extends OpensearchEmailSenderSettings> emailSender() {
        return emailSender;
    }

    /**
     * Relative amount. Maximum amount of heap memory used for field data cache. This is an expert setting; decreasing the value too much will increase overhead of loading field data; too much memory used for field data cache will decrease amount of heap available for other operations.
     */
    public JsonNullable<? extends Long> indicesFielddataCacheSize() {
        return indicesFielddataCacheSize;
    }

    public JsonNullable<? extends Boolean> actionDestructiveRequiresName() {
        return actionDestructiveRequiresName;
    }

    /**
     * Percentage value. Default is 10%. Total amount of heap used for indexing buffer, before writing segments to disk. This is an expert setting. Too low value will slow down indexing; too high value will increase indexing performance but causes performance issues for query performance.
     */
    public Optional<? extends Long> indicesMemoryIndexBufferSize() {
        return indicesMemoryIndexBufferSize;
    }

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    public Optional<? extends Long> threadPoolForceMergeSize() {
        return threadPoolForceMergeSize;
    }

    public Optional<? extends OpensearchSecurityPluginSettings> authFailureListeners() {
        return authFailureListeners;
    }

    public Optional<? extends OpensearchISMHistorySettings> ismHistory() {
        return ismHistory;
    }

    /**
     * How many concurrent incoming/outgoing shard recoveries (normally replicas) are allowed to happen on a node. Defaults to 2.
     */
    public Optional<? extends Long> clusterRoutingAllocationNodeConcurrentRecoveries() {
        return clusterRoutingAllocationNodeConcurrentRecoveries;
    }

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    public Optional<? extends Long> threadPoolAnalyzeQueueSize() {
        return threadPoolAnalyzeQueueSize;
    }

    /**
     * Explicitly allow or block automatic creation of indices. Defaults to true
     */
    public Optional<? extends Boolean> actionAutoCreateIndexEnabled() {
        return actionAutoCreateIndexEnabled;
    }

    /**
     * Maximum content length for HTTP requests to the OpenSearch HTTP API, in bytes.
     */
    public Optional<? extends Long> httpMaxContentLength() {
        return httpMaxContentLength;
    }

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    public Optional<? extends Long> threadPoolWriteSize() {
        return threadPoolWriteSize;
    }

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    public Optional<? extends Long> threadPoolSearchQueueSize() {
        return threadPoolSearchQueueSize;
    }

    /**
     * Maximum number of clauses Lucene BooleanQuery can have. The default value (1024) is relatively high, and increasing it may cause performance issues. Investigate other approaches first before increasing this value.
     */
    public Optional<? extends Long> indicesQueryBoolMaxClauseCount() {
        return indicesQueryBoolMaxClauseCount;
    }

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    public Optional<? extends Long> threadPoolSearchThrottledQueueSize() {
        return threadPoolSearchThrottledQueueSize;
    }

    /**
     * Controls the number of shards allowed in the cluster per data node
     */
    public Optional<? extends Long> clusterMaxShardsPerNode() {
        return clusterMaxShardsPerNode;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    public JsonSchemaOpensearch withThreadPoolSearchThrottledSize(long threadPoolSearchThrottledSize) {
        Utils.checkNotNull(threadPoolSearchThrottledSize, "threadPoolSearchThrottledSize");
        this.threadPoolSearchThrottledSize = Optional.ofNullable(threadPoolSearchThrottledSize);
        return this;
    }

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    public JsonSchemaOpensearch withThreadPoolSearchThrottledSize(Optional<? extends Long> threadPoolSearchThrottledSize) {
        Utils.checkNotNull(threadPoolSearchThrottledSize, "threadPoolSearchThrottledSize");
        this.threadPoolSearchThrottledSize = threadPoolSearchThrottledSize;
        return this;
    }

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    public JsonSchemaOpensearch withThreadPoolAnalyzeSize(long threadPoolAnalyzeSize) {
        Utils.checkNotNull(threadPoolAnalyzeSize, "threadPoolAnalyzeSize");
        this.threadPoolAnalyzeSize = Optional.ofNullable(threadPoolAnalyzeSize);
        return this;
    }

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    public JsonSchemaOpensearch withThreadPoolAnalyzeSize(Optional<? extends Long> threadPoolAnalyzeSize) {
        Utils.checkNotNull(threadPoolAnalyzeSize, "threadPoolAnalyzeSize");
        this.threadPoolAnalyzeSize = threadPoolAnalyzeSize;
        return this;
    }

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    public JsonSchemaOpensearch withThreadPoolGetSize(long threadPoolGetSize) {
        Utils.checkNotNull(threadPoolGetSize, "threadPoolGetSize");
        this.threadPoolGetSize = Optional.ofNullable(threadPoolGetSize);
        return this;
    }

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    public JsonSchemaOpensearch withThreadPoolGetSize(Optional<? extends Long> threadPoolGetSize) {
        Utils.checkNotNull(threadPoolGetSize, "threadPoolGetSize");
        this.threadPoolGetSize = threadPoolGetSize;
        return this;
    }

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    public JsonSchemaOpensearch withThreadPoolGetQueueSize(long threadPoolGetQueueSize) {
        Utils.checkNotNull(threadPoolGetQueueSize, "threadPoolGetQueueSize");
        this.threadPoolGetQueueSize = Optional.ofNullable(threadPoolGetQueueSize);
        return this;
    }

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    public JsonSchemaOpensearch withThreadPoolGetQueueSize(Optional<? extends Long> threadPoolGetQueueSize) {
        Utils.checkNotNull(threadPoolGetQueueSize, "threadPoolGetQueueSize");
        this.threadPoolGetQueueSize = threadPoolGetQueueSize;
        return this;
    }

    /**
     * Number of file chunks sent in parallel for each recovery. Defaults to 2.
     */
    public JsonSchemaOpensearch withIndicesRecoveryMaxConcurrentFileChunks(long indicesRecoveryMaxConcurrentFileChunks) {
        Utils.checkNotNull(indicesRecoveryMaxConcurrentFileChunks, "indicesRecoveryMaxConcurrentFileChunks");
        this.indicesRecoveryMaxConcurrentFileChunks = Optional.ofNullable(indicesRecoveryMaxConcurrentFileChunks);
        return this;
    }

    /**
     * Number of file chunks sent in parallel for each recovery. Defaults to 2.
     */
    public JsonSchemaOpensearch withIndicesRecoveryMaxConcurrentFileChunks(Optional<? extends Long> indicesRecoveryMaxConcurrentFileChunks) {
        Utils.checkNotNull(indicesRecoveryMaxConcurrentFileChunks, "indicesRecoveryMaxConcurrentFileChunks");
        this.indicesRecoveryMaxConcurrentFileChunks = indicesRecoveryMaxConcurrentFileChunks;
        return this;
    }

    /**
     * Percentage value. Default is 10%. Maximum amount of heap used for query cache. This is an expert setting. Too low value will decrease query performance and increase performance for other operations; too high value will cause issues with other OpenSearch functionality.
     */
    public JsonSchemaOpensearch withIndicesQueriesCacheSize(long indicesQueriesCacheSize) {
        Utils.checkNotNull(indicesQueriesCacheSize, "indicesQueriesCacheSize");
        this.indicesQueriesCacheSize = Optional.ofNullable(indicesQueriesCacheSize);
        return this;
    }

    /**
     * Percentage value. Default is 10%. Maximum amount of heap used for query cache. This is an expert setting. Too low value will decrease query performance and increase performance for other operations; too high value will cause issues with other OpenSearch functionality.
     */
    public JsonSchemaOpensearch withIndicesQueriesCacheSize(Optional<? extends Long> indicesQueriesCacheSize) {
        Utils.checkNotNull(indicesQueriesCacheSize, "indicesQueriesCacheSize");
        this.indicesQueriesCacheSize = indicesQueriesCacheSize;
        return this;
    }

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    public JsonSchemaOpensearch withThreadPoolSearchSize(long threadPoolSearchSize) {
        Utils.checkNotNull(threadPoolSearchSize, "threadPoolSearchSize");
        this.threadPoolSearchSize = Optional.ofNullable(threadPoolSearchSize);
        return this;
    }

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    public JsonSchemaOpensearch withThreadPoolSearchSize(Optional<? extends Long> threadPoolSearchSize) {
        Utils.checkNotNull(threadPoolSearchSize, "threadPoolSearchSize");
        this.threadPoolSearchSize = threadPoolSearchSize;
        return this;
    }

    /**
     * Limits total inbound and outbound recovery traffic for each node. Applies to both peer recoveries as well as snapshot recoveries (i.e., restores from a snapshot). Defaults to 40mb
     */
    public JsonSchemaOpensearch withIndicesRecoveryMaxBytesPerSec(long indicesRecoveryMaxBytesPerSec) {
        Utils.checkNotNull(indicesRecoveryMaxBytesPerSec, "indicesRecoveryMaxBytesPerSec");
        this.indicesRecoveryMaxBytesPerSec = Optional.ofNullable(indicesRecoveryMaxBytesPerSec);
        return this;
    }

    /**
     * Limits total inbound and outbound recovery traffic for each node. Applies to both peer recoveries as well as snapshot recoveries (i.e., restores from a snapshot). Defaults to 40mb
     */
    public JsonSchemaOpensearch withIndicesRecoveryMaxBytesPerSec(Optional<? extends Long> indicesRecoveryMaxBytesPerSec) {
        Utils.checkNotNull(indicesRecoveryMaxBytesPerSec, "indicesRecoveryMaxBytesPerSec");
        this.indicesRecoveryMaxBytesPerSec = indicesRecoveryMaxBytesPerSec;
        return this;
    }

    /**
     * The max length of an HTTP URL, in bytes
     */
    public JsonSchemaOpensearch withHttpMaxInitialLineLength(long httpMaxInitialLineLength) {
        Utils.checkNotNull(httpMaxInitialLineLength, "httpMaxInitialLineLength");
        this.httpMaxInitialLineLength = Optional.ofNullable(httpMaxInitialLineLength);
        return this;
    }

    /**
     * The max length of an HTTP URL, in bytes
     */
    public JsonSchemaOpensearch withHttpMaxInitialLineLength(Optional<? extends Long> httpMaxInitialLineLength) {
        Utils.checkNotNull(httpMaxInitialLineLength, "httpMaxInitialLineLength");
        this.httpMaxInitialLineLength = httpMaxInitialLineLength;
        return this;
    }

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    public JsonSchemaOpensearch withThreadPoolWriteQueueSize(long threadPoolWriteQueueSize) {
        Utils.checkNotNull(threadPoolWriteQueueSize, "threadPoolWriteQueueSize");
        this.threadPoolWriteQueueSize = Optional.ofNullable(threadPoolWriteQueueSize);
        return this;
    }

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    public JsonSchemaOpensearch withThreadPoolWriteQueueSize(Optional<? extends Long> threadPoolWriteQueueSize) {
        Utils.checkNotNull(threadPoolWriteQueueSize, "threadPoolWriteQueueSize");
        this.threadPoolWriteQueueSize = threadPoolWriteQueueSize;
        return this;
    }

    /**
     * Script compilation circuit breaker limits the number of inline script compilations within a period of time. Default is use-context
     */
    public JsonSchemaOpensearch withScriptMaxCompilationsRate(String scriptMaxCompilationsRate) {
        Utils.checkNotNull(scriptMaxCompilationsRate, "scriptMaxCompilationsRate");
        this.scriptMaxCompilationsRate = Optional.ofNullable(scriptMaxCompilationsRate);
        return this;
    }

    /**
     * Script compilation circuit breaker limits the number of inline script compilations within a period of time. Default is use-context
     */
    public JsonSchemaOpensearch withScriptMaxCompilationsRate(Optional<? extends String> scriptMaxCompilationsRate) {
        Utils.checkNotNull(scriptMaxCompilationsRate, "scriptMaxCompilationsRate");
        this.scriptMaxCompilationsRate = scriptMaxCompilationsRate;
        return this;
    }

    /**
     * Maximum number of aggregation buckets allowed in a single response. OpenSearch default value is used when this is not defined.
     */
    public JsonSchemaOpensearch withSearchMaxBuckets(long searchMaxBuckets) {
        Utils.checkNotNull(searchMaxBuckets, "searchMaxBuckets");
        this.searchMaxBuckets = JsonNullable.of(searchMaxBuckets);
        return this;
    }

    /**
     * Maximum number of aggregation buckets allowed in a single response. OpenSearch default value is used when this is not defined.
     */
    public JsonSchemaOpensearch withSearchMaxBuckets(JsonNullable<? extends Long> searchMaxBuckets) {
        Utils.checkNotNull(searchMaxBuckets, "searchMaxBuckets");
        this.searchMaxBuckets = searchMaxBuckets;
        return this;
    }

    /**
     * Whitelisted addresses for reindexing. Changing this value will cause all OpenSearch instances to restart.
     */
    public JsonSchemaOpensearch withReindexRemoteWhitelist(java.util.List<String> reindexRemoteWhitelist) {
        Utils.checkNotNull(reindexRemoteWhitelist, "reindexRemoteWhitelist");
        this.reindexRemoteWhitelist = JsonNullable.of(reindexRemoteWhitelist);
        return this;
    }

    /**
     * Whitelisted addresses for reindexing. Changing this value will cause all OpenSearch instances to restart.
     */
    public JsonSchemaOpensearch withReindexRemoteWhitelist(JsonNullable<? extends java.util.List<String>> reindexRemoteWhitelist) {
        Utils.checkNotNull(reindexRemoteWhitelist, "reindexRemoteWhitelist");
        this.reindexRemoteWhitelist = reindexRemoteWhitelist;
        return this;
    }

    /**
     * Compatibility mode sets OpenSearch to report its version as 7.10 so clients continue to work. Default is false
     */
    public JsonSchemaOpensearch withOverrideMainResponseVersion(boolean overrideMainResponseVersion) {
        Utils.checkNotNull(overrideMainResponseVersion, "overrideMainResponseVersion");
        this.overrideMainResponseVersion = Optional.ofNullable(overrideMainResponseVersion);
        return this;
    }

    /**
     * Compatibility mode sets OpenSearch to report its version as 7.10 so clients continue to work. Default is false
     */
    public JsonSchemaOpensearch withOverrideMainResponseVersion(Optional<? extends Boolean> overrideMainResponseVersion) {
        Utils.checkNotNull(overrideMainResponseVersion, "overrideMainResponseVersion");
        this.overrideMainResponseVersion = overrideMainResponseVersion;
        return this;
    }

    /**
     * The max size of allowed headers, in bytes
     */
    public JsonSchemaOpensearch withHttpMaxHeaderSize(long httpMaxHeaderSize) {
        Utils.checkNotNull(httpMaxHeaderSize, "httpMaxHeaderSize");
        this.httpMaxHeaderSize = Optional.ofNullable(httpMaxHeaderSize);
        return this;
    }

    /**
     * The max size of allowed headers, in bytes
     */
    public JsonSchemaOpensearch withHttpMaxHeaderSize(Optional<? extends Long> httpMaxHeaderSize) {
        Utils.checkNotNull(httpMaxHeaderSize, "httpMaxHeaderSize");
        this.httpMaxHeaderSize = httpMaxHeaderSize;
        return this;
    }

    public JsonSchemaOpensearch withEmailSender(OpensearchEmailSenderSettings emailSender) {
        Utils.checkNotNull(emailSender, "emailSender");
        this.emailSender = Optional.ofNullable(emailSender);
        return this;
    }

    public JsonSchemaOpensearch withEmailSender(Optional<? extends OpensearchEmailSenderSettings> emailSender) {
        Utils.checkNotNull(emailSender, "emailSender");
        this.emailSender = emailSender;
        return this;
    }

    /**
     * Relative amount. Maximum amount of heap memory used for field data cache. This is an expert setting; decreasing the value too much will increase overhead of loading field data; too much memory used for field data cache will decrease amount of heap available for other operations.
     */
    public JsonSchemaOpensearch withIndicesFielddataCacheSize(long indicesFielddataCacheSize) {
        Utils.checkNotNull(indicesFielddataCacheSize, "indicesFielddataCacheSize");
        this.indicesFielddataCacheSize = JsonNullable.of(indicesFielddataCacheSize);
        return this;
    }

    /**
     * Relative amount. Maximum amount of heap memory used for field data cache. This is an expert setting; decreasing the value too much will increase overhead of loading field data; too much memory used for field data cache will decrease amount of heap available for other operations.
     */
    public JsonSchemaOpensearch withIndicesFielddataCacheSize(JsonNullable<? extends Long> indicesFielddataCacheSize) {
        Utils.checkNotNull(indicesFielddataCacheSize, "indicesFielddataCacheSize");
        this.indicesFielddataCacheSize = indicesFielddataCacheSize;
        return this;
    }

    public JsonSchemaOpensearch withActionDestructiveRequiresName(boolean actionDestructiveRequiresName) {
        Utils.checkNotNull(actionDestructiveRequiresName, "actionDestructiveRequiresName");
        this.actionDestructiveRequiresName = JsonNullable.of(actionDestructiveRequiresName);
        return this;
    }

    public JsonSchemaOpensearch withActionDestructiveRequiresName(JsonNullable<? extends Boolean> actionDestructiveRequiresName) {
        Utils.checkNotNull(actionDestructiveRequiresName, "actionDestructiveRequiresName");
        this.actionDestructiveRequiresName = actionDestructiveRequiresName;
        return this;
    }

    /**
     * Percentage value. Default is 10%. Total amount of heap used for indexing buffer, before writing segments to disk. This is an expert setting. Too low value will slow down indexing; too high value will increase indexing performance but causes performance issues for query performance.
     */
    public JsonSchemaOpensearch withIndicesMemoryIndexBufferSize(long indicesMemoryIndexBufferSize) {
        Utils.checkNotNull(indicesMemoryIndexBufferSize, "indicesMemoryIndexBufferSize");
        this.indicesMemoryIndexBufferSize = Optional.ofNullable(indicesMemoryIndexBufferSize);
        return this;
    }

    /**
     * Percentage value. Default is 10%. Total amount of heap used for indexing buffer, before writing segments to disk. This is an expert setting. Too low value will slow down indexing; too high value will increase indexing performance but causes performance issues for query performance.
     */
    public JsonSchemaOpensearch withIndicesMemoryIndexBufferSize(Optional<? extends Long> indicesMemoryIndexBufferSize) {
        Utils.checkNotNull(indicesMemoryIndexBufferSize, "indicesMemoryIndexBufferSize");
        this.indicesMemoryIndexBufferSize = indicesMemoryIndexBufferSize;
        return this;
    }

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    public JsonSchemaOpensearch withThreadPoolForceMergeSize(long threadPoolForceMergeSize) {
        Utils.checkNotNull(threadPoolForceMergeSize, "threadPoolForceMergeSize");
        this.threadPoolForceMergeSize = Optional.ofNullable(threadPoolForceMergeSize);
        return this;
    }

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    public JsonSchemaOpensearch withThreadPoolForceMergeSize(Optional<? extends Long> threadPoolForceMergeSize) {
        Utils.checkNotNull(threadPoolForceMergeSize, "threadPoolForceMergeSize");
        this.threadPoolForceMergeSize = threadPoolForceMergeSize;
        return this;
    }

    public JsonSchemaOpensearch withAuthFailureListeners(OpensearchSecurityPluginSettings authFailureListeners) {
        Utils.checkNotNull(authFailureListeners, "authFailureListeners");
        this.authFailureListeners = Optional.ofNullable(authFailureListeners);
        return this;
    }

    public JsonSchemaOpensearch withAuthFailureListeners(Optional<? extends OpensearchSecurityPluginSettings> authFailureListeners) {
        Utils.checkNotNull(authFailureListeners, "authFailureListeners");
        this.authFailureListeners = authFailureListeners;
        return this;
    }

    public JsonSchemaOpensearch withIsmHistory(OpensearchISMHistorySettings ismHistory) {
        Utils.checkNotNull(ismHistory, "ismHistory");
        this.ismHistory = Optional.ofNullable(ismHistory);
        return this;
    }

    public JsonSchemaOpensearch withIsmHistory(Optional<? extends OpensearchISMHistorySettings> ismHistory) {
        Utils.checkNotNull(ismHistory, "ismHistory");
        this.ismHistory = ismHistory;
        return this;
    }

    /**
     * How many concurrent incoming/outgoing shard recoveries (normally replicas) are allowed to happen on a node. Defaults to 2.
     */
    public JsonSchemaOpensearch withClusterRoutingAllocationNodeConcurrentRecoveries(long clusterRoutingAllocationNodeConcurrentRecoveries) {
        Utils.checkNotNull(clusterRoutingAllocationNodeConcurrentRecoveries, "clusterRoutingAllocationNodeConcurrentRecoveries");
        this.clusterRoutingAllocationNodeConcurrentRecoveries = Optional.ofNullable(clusterRoutingAllocationNodeConcurrentRecoveries);
        return this;
    }

    /**
     * How many concurrent incoming/outgoing shard recoveries (normally replicas) are allowed to happen on a node. Defaults to 2.
     */
    public JsonSchemaOpensearch withClusterRoutingAllocationNodeConcurrentRecoveries(Optional<? extends Long> clusterRoutingAllocationNodeConcurrentRecoveries) {
        Utils.checkNotNull(clusterRoutingAllocationNodeConcurrentRecoveries, "clusterRoutingAllocationNodeConcurrentRecoveries");
        this.clusterRoutingAllocationNodeConcurrentRecoveries = clusterRoutingAllocationNodeConcurrentRecoveries;
        return this;
    }

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    public JsonSchemaOpensearch withThreadPoolAnalyzeQueueSize(long threadPoolAnalyzeQueueSize) {
        Utils.checkNotNull(threadPoolAnalyzeQueueSize, "threadPoolAnalyzeQueueSize");
        this.threadPoolAnalyzeQueueSize = Optional.ofNullable(threadPoolAnalyzeQueueSize);
        return this;
    }

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    public JsonSchemaOpensearch withThreadPoolAnalyzeQueueSize(Optional<? extends Long> threadPoolAnalyzeQueueSize) {
        Utils.checkNotNull(threadPoolAnalyzeQueueSize, "threadPoolAnalyzeQueueSize");
        this.threadPoolAnalyzeQueueSize = threadPoolAnalyzeQueueSize;
        return this;
    }

    /**
     * Explicitly allow or block automatic creation of indices. Defaults to true
     */
    public JsonSchemaOpensearch withActionAutoCreateIndexEnabled(boolean actionAutoCreateIndexEnabled) {
        Utils.checkNotNull(actionAutoCreateIndexEnabled, "actionAutoCreateIndexEnabled");
        this.actionAutoCreateIndexEnabled = Optional.ofNullable(actionAutoCreateIndexEnabled);
        return this;
    }

    /**
     * Explicitly allow or block automatic creation of indices. Defaults to true
     */
    public JsonSchemaOpensearch withActionAutoCreateIndexEnabled(Optional<? extends Boolean> actionAutoCreateIndexEnabled) {
        Utils.checkNotNull(actionAutoCreateIndexEnabled, "actionAutoCreateIndexEnabled");
        this.actionAutoCreateIndexEnabled = actionAutoCreateIndexEnabled;
        return this;
    }

    /**
     * Maximum content length for HTTP requests to the OpenSearch HTTP API, in bytes.
     */
    public JsonSchemaOpensearch withHttpMaxContentLength(long httpMaxContentLength) {
        Utils.checkNotNull(httpMaxContentLength, "httpMaxContentLength");
        this.httpMaxContentLength = Optional.ofNullable(httpMaxContentLength);
        return this;
    }

    /**
     * Maximum content length for HTTP requests to the OpenSearch HTTP API, in bytes.
     */
    public JsonSchemaOpensearch withHttpMaxContentLength(Optional<? extends Long> httpMaxContentLength) {
        Utils.checkNotNull(httpMaxContentLength, "httpMaxContentLength");
        this.httpMaxContentLength = httpMaxContentLength;
        return this;
    }

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    public JsonSchemaOpensearch withThreadPoolWriteSize(long threadPoolWriteSize) {
        Utils.checkNotNull(threadPoolWriteSize, "threadPoolWriteSize");
        this.threadPoolWriteSize = Optional.ofNullable(threadPoolWriteSize);
        return this;
    }

    /**
     * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
     */
    public JsonSchemaOpensearch withThreadPoolWriteSize(Optional<? extends Long> threadPoolWriteSize) {
        Utils.checkNotNull(threadPoolWriteSize, "threadPoolWriteSize");
        this.threadPoolWriteSize = threadPoolWriteSize;
        return this;
    }

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    public JsonSchemaOpensearch withThreadPoolSearchQueueSize(long threadPoolSearchQueueSize) {
        Utils.checkNotNull(threadPoolSearchQueueSize, "threadPoolSearchQueueSize");
        this.threadPoolSearchQueueSize = Optional.ofNullable(threadPoolSearchQueueSize);
        return this;
    }

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    public JsonSchemaOpensearch withThreadPoolSearchQueueSize(Optional<? extends Long> threadPoolSearchQueueSize) {
        Utils.checkNotNull(threadPoolSearchQueueSize, "threadPoolSearchQueueSize");
        this.threadPoolSearchQueueSize = threadPoolSearchQueueSize;
        return this;
    }

    /**
     * Maximum number of clauses Lucene BooleanQuery can have. The default value (1024) is relatively high, and increasing it may cause performance issues. Investigate other approaches first before increasing this value.
     */
    public JsonSchemaOpensearch withIndicesQueryBoolMaxClauseCount(long indicesQueryBoolMaxClauseCount) {
        Utils.checkNotNull(indicesQueryBoolMaxClauseCount, "indicesQueryBoolMaxClauseCount");
        this.indicesQueryBoolMaxClauseCount = Optional.ofNullable(indicesQueryBoolMaxClauseCount);
        return this;
    }

    /**
     * Maximum number of clauses Lucene BooleanQuery can have. The default value (1024) is relatively high, and increasing it may cause performance issues. Investigate other approaches first before increasing this value.
     */
    public JsonSchemaOpensearch withIndicesQueryBoolMaxClauseCount(Optional<? extends Long> indicesQueryBoolMaxClauseCount) {
        Utils.checkNotNull(indicesQueryBoolMaxClauseCount, "indicesQueryBoolMaxClauseCount");
        this.indicesQueryBoolMaxClauseCount = indicesQueryBoolMaxClauseCount;
        return this;
    }

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    public JsonSchemaOpensearch withThreadPoolSearchThrottledQueueSize(long threadPoolSearchThrottledQueueSize) {
        Utils.checkNotNull(threadPoolSearchThrottledQueueSize, "threadPoolSearchThrottledQueueSize");
        this.threadPoolSearchThrottledQueueSize = Optional.ofNullable(threadPoolSearchThrottledQueueSize);
        return this;
    }

    /**
     * Size for the thread pool queue. See documentation for exact details.
     */
    public JsonSchemaOpensearch withThreadPoolSearchThrottledQueueSize(Optional<? extends Long> threadPoolSearchThrottledQueueSize) {
        Utils.checkNotNull(threadPoolSearchThrottledQueueSize, "threadPoolSearchThrottledQueueSize");
        this.threadPoolSearchThrottledQueueSize = threadPoolSearchThrottledQueueSize;
        return this;
    }

    /**
     * Controls the number of shards allowed in the cluster per data node
     */
    public JsonSchemaOpensearch withClusterMaxShardsPerNode(long clusterMaxShardsPerNode) {
        Utils.checkNotNull(clusterMaxShardsPerNode, "clusterMaxShardsPerNode");
        this.clusterMaxShardsPerNode = Optional.ofNullable(clusterMaxShardsPerNode);
        return this;
    }

    /**
     * Controls the number of shards allowed in the cluster per data node
     */
    public JsonSchemaOpensearch withClusterMaxShardsPerNode(Optional<? extends Long> clusterMaxShardsPerNode) {
        Utils.checkNotNull(clusterMaxShardsPerNode, "clusterMaxShardsPerNode");
        this.clusterMaxShardsPerNode = clusterMaxShardsPerNode;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        JsonSchemaOpensearch other = (JsonSchemaOpensearch) o;
        return 
            java.util.Objects.deepEquals(this.threadPoolSearchThrottledSize, other.threadPoolSearchThrottledSize) &&
            java.util.Objects.deepEquals(this.threadPoolAnalyzeSize, other.threadPoolAnalyzeSize) &&
            java.util.Objects.deepEquals(this.threadPoolGetSize, other.threadPoolGetSize) &&
            java.util.Objects.deepEquals(this.threadPoolGetQueueSize, other.threadPoolGetQueueSize) &&
            java.util.Objects.deepEquals(this.indicesRecoveryMaxConcurrentFileChunks, other.indicesRecoveryMaxConcurrentFileChunks) &&
            java.util.Objects.deepEquals(this.indicesQueriesCacheSize, other.indicesQueriesCacheSize) &&
            java.util.Objects.deepEquals(this.threadPoolSearchSize, other.threadPoolSearchSize) &&
            java.util.Objects.deepEquals(this.indicesRecoveryMaxBytesPerSec, other.indicesRecoveryMaxBytesPerSec) &&
            java.util.Objects.deepEquals(this.httpMaxInitialLineLength, other.httpMaxInitialLineLength) &&
            java.util.Objects.deepEquals(this.threadPoolWriteQueueSize, other.threadPoolWriteQueueSize) &&
            java.util.Objects.deepEquals(this.scriptMaxCompilationsRate, other.scriptMaxCompilationsRate) &&
            java.util.Objects.deepEquals(this.searchMaxBuckets, other.searchMaxBuckets) &&
            java.util.Objects.deepEquals(this.reindexRemoteWhitelist, other.reindexRemoteWhitelist) &&
            java.util.Objects.deepEquals(this.overrideMainResponseVersion, other.overrideMainResponseVersion) &&
            java.util.Objects.deepEquals(this.httpMaxHeaderSize, other.httpMaxHeaderSize) &&
            java.util.Objects.deepEquals(this.emailSender, other.emailSender) &&
            java.util.Objects.deepEquals(this.indicesFielddataCacheSize, other.indicesFielddataCacheSize) &&
            java.util.Objects.deepEquals(this.actionDestructiveRequiresName, other.actionDestructiveRequiresName) &&
            java.util.Objects.deepEquals(this.indicesMemoryIndexBufferSize, other.indicesMemoryIndexBufferSize) &&
            java.util.Objects.deepEquals(this.threadPoolForceMergeSize, other.threadPoolForceMergeSize) &&
            java.util.Objects.deepEquals(this.authFailureListeners, other.authFailureListeners) &&
            java.util.Objects.deepEquals(this.ismHistory, other.ismHistory) &&
            java.util.Objects.deepEquals(this.clusterRoutingAllocationNodeConcurrentRecoveries, other.clusterRoutingAllocationNodeConcurrentRecoveries) &&
            java.util.Objects.deepEquals(this.threadPoolAnalyzeQueueSize, other.threadPoolAnalyzeQueueSize) &&
            java.util.Objects.deepEquals(this.actionAutoCreateIndexEnabled, other.actionAutoCreateIndexEnabled) &&
            java.util.Objects.deepEquals(this.httpMaxContentLength, other.httpMaxContentLength) &&
            java.util.Objects.deepEquals(this.threadPoolWriteSize, other.threadPoolWriteSize) &&
            java.util.Objects.deepEquals(this.threadPoolSearchQueueSize, other.threadPoolSearchQueueSize) &&
            java.util.Objects.deepEquals(this.indicesQueryBoolMaxClauseCount, other.indicesQueryBoolMaxClauseCount) &&
            java.util.Objects.deepEquals(this.threadPoolSearchThrottledQueueSize, other.threadPoolSearchThrottledQueueSize) &&
            java.util.Objects.deepEquals(this.clusterMaxShardsPerNode, other.clusterMaxShardsPerNode);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            threadPoolSearchThrottledSize,
            threadPoolAnalyzeSize,
            threadPoolGetSize,
            threadPoolGetQueueSize,
            indicesRecoveryMaxConcurrentFileChunks,
            indicesQueriesCacheSize,
            threadPoolSearchSize,
            indicesRecoveryMaxBytesPerSec,
            httpMaxInitialLineLength,
            threadPoolWriteQueueSize,
            scriptMaxCompilationsRate,
            searchMaxBuckets,
            reindexRemoteWhitelist,
            overrideMainResponseVersion,
            httpMaxHeaderSize,
            emailSender,
            indicesFielddataCacheSize,
            actionDestructiveRequiresName,
            indicesMemoryIndexBufferSize,
            threadPoolForceMergeSize,
            authFailureListeners,
            ismHistory,
            clusterRoutingAllocationNodeConcurrentRecoveries,
            threadPoolAnalyzeQueueSize,
            actionAutoCreateIndexEnabled,
            httpMaxContentLength,
            threadPoolWriteSize,
            threadPoolSearchQueueSize,
            indicesQueryBoolMaxClauseCount,
            threadPoolSearchThrottledQueueSize,
            clusterMaxShardsPerNode);
    }
    
    @Override
    public String toString() {
        return Utils.toString(JsonSchemaOpensearch.class,
                "threadPoolSearchThrottledSize", threadPoolSearchThrottledSize,
                "threadPoolAnalyzeSize", threadPoolAnalyzeSize,
                "threadPoolGetSize", threadPoolGetSize,
                "threadPoolGetQueueSize", threadPoolGetQueueSize,
                "indicesRecoveryMaxConcurrentFileChunks", indicesRecoveryMaxConcurrentFileChunks,
                "indicesQueriesCacheSize", indicesQueriesCacheSize,
                "threadPoolSearchSize", threadPoolSearchSize,
                "indicesRecoveryMaxBytesPerSec", indicesRecoveryMaxBytesPerSec,
                "httpMaxInitialLineLength", httpMaxInitialLineLength,
                "threadPoolWriteQueueSize", threadPoolWriteQueueSize,
                "scriptMaxCompilationsRate", scriptMaxCompilationsRate,
                "searchMaxBuckets", searchMaxBuckets,
                "reindexRemoteWhitelist", reindexRemoteWhitelist,
                "overrideMainResponseVersion", overrideMainResponseVersion,
                "httpMaxHeaderSize", httpMaxHeaderSize,
                "emailSender", emailSender,
                "indicesFielddataCacheSize", indicesFielddataCacheSize,
                "actionDestructiveRequiresName", actionDestructiveRequiresName,
                "indicesMemoryIndexBufferSize", indicesMemoryIndexBufferSize,
                "threadPoolForceMergeSize", threadPoolForceMergeSize,
                "authFailureListeners", authFailureListeners,
                "ismHistory", ismHistory,
                "clusterRoutingAllocationNodeConcurrentRecoveries", clusterRoutingAllocationNodeConcurrentRecoveries,
                "threadPoolAnalyzeQueueSize", threadPoolAnalyzeQueueSize,
                "actionAutoCreateIndexEnabled", actionAutoCreateIndexEnabled,
                "httpMaxContentLength", httpMaxContentLength,
                "threadPoolWriteSize", threadPoolWriteSize,
                "threadPoolSearchQueueSize", threadPoolSearchQueueSize,
                "indicesQueryBoolMaxClauseCount", indicesQueryBoolMaxClauseCount,
                "threadPoolSearchThrottledQueueSize", threadPoolSearchThrottledQueueSize,
                "clusterMaxShardsPerNode", clusterMaxShardsPerNode);
    }
    
    public final static class Builder {
 
        private Optional<? extends Long> threadPoolSearchThrottledSize = Optional.empty();
 
        private Optional<? extends Long> threadPoolAnalyzeSize = Optional.empty();
 
        private Optional<? extends Long> threadPoolGetSize = Optional.empty();
 
        private Optional<? extends Long> threadPoolGetQueueSize = Optional.empty();
 
        private Optional<? extends Long> indicesRecoveryMaxConcurrentFileChunks = Optional.empty();
 
        private Optional<? extends Long> indicesQueriesCacheSize = Optional.empty();
 
        private Optional<? extends Long> threadPoolSearchSize = Optional.empty();
 
        private Optional<? extends Long> indicesRecoveryMaxBytesPerSec = Optional.empty();
 
        private Optional<? extends Long> httpMaxInitialLineLength = Optional.empty();
 
        private Optional<? extends Long> threadPoolWriteQueueSize = Optional.empty();
 
        private Optional<? extends String> scriptMaxCompilationsRate = Optional.empty();
 
        private JsonNullable<? extends Long> searchMaxBuckets = JsonNullable.undefined();
 
        private JsonNullable<? extends java.util.List<String>> reindexRemoteWhitelist = JsonNullable.undefined();
 
        private Optional<? extends Boolean> overrideMainResponseVersion = Optional.empty();
 
        private Optional<? extends Long> httpMaxHeaderSize = Optional.empty();
 
        private Optional<? extends OpensearchEmailSenderSettings> emailSender = Optional.empty();
 
        private JsonNullable<? extends Long> indicesFielddataCacheSize;
 
        private JsonNullable<? extends Boolean> actionDestructiveRequiresName = JsonNullable.undefined();
 
        private Optional<? extends Long> indicesMemoryIndexBufferSize = Optional.empty();
 
        private Optional<? extends Long> threadPoolForceMergeSize = Optional.empty();
 
        private Optional<? extends OpensearchSecurityPluginSettings> authFailureListeners = Optional.empty();
 
        private Optional<? extends OpensearchISMHistorySettings> ismHistory = Optional.empty();
 
        private Optional<? extends Long> clusterRoutingAllocationNodeConcurrentRecoveries = Optional.empty();
 
        private Optional<? extends Long> threadPoolAnalyzeQueueSize = Optional.empty();
 
        private Optional<? extends Boolean> actionAutoCreateIndexEnabled = Optional.empty();
 
        private Optional<? extends Long> httpMaxContentLength = Optional.empty();
 
        private Optional<? extends Long> threadPoolWriteSize = Optional.empty();
 
        private Optional<? extends Long> threadPoolSearchQueueSize = Optional.empty();
 
        private Optional<? extends Long> indicesQueryBoolMaxClauseCount = Optional.empty();
 
        private Optional<? extends Long> threadPoolSearchThrottledQueueSize = Optional.empty();
 
        private Optional<? extends Long> clusterMaxShardsPerNode = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
         */
        public Builder threadPoolSearchThrottledSize(long threadPoolSearchThrottledSize) {
            Utils.checkNotNull(threadPoolSearchThrottledSize, "threadPoolSearchThrottledSize");
            this.threadPoolSearchThrottledSize = Optional.ofNullable(threadPoolSearchThrottledSize);
            return this;
        }

        /**
         * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
         */
        public Builder threadPoolSearchThrottledSize(Optional<? extends Long> threadPoolSearchThrottledSize) {
            Utils.checkNotNull(threadPoolSearchThrottledSize, "threadPoolSearchThrottledSize");
            this.threadPoolSearchThrottledSize = threadPoolSearchThrottledSize;
            return this;
        }

        /**
         * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
         */
        public Builder threadPoolAnalyzeSize(long threadPoolAnalyzeSize) {
            Utils.checkNotNull(threadPoolAnalyzeSize, "threadPoolAnalyzeSize");
            this.threadPoolAnalyzeSize = Optional.ofNullable(threadPoolAnalyzeSize);
            return this;
        }

        /**
         * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
         */
        public Builder threadPoolAnalyzeSize(Optional<? extends Long> threadPoolAnalyzeSize) {
            Utils.checkNotNull(threadPoolAnalyzeSize, "threadPoolAnalyzeSize");
            this.threadPoolAnalyzeSize = threadPoolAnalyzeSize;
            return this;
        }

        /**
         * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
         */
        public Builder threadPoolGetSize(long threadPoolGetSize) {
            Utils.checkNotNull(threadPoolGetSize, "threadPoolGetSize");
            this.threadPoolGetSize = Optional.ofNullable(threadPoolGetSize);
            return this;
        }

        /**
         * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
         */
        public Builder threadPoolGetSize(Optional<? extends Long> threadPoolGetSize) {
            Utils.checkNotNull(threadPoolGetSize, "threadPoolGetSize");
            this.threadPoolGetSize = threadPoolGetSize;
            return this;
        }

        /**
         * Size for the thread pool queue. See documentation for exact details.
         */
        public Builder threadPoolGetQueueSize(long threadPoolGetQueueSize) {
            Utils.checkNotNull(threadPoolGetQueueSize, "threadPoolGetQueueSize");
            this.threadPoolGetQueueSize = Optional.ofNullable(threadPoolGetQueueSize);
            return this;
        }

        /**
         * Size for the thread pool queue. See documentation for exact details.
         */
        public Builder threadPoolGetQueueSize(Optional<? extends Long> threadPoolGetQueueSize) {
            Utils.checkNotNull(threadPoolGetQueueSize, "threadPoolGetQueueSize");
            this.threadPoolGetQueueSize = threadPoolGetQueueSize;
            return this;
        }

        /**
         * Number of file chunks sent in parallel for each recovery. Defaults to 2.
         */
        public Builder indicesRecoveryMaxConcurrentFileChunks(long indicesRecoveryMaxConcurrentFileChunks) {
            Utils.checkNotNull(indicesRecoveryMaxConcurrentFileChunks, "indicesRecoveryMaxConcurrentFileChunks");
            this.indicesRecoveryMaxConcurrentFileChunks = Optional.ofNullable(indicesRecoveryMaxConcurrentFileChunks);
            return this;
        }

        /**
         * Number of file chunks sent in parallel for each recovery. Defaults to 2.
         */
        public Builder indicesRecoveryMaxConcurrentFileChunks(Optional<? extends Long> indicesRecoveryMaxConcurrentFileChunks) {
            Utils.checkNotNull(indicesRecoveryMaxConcurrentFileChunks, "indicesRecoveryMaxConcurrentFileChunks");
            this.indicesRecoveryMaxConcurrentFileChunks = indicesRecoveryMaxConcurrentFileChunks;
            return this;
        }

        /**
         * Percentage value. Default is 10%. Maximum amount of heap used for query cache. This is an expert setting. Too low value will decrease query performance and increase performance for other operations; too high value will cause issues with other OpenSearch functionality.
         */
        public Builder indicesQueriesCacheSize(long indicesQueriesCacheSize) {
            Utils.checkNotNull(indicesQueriesCacheSize, "indicesQueriesCacheSize");
            this.indicesQueriesCacheSize = Optional.ofNullable(indicesQueriesCacheSize);
            return this;
        }

        /**
         * Percentage value. Default is 10%. Maximum amount of heap used for query cache. This is an expert setting. Too low value will decrease query performance and increase performance for other operations; too high value will cause issues with other OpenSearch functionality.
         */
        public Builder indicesQueriesCacheSize(Optional<? extends Long> indicesQueriesCacheSize) {
            Utils.checkNotNull(indicesQueriesCacheSize, "indicesQueriesCacheSize");
            this.indicesQueriesCacheSize = indicesQueriesCacheSize;
            return this;
        }

        /**
         * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
         */
        public Builder threadPoolSearchSize(long threadPoolSearchSize) {
            Utils.checkNotNull(threadPoolSearchSize, "threadPoolSearchSize");
            this.threadPoolSearchSize = Optional.ofNullable(threadPoolSearchSize);
            return this;
        }

        /**
         * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
         */
        public Builder threadPoolSearchSize(Optional<? extends Long> threadPoolSearchSize) {
            Utils.checkNotNull(threadPoolSearchSize, "threadPoolSearchSize");
            this.threadPoolSearchSize = threadPoolSearchSize;
            return this;
        }

        /**
         * Limits total inbound and outbound recovery traffic for each node. Applies to both peer recoveries as well as snapshot recoveries (i.e., restores from a snapshot). Defaults to 40mb
         */
        public Builder indicesRecoveryMaxBytesPerSec(long indicesRecoveryMaxBytesPerSec) {
            Utils.checkNotNull(indicesRecoveryMaxBytesPerSec, "indicesRecoveryMaxBytesPerSec");
            this.indicesRecoveryMaxBytesPerSec = Optional.ofNullable(indicesRecoveryMaxBytesPerSec);
            return this;
        }

        /**
         * Limits total inbound and outbound recovery traffic for each node. Applies to both peer recoveries as well as snapshot recoveries (i.e., restores from a snapshot). Defaults to 40mb
         */
        public Builder indicesRecoveryMaxBytesPerSec(Optional<? extends Long> indicesRecoveryMaxBytesPerSec) {
            Utils.checkNotNull(indicesRecoveryMaxBytesPerSec, "indicesRecoveryMaxBytesPerSec");
            this.indicesRecoveryMaxBytesPerSec = indicesRecoveryMaxBytesPerSec;
            return this;
        }

        /**
         * The max length of an HTTP URL, in bytes
         */
        public Builder httpMaxInitialLineLength(long httpMaxInitialLineLength) {
            Utils.checkNotNull(httpMaxInitialLineLength, "httpMaxInitialLineLength");
            this.httpMaxInitialLineLength = Optional.ofNullable(httpMaxInitialLineLength);
            return this;
        }

        /**
         * The max length of an HTTP URL, in bytes
         */
        public Builder httpMaxInitialLineLength(Optional<? extends Long> httpMaxInitialLineLength) {
            Utils.checkNotNull(httpMaxInitialLineLength, "httpMaxInitialLineLength");
            this.httpMaxInitialLineLength = httpMaxInitialLineLength;
            return this;
        }

        /**
         * Size for the thread pool queue. See documentation for exact details.
         */
        public Builder threadPoolWriteQueueSize(long threadPoolWriteQueueSize) {
            Utils.checkNotNull(threadPoolWriteQueueSize, "threadPoolWriteQueueSize");
            this.threadPoolWriteQueueSize = Optional.ofNullable(threadPoolWriteQueueSize);
            return this;
        }

        /**
         * Size for the thread pool queue. See documentation for exact details.
         */
        public Builder threadPoolWriteQueueSize(Optional<? extends Long> threadPoolWriteQueueSize) {
            Utils.checkNotNull(threadPoolWriteQueueSize, "threadPoolWriteQueueSize");
            this.threadPoolWriteQueueSize = threadPoolWriteQueueSize;
            return this;
        }

        /**
         * Script compilation circuit breaker limits the number of inline script compilations within a period of time. Default is use-context
         */
        public Builder scriptMaxCompilationsRate(String scriptMaxCompilationsRate) {
            Utils.checkNotNull(scriptMaxCompilationsRate, "scriptMaxCompilationsRate");
            this.scriptMaxCompilationsRate = Optional.ofNullable(scriptMaxCompilationsRate);
            return this;
        }

        /**
         * Script compilation circuit breaker limits the number of inline script compilations within a period of time. Default is use-context
         */
        public Builder scriptMaxCompilationsRate(Optional<? extends String> scriptMaxCompilationsRate) {
            Utils.checkNotNull(scriptMaxCompilationsRate, "scriptMaxCompilationsRate");
            this.scriptMaxCompilationsRate = scriptMaxCompilationsRate;
            return this;
        }

        /**
         * Maximum number of aggregation buckets allowed in a single response. OpenSearch default value is used when this is not defined.
         */
        public Builder searchMaxBuckets(long searchMaxBuckets) {
            Utils.checkNotNull(searchMaxBuckets, "searchMaxBuckets");
            this.searchMaxBuckets = JsonNullable.of(searchMaxBuckets);
            return this;
        }

        /**
         * Maximum number of aggregation buckets allowed in a single response. OpenSearch default value is used when this is not defined.
         */
        public Builder searchMaxBuckets(JsonNullable<? extends Long> searchMaxBuckets) {
            Utils.checkNotNull(searchMaxBuckets, "searchMaxBuckets");
            this.searchMaxBuckets = searchMaxBuckets;
            return this;
        }

        /**
         * Whitelisted addresses for reindexing. Changing this value will cause all OpenSearch instances to restart.
         */
        public Builder reindexRemoteWhitelist(java.util.List<String> reindexRemoteWhitelist) {
            Utils.checkNotNull(reindexRemoteWhitelist, "reindexRemoteWhitelist");
            this.reindexRemoteWhitelist = JsonNullable.of(reindexRemoteWhitelist);
            return this;
        }

        /**
         * Whitelisted addresses for reindexing. Changing this value will cause all OpenSearch instances to restart.
         */
        public Builder reindexRemoteWhitelist(JsonNullable<? extends java.util.List<String>> reindexRemoteWhitelist) {
            Utils.checkNotNull(reindexRemoteWhitelist, "reindexRemoteWhitelist");
            this.reindexRemoteWhitelist = reindexRemoteWhitelist;
            return this;
        }

        /**
         * Compatibility mode sets OpenSearch to report its version as 7.10 so clients continue to work. Default is false
         */
        public Builder overrideMainResponseVersion(boolean overrideMainResponseVersion) {
            Utils.checkNotNull(overrideMainResponseVersion, "overrideMainResponseVersion");
            this.overrideMainResponseVersion = Optional.ofNullable(overrideMainResponseVersion);
            return this;
        }

        /**
         * Compatibility mode sets OpenSearch to report its version as 7.10 so clients continue to work. Default is false
         */
        public Builder overrideMainResponseVersion(Optional<? extends Boolean> overrideMainResponseVersion) {
            Utils.checkNotNull(overrideMainResponseVersion, "overrideMainResponseVersion");
            this.overrideMainResponseVersion = overrideMainResponseVersion;
            return this;
        }

        /**
         * The max size of allowed headers, in bytes
         */
        public Builder httpMaxHeaderSize(long httpMaxHeaderSize) {
            Utils.checkNotNull(httpMaxHeaderSize, "httpMaxHeaderSize");
            this.httpMaxHeaderSize = Optional.ofNullable(httpMaxHeaderSize);
            return this;
        }

        /**
         * The max size of allowed headers, in bytes
         */
        public Builder httpMaxHeaderSize(Optional<? extends Long> httpMaxHeaderSize) {
            Utils.checkNotNull(httpMaxHeaderSize, "httpMaxHeaderSize");
            this.httpMaxHeaderSize = httpMaxHeaderSize;
            return this;
        }

        public Builder emailSender(OpensearchEmailSenderSettings emailSender) {
            Utils.checkNotNull(emailSender, "emailSender");
            this.emailSender = Optional.ofNullable(emailSender);
            return this;
        }

        public Builder emailSender(Optional<? extends OpensearchEmailSenderSettings> emailSender) {
            Utils.checkNotNull(emailSender, "emailSender");
            this.emailSender = emailSender;
            return this;
        }

        /**
         * Relative amount. Maximum amount of heap memory used for field data cache. This is an expert setting; decreasing the value too much will increase overhead of loading field data; too much memory used for field data cache will decrease amount of heap available for other operations.
         */
        public Builder indicesFielddataCacheSize(long indicesFielddataCacheSize) {
            Utils.checkNotNull(indicesFielddataCacheSize, "indicesFielddataCacheSize");
            this.indicesFielddataCacheSize = JsonNullable.of(indicesFielddataCacheSize);
            return this;
        }

        /**
         * Relative amount. Maximum amount of heap memory used for field data cache. This is an expert setting; decreasing the value too much will increase overhead of loading field data; too much memory used for field data cache will decrease amount of heap available for other operations.
         */
        public Builder indicesFielddataCacheSize(JsonNullable<? extends Long> indicesFielddataCacheSize) {
            Utils.checkNotNull(indicesFielddataCacheSize, "indicesFielddataCacheSize");
            this.indicesFielddataCacheSize = indicesFielddataCacheSize;
            return this;
        }

        public Builder actionDestructiveRequiresName(boolean actionDestructiveRequiresName) {
            Utils.checkNotNull(actionDestructiveRequiresName, "actionDestructiveRequiresName");
            this.actionDestructiveRequiresName = JsonNullable.of(actionDestructiveRequiresName);
            return this;
        }

        public Builder actionDestructiveRequiresName(JsonNullable<? extends Boolean> actionDestructiveRequiresName) {
            Utils.checkNotNull(actionDestructiveRequiresName, "actionDestructiveRequiresName");
            this.actionDestructiveRequiresName = actionDestructiveRequiresName;
            return this;
        }

        /**
         * Percentage value. Default is 10%. Total amount of heap used for indexing buffer, before writing segments to disk. This is an expert setting. Too low value will slow down indexing; too high value will increase indexing performance but causes performance issues for query performance.
         */
        public Builder indicesMemoryIndexBufferSize(long indicesMemoryIndexBufferSize) {
            Utils.checkNotNull(indicesMemoryIndexBufferSize, "indicesMemoryIndexBufferSize");
            this.indicesMemoryIndexBufferSize = Optional.ofNullable(indicesMemoryIndexBufferSize);
            return this;
        }

        /**
         * Percentage value. Default is 10%. Total amount of heap used for indexing buffer, before writing segments to disk. This is an expert setting. Too low value will slow down indexing; too high value will increase indexing performance but causes performance issues for query performance.
         */
        public Builder indicesMemoryIndexBufferSize(Optional<? extends Long> indicesMemoryIndexBufferSize) {
            Utils.checkNotNull(indicesMemoryIndexBufferSize, "indicesMemoryIndexBufferSize");
            this.indicesMemoryIndexBufferSize = indicesMemoryIndexBufferSize;
            return this;
        }

        /**
         * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
         */
        public Builder threadPoolForceMergeSize(long threadPoolForceMergeSize) {
            Utils.checkNotNull(threadPoolForceMergeSize, "threadPoolForceMergeSize");
            this.threadPoolForceMergeSize = Optional.ofNullable(threadPoolForceMergeSize);
            return this;
        }

        /**
         * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
         */
        public Builder threadPoolForceMergeSize(Optional<? extends Long> threadPoolForceMergeSize) {
            Utils.checkNotNull(threadPoolForceMergeSize, "threadPoolForceMergeSize");
            this.threadPoolForceMergeSize = threadPoolForceMergeSize;
            return this;
        }

        public Builder authFailureListeners(OpensearchSecurityPluginSettings authFailureListeners) {
            Utils.checkNotNull(authFailureListeners, "authFailureListeners");
            this.authFailureListeners = Optional.ofNullable(authFailureListeners);
            return this;
        }

        public Builder authFailureListeners(Optional<? extends OpensearchSecurityPluginSettings> authFailureListeners) {
            Utils.checkNotNull(authFailureListeners, "authFailureListeners");
            this.authFailureListeners = authFailureListeners;
            return this;
        }

        public Builder ismHistory(OpensearchISMHistorySettings ismHistory) {
            Utils.checkNotNull(ismHistory, "ismHistory");
            this.ismHistory = Optional.ofNullable(ismHistory);
            return this;
        }

        public Builder ismHistory(Optional<? extends OpensearchISMHistorySettings> ismHistory) {
            Utils.checkNotNull(ismHistory, "ismHistory");
            this.ismHistory = ismHistory;
            return this;
        }

        /**
         * How many concurrent incoming/outgoing shard recoveries (normally replicas) are allowed to happen on a node. Defaults to 2.
         */
        public Builder clusterRoutingAllocationNodeConcurrentRecoveries(long clusterRoutingAllocationNodeConcurrentRecoveries) {
            Utils.checkNotNull(clusterRoutingAllocationNodeConcurrentRecoveries, "clusterRoutingAllocationNodeConcurrentRecoveries");
            this.clusterRoutingAllocationNodeConcurrentRecoveries = Optional.ofNullable(clusterRoutingAllocationNodeConcurrentRecoveries);
            return this;
        }

        /**
         * How many concurrent incoming/outgoing shard recoveries (normally replicas) are allowed to happen on a node. Defaults to 2.
         */
        public Builder clusterRoutingAllocationNodeConcurrentRecoveries(Optional<? extends Long> clusterRoutingAllocationNodeConcurrentRecoveries) {
            Utils.checkNotNull(clusterRoutingAllocationNodeConcurrentRecoveries, "clusterRoutingAllocationNodeConcurrentRecoveries");
            this.clusterRoutingAllocationNodeConcurrentRecoveries = clusterRoutingAllocationNodeConcurrentRecoveries;
            return this;
        }

        /**
         * Size for the thread pool queue. See documentation for exact details.
         */
        public Builder threadPoolAnalyzeQueueSize(long threadPoolAnalyzeQueueSize) {
            Utils.checkNotNull(threadPoolAnalyzeQueueSize, "threadPoolAnalyzeQueueSize");
            this.threadPoolAnalyzeQueueSize = Optional.ofNullable(threadPoolAnalyzeQueueSize);
            return this;
        }

        /**
         * Size for the thread pool queue. See documentation for exact details.
         */
        public Builder threadPoolAnalyzeQueueSize(Optional<? extends Long> threadPoolAnalyzeQueueSize) {
            Utils.checkNotNull(threadPoolAnalyzeQueueSize, "threadPoolAnalyzeQueueSize");
            this.threadPoolAnalyzeQueueSize = threadPoolAnalyzeQueueSize;
            return this;
        }

        /**
         * Explicitly allow or block automatic creation of indices. Defaults to true
         */
        public Builder actionAutoCreateIndexEnabled(boolean actionAutoCreateIndexEnabled) {
            Utils.checkNotNull(actionAutoCreateIndexEnabled, "actionAutoCreateIndexEnabled");
            this.actionAutoCreateIndexEnabled = Optional.ofNullable(actionAutoCreateIndexEnabled);
            return this;
        }

        /**
         * Explicitly allow or block automatic creation of indices. Defaults to true
         */
        public Builder actionAutoCreateIndexEnabled(Optional<? extends Boolean> actionAutoCreateIndexEnabled) {
            Utils.checkNotNull(actionAutoCreateIndexEnabled, "actionAutoCreateIndexEnabled");
            this.actionAutoCreateIndexEnabled = actionAutoCreateIndexEnabled;
            return this;
        }

        /**
         * Maximum content length for HTTP requests to the OpenSearch HTTP API, in bytes.
         */
        public Builder httpMaxContentLength(long httpMaxContentLength) {
            Utils.checkNotNull(httpMaxContentLength, "httpMaxContentLength");
            this.httpMaxContentLength = Optional.ofNullable(httpMaxContentLength);
            return this;
        }

        /**
         * Maximum content length for HTTP requests to the OpenSearch HTTP API, in bytes.
         */
        public Builder httpMaxContentLength(Optional<? extends Long> httpMaxContentLength) {
            Utils.checkNotNull(httpMaxContentLength, "httpMaxContentLength");
            this.httpMaxContentLength = httpMaxContentLength;
            return this;
        }

        /**
         * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
         */
        public Builder threadPoolWriteSize(long threadPoolWriteSize) {
            Utils.checkNotNull(threadPoolWriteSize, "threadPoolWriteSize");
            this.threadPoolWriteSize = Optional.ofNullable(threadPoolWriteSize);
            return this;
        }

        /**
         * Size for the thread pool. See documentation for exact details. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.
         */
        public Builder threadPoolWriteSize(Optional<? extends Long> threadPoolWriteSize) {
            Utils.checkNotNull(threadPoolWriteSize, "threadPoolWriteSize");
            this.threadPoolWriteSize = threadPoolWriteSize;
            return this;
        }

        /**
         * Size for the thread pool queue. See documentation for exact details.
         */
        public Builder threadPoolSearchQueueSize(long threadPoolSearchQueueSize) {
            Utils.checkNotNull(threadPoolSearchQueueSize, "threadPoolSearchQueueSize");
            this.threadPoolSearchQueueSize = Optional.ofNullable(threadPoolSearchQueueSize);
            return this;
        }

        /**
         * Size for the thread pool queue. See documentation for exact details.
         */
        public Builder threadPoolSearchQueueSize(Optional<? extends Long> threadPoolSearchQueueSize) {
            Utils.checkNotNull(threadPoolSearchQueueSize, "threadPoolSearchQueueSize");
            this.threadPoolSearchQueueSize = threadPoolSearchQueueSize;
            return this;
        }

        /**
         * Maximum number of clauses Lucene BooleanQuery can have. The default value (1024) is relatively high, and increasing it may cause performance issues. Investigate other approaches first before increasing this value.
         */
        public Builder indicesQueryBoolMaxClauseCount(long indicesQueryBoolMaxClauseCount) {
            Utils.checkNotNull(indicesQueryBoolMaxClauseCount, "indicesQueryBoolMaxClauseCount");
            this.indicesQueryBoolMaxClauseCount = Optional.ofNullable(indicesQueryBoolMaxClauseCount);
            return this;
        }

        /**
         * Maximum number of clauses Lucene BooleanQuery can have. The default value (1024) is relatively high, and increasing it may cause performance issues. Investigate other approaches first before increasing this value.
         */
        public Builder indicesQueryBoolMaxClauseCount(Optional<? extends Long> indicesQueryBoolMaxClauseCount) {
            Utils.checkNotNull(indicesQueryBoolMaxClauseCount, "indicesQueryBoolMaxClauseCount");
            this.indicesQueryBoolMaxClauseCount = indicesQueryBoolMaxClauseCount;
            return this;
        }

        /**
         * Size for the thread pool queue. See documentation for exact details.
         */
        public Builder threadPoolSearchThrottledQueueSize(long threadPoolSearchThrottledQueueSize) {
            Utils.checkNotNull(threadPoolSearchThrottledQueueSize, "threadPoolSearchThrottledQueueSize");
            this.threadPoolSearchThrottledQueueSize = Optional.ofNullable(threadPoolSearchThrottledQueueSize);
            return this;
        }

        /**
         * Size for the thread pool queue. See documentation for exact details.
         */
        public Builder threadPoolSearchThrottledQueueSize(Optional<? extends Long> threadPoolSearchThrottledQueueSize) {
            Utils.checkNotNull(threadPoolSearchThrottledQueueSize, "threadPoolSearchThrottledQueueSize");
            this.threadPoolSearchThrottledQueueSize = threadPoolSearchThrottledQueueSize;
            return this;
        }

        /**
         * Controls the number of shards allowed in the cluster per data node
         */
        public Builder clusterMaxShardsPerNode(long clusterMaxShardsPerNode) {
            Utils.checkNotNull(clusterMaxShardsPerNode, "clusterMaxShardsPerNode");
            this.clusterMaxShardsPerNode = Optional.ofNullable(clusterMaxShardsPerNode);
            return this;
        }

        /**
         * Controls the number of shards allowed in the cluster per data node
         */
        public Builder clusterMaxShardsPerNode(Optional<? extends Long> clusterMaxShardsPerNode) {
            Utils.checkNotNull(clusterMaxShardsPerNode, "clusterMaxShardsPerNode");
            this.clusterMaxShardsPerNode = clusterMaxShardsPerNode;
            return this;
        }
        
        public JsonSchemaOpensearch build() {
            if (indicesFielddataCacheSize == null) {
                indicesFielddataCacheSize = _SINGLETON_VALUE_IndicesFielddataCacheSize.value();
            }
            return new JsonSchemaOpensearch(
                threadPoolSearchThrottledSize,
                threadPoolAnalyzeSize,
                threadPoolGetSize,
                threadPoolGetQueueSize,
                indicesRecoveryMaxConcurrentFileChunks,
                indicesQueriesCacheSize,
                threadPoolSearchSize,
                indicesRecoveryMaxBytesPerSec,
                httpMaxInitialLineLength,
                threadPoolWriteQueueSize,
                scriptMaxCompilationsRate,
                searchMaxBuckets,
                reindexRemoteWhitelist,
                overrideMainResponseVersion,
                httpMaxHeaderSize,
                emailSender,
                indicesFielddataCacheSize,
                actionDestructiveRequiresName,
                indicesMemoryIndexBufferSize,
                threadPoolForceMergeSize,
                authFailureListeners,
                ismHistory,
                clusterRoutingAllocationNodeConcurrentRecoveries,
                threadPoolAnalyzeQueueSize,
                actionAutoCreateIndexEnabled,
                httpMaxContentLength,
                threadPoolWriteSize,
                threadPoolSearchQueueSize,
                indicesQueryBoolMaxClauseCount,
                threadPoolSearchThrottledQueueSize,
                clusterMaxShardsPerNode);
        }

        private static final LazySingletonValue<JsonNullable<? extends Long>> _SINGLETON_VALUE_IndicesFielddataCacheSize =
                new LazySingletonValue<>(
                        "indices_fielddata_cache_size",
                        "null",
                        new TypeReference<JsonNullable<? extends Long>>() {});
    }
}

