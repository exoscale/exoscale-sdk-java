/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.exoscale.api.models.components;

import com.exoscale.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.OffsetDateTime;
import java.util.Optional;


public class DbaasServiceOpensearch {

    /**
     * DbaaS service description
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("description")
    private Optional<? extends String> description;

    /**
     * Maximum number of indexes to keep before deleting the oldest one
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max-index-count")
    private Optional<? extends Long> maxIndexCount;

    /**
     * Service last update timestamp (ISO 8601)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated-at")
    private Optional<? extends OffsetDateTime> updatedAt;

    /**
     * Number of service nodes in the active plan
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("node-count")
    private Optional<? extends Long> nodeCount;

    /**
     * Opensearch connection information properties
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("connection-info")
    private Optional<? extends DbaasServiceOpensearchConnectionInfo> connectionInfo;

    /**
     * Number of CPUs for each node
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("node-cpu-count")
    private Optional<? extends Long> nodeCpuCount;

    /**
     * Service integrations
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("integrations")
    private Optional<? extends java.util.List<DbaasIntegration>> integrations;

    /**
     * The zone where the service is running
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("zone")
    private Optional<? extends String> zone;

    /**
     * State of individual service nodes
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("node-states")
    private Optional<? extends java.util.List<DbaasNodeState>> nodeStates;

    @JsonProperty("name")
    private String name;

    /**
     * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("keep-index-refresh-interval")
    private Optional<? extends Boolean> keepIndexRefreshInterval;

    @JsonProperty("type")
    private String type;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("state")
    private Optional<? extends EnumServiceState> state;

    /**
     * Allowed CIDR address blocks for incoming connections
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ip-filter")
    private Optional<? extends java.util.List<String>> ipFilter;

    /**
     * List of backups for the service
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("backups")
    private Optional<? extends java.util.List<DbaasServiceBackup>> backups;

    /**
     * Service is protected against termination and powering off
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("termination-protection")
    private Optional<? extends Boolean> terminationProtection;

    /**
     * Service notifications
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("notifications")
    private Optional<? extends java.util.List<DbaasServiceNotification>> notifications;

    /**
     * Service component information objects
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("components")
    private Optional<? extends java.util.List<DbaasServiceOpensearchComponents>> components;

    /**
     * Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("index-patterns")
    private Optional<? extends java.util.List<IndexPatterns>> indexPatterns;

    /**
     * Automatic maintenance settings
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maintenance")
    private Optional<? extends DbaasServiceMaintenance> maintenance;

    /**
     * Template settings for all new indexes
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("index-template")
    private Optional<? extends IndexTemplate> indexTemplate;

    /**
     * TODO UNIT disk space for data storage
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("disk-size")
    private Optional<? extends Long> diskSize;

    /**
     * TODO UNIT of memory for each node
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("node-memory")
    private Optional<? extends Long> nodeMemory;

    /**
     * URI for connecting to the service (may be absent)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("uri")
    private Optional<? extends String> uri;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("opensearch-settings")
    private Optional<? extends JsonSchemaOpensearch> opensearchSettings;

    /**
     * service_uri parameterized into key-value pairs
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("uri-params")
    private Optional<? extends DbaasServiceOpensearchUriParams> uriParams;

    /**
     * OpenSearch version
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("version")
    private Optional<? extends String> version;

    /**
     * Service creation timestamp (ISO 8601)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created-at")
    private Optional<? extends OffsetDateTime> createdAt;

    /**
     * Subscription plan
     */
    @JsonProperty("plan")
    private String plan;

    /**
     * OpenSearch Dashboards settings
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("opensearch-dashboards")
    private Optional<? extends OpensearchDashboards> opensearchDashboards;

    /**
     * List of service users
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("users")
    private Optional<? extends java.util.List<DbaasServiceOpensearchUsers>> users;

    public DbaasServiceOpensearch(
            @JsonProperty("description") Optional<? extends String> description,
            @JsonProperty("max-index-count") Optional<? extends Long> maxIndexCount,
            @JsonProperty("updated-at") Optional<? extends OffsetDateTime> updatedAt,
            @JsonProperty("node-count") Optional<? extends Long> nodeCount,
            @JsonProperty("connection-info") Optional<? extends DbaasServiceOpensearchConnectionInfo> connectionInfo,
            @JsonProperty("node-cpu-count") Optional<? extends Long> nodeCpuCount,
            @JsonProperty("integrations") Optional<? extends java.util.List<DbaasIntegration>> integrations,
            @JsonProperty("zone") Optional<? extends String> zone,
            @JsonProperty("node-states") Optional<? extends java.util.List<DbaasNodeState>> nodeStates,
            @JsonProperty("name") String name,
            @JsonProperty("keep-index-refresh-interval") Optional<? extends Boolean> keepIndexRefreshInterval,
            @JsonProperty("type") String type,
            @JsonProperty("state") Optional<? extends EnumServiceState> state,
            @JsonProperty("ip-filter") Optional<? extends java.util.List<String>> ipFilter,
            @JsonProperty("backups") Optional<? extends java.util.List<DbaasServiceBackup>> backups,
            @JsonProperty("termination-protection") Optional<? extends Boolean> terminationProtection,
            @JsonProperty("notifications") Optional<? extends java.util.List<DbaasServiceNotification>> notifications,
            @JsonProperty("components") Optional<? extends java.util.List<DbaasServiceOpensearchComponents>> components,
            @JsonProperty("index-patterns") Optional<? extends java.util.List<IndexPatterns>> indexPatterns,
            @JsonProperty("maintenance") Optional<? extends DbaasServiceMaintenance> maintenance,
            @JsonProperty("index-template") Optional<? extends IndexTemplate> indexTemplate,
            @JsonProperty("disk-size") Optional<? extends Long> diskSize,
            @JsonProperty("node-memory") Optional<? extends Long> nodeMemory,
            @JsonProperty("uri") Optional<? extends String> uri,
            @JsonProperty("opensearch-settings") Optional<? extends JsonSchemaOpensearch> opensearchSettings,
            @JsonProperty("uri-params") Optional<? extends DbaasServiceOpensearchUriParams> uriParams,
            @JsonProperty("version") Optional<? extends String> version,
            @JsonProperty("created-at") Optional<? extends OffsetDateTime> createdAt,
            @JsonProperty("plan") String plan,
            @JsonProperty("opensearch-dashboards") Optional<? extends OpensearchDashboards> opensearchDashboards,
            @JsonProperty("users") Optional<? extends java.util.List<DbaasServiceOpensearchUsers>> users) {
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(maxIndexCount, "maxIndexCount");
        Utils.checkNotNull(updatedAt, "updatedAt");
        Utils.checkNotNull(nodeCount, "nodeCount");
        Utils.checkNotNull(connectionInfo, "connectionInfo");
        Utils.checkNotNull(nodeCpuCount, "nodeCpuCount");
        Utils.checkNotNull(integrations, "integrations");
        Utils.checkNotNull(zone, "zone");
        Utils.checkNotNull(nodeStates, "nodeStates");
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(keepIndexRefreshInterval, "keepIndexRefreshInterval");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(state, "state");
        Utils.checkNotNull(ipFilter, "ipFilter");
        Utils.checkNotNull(backups, "backups");
        Utils.checkNotNull(terminationProtection, "terminationProtection");
        Utils.checkNotNull(notifications, "notifications");
        Utils.checkNotNull(components, "components");
        Utils.checkNotNull(indexPatterns, "indexPatterns");
        Utils.checkNotNull(maintenance, "maintenance");
        Utils.checkNotNull(indexTemplate, "indexTemplate");
        Utils.checkNotNull(diskSize, "diskSize");
        Utils.checkNotNull(nodeMemory, "nodeMemory");
        Utils.checkNotNull(uri, "uri");
        Utils.checkNotNull(opensearchSettings, "opensearchSettings");
        Utils.checkNotNull(uriParams, "uriParams");
        Utils.checkNotNull(version, "version");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(plan, "plan");
        Utils.checkNotNull(opensearchDashboards, "opensearchDashboards");
        Utils.checkNotNull(users, "users");
        this.description = description;
        this.maxIndexCount = maxIndexCount;
        this.updatedAt = updatedAt;
        this.nodeCount = nodeCount;
        this.connectionInfo = connectionInfo;
        this.nodeCpuCount = nodeCpuCount;
        this.integrations = integrations;
        this.zone = zone;
        this.nodeStates = nodeStates;
        this.name = name;
        this.keepIndexRefreshInterval = keepIndexRefreshInterval;
        this.type = type;
        this.state = state;
        this.ipFilter = ipFilter;
        this.backups = backups;
        this.terminationProtection = terminationProtection;
        this.notifications = notifications;
        this.components = components;
        this.indexPatterns = indexPatterns;
        this.maintenance = maintenance;
        this.indexTemplate = indexTemplate;
        this.diskSize = diskSize;
        this.nodeMemory = nodeMemory;
        this.uri = uri;
        this.opensearchSettings = opensearchSettings;
        this.uriParams = uriParams;
        this.version = version;
        this.createdAt = createdAt;
        this.plan = plan;
        this.opensearchDashboards = opensearchDashboards;
        this.users = users;
    }

    /**
     * DbaaS service description
     */
    public Optional<? extends String> description() {
        return description;
    }

    /**
     * Maximum number of indexes to keep before deleting the oldest one
     */
    public Optional<? extends Long> maxIndexCount() {
        return maxIndexCount;
    }

    /**
     * Service last update timestamp (ISO 8601)
     */
    public Optional<? extends OffsetDateTime> updatedAt() {
        return updatedAt;
    }

    /**
     * Number of service nodes in the active plan
     */
    public Optional<? extends Long> nodeCount() {
        return nodeCount;
    }

    /**
     * Opensearch connection information properties
     */
    public Optional<? extends DbaasServiceOpensearchConnectionInfo> connectionInfo() {
        return connectionInfo;
    }

    /**
     * Number of CPUs for each node
     */
    public Optional<? extends Long> nodeCpuCount() {
        return nodeCpuCount;
    }

    /**
     * Service integrations
     */
    public Optional<? extends java.util.List<DbaasIntegration>> integrations() {
        return integrations;
    }

    /**
     * The zone where the service is running
     */
    public Optional<? extends String> zone() {
        return zone;
    }

    /**
     * State of individual service nodes
     */
    public Optional<? extends java.util.List<DbaasNodeState>> nodeStates() {
        return nodeStates;
    }

    public String name() {
        return name;
    }

    /**
     * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
     */
    public Optional<? extends Boolean> keepIndexRefreshInterval() {
        return keepIndexRefreshInterval;
    }

    public String type() {
        return type;
    }

    public Optional<? extends EnumServiceState> state() {
        return state;
    }

    /**
     * Allowed CIDR address blocks for incoming connections
     */
    public Optional<? extends java.util.List<String>> ipFilter() {
        return ipFilter;
    }

    /**
     * List of backups for the service
     */
    public Optional<? extends java.util.List<DbaasServiceBackup>> backups() {
        return backups;
    }

    /**
     * Service is protected against termination and powering off
     */
    public Optional<? extends Boolean> terminationProtection() {
        return terminationProtection;
    }

    /**
     * Service notifications
     */
    public Optional<? extends java.util.List<DbaasServiceNotification>> notifications() {
        return notifications;
    }

    /**
     * Service component information objects
     */
    public Optional<? extends java.util.List<DbaasServiceOpensearchComponents>> components() {
        return components;
    }

    /**
     * Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
     */
    public Optional<? extends java.util.List<IndexPatterns>> indexPatterns() {
        return indexPatterns;
    }

    /**
     * Automatic maintenance settings
     */
    public Optional<? extends DbaasServiceMaintenance> maintenance() {
        return maintenance;
    }

    /**
     * Template settings for all new indexes
     */
    public Optional<? extends IndexTemplate> indexTemplate() {
        return indexTemplate;
    }

    /**
     * TODO UNIT disk space for data storage
     */
    public Optional<? extends Long> diskSize() {
        return diskSize;
    }

    /**
     * TODO UNIT of memory for each node
     */
    public Optional<? extends Long> nodeMemory() {
        return nodeMemory;
    }

    /**
     * URI for connecting to the service (may be absent)
     */
    public Optional<? extends String> uri() {
        return uri;
    }

    public Optional<? extends JsonSchemaOpensearch> opensearchSettings() {
        return opensearchSettings;
    }

    /**
     * service_uri parameterized into key-value pairs
     */
    public Optional<? extends DbaasServiceOpensearchUriParams> uriParams() {
        return uriParams;
    }

    /**
     * OpenSearch version
     */
    public Optional<? extends String> version() {
        return version;
    }

    /**
     * Service creation timestamp (ISO 8601)
     */
    public Optional<? extends OffsetDateTime> createdAt() {
        return createdAt;
    }

    /**
     * Subscription plan
     */
    public String plan() {
        return plan;
    }

    /**
     * OpenSearch Dashboards settings
     */
    public Optional<? extends OpensearchDashboards> opensearchDashboards() {
        return opensearchDashboards;
    }

    /**
     * List of service users
     */
    public Optional<? extends java.util.List<DbaasServiceOpensearchUsers>> users() {
        return users;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * DbaaS service description
     */
    public DbaasServiceOpensearch withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = Optional.ofNullable(description);
        return this;
    }

    /**
     * DbaaS service description
     */
    public DbaasServiceOpensearch withDescription(Optional<? extends String> description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * Maximum number of indexes to keep before deleting the oldest one
     */
    public DbaasServiceOpensearch withMaxIndexCount(long maxIndexCount) {
        Utils.checkNotNull(maxIndexCount, "maxIndexCount");
        this.maxIndexCount = Optional.ofNullable(maxIndexCount);
        return this;
    }

    /**
     * Maximum number of indexes to keep before deleting the oldest one
     */
    public DbaasServiceOpensearch withMaxIndexCount(Optional<? extends Long> maxIndexCount) {
        Utils.checkNotNull(maxIndexCount, "maxIndexCount");
        this.maxIndexCount = maxIndexCount;
        return this;
    }

    /**
     * Service last update timestamp (ISO 8601)
     */
    public DbaasServiceOpensearch withUpdatedAt(OffsetDateTime updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = Optional.ofNullable(updatedAt);
        return this;
    }

    /**
     * Service last update timestamp (ISO 8601)
     */
    public DbaasServiceOpensearch withUpdatedAt(Optional<? extends OffsetDateTime> updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = updatedAt;
        return this;
    }

    /**
     * Number of service nodes in the active plan
     */
    public DbaasServiceOpensearch withNodeCount(long nodeCount) {
        Utils.checkNotNull(nodeCount, "nodeCount");
        this.nodeCount = Optional.ofNullable(nodeCount);
        return this;
    }

    /**
     * Number of service nodes in the active plan
     */
    public DbaasServiceOpensearch withNodeCount(Optional<? extends Long> nodeCount) {
        Utils.checkNotNull(nodeCount, "nodeCount");
        this.nodeCount = nodeCount;
        return this;
    }

    /**
     * Opensearch connection information properties
     */
    public DbaasServiceOpensearch withConnectionInfo(DbaasServiceOpensearchConnectionInfo connectionInfo) {
        Utils.checkNotNull(connectionInfo, "connectionInfo");
        this.connectionInfo = Optional.ofNullable(connectionInfo);
        return this;
    }

    /**
     * Opensearch connection information properties
     */
    public DbaasServiceOpensearch withConnectionInfo(Optional<? extends DbaasServiceOpensearchConnectionInfo> connectionInfo) {
        Utils.checkNotNull(connectionInfo, "connectionInfo");
        this.connectionInfo = connectionInfo;
        return this;
    }

    /**
     * Number of CPUs for each node
     */
    public DbaasServiceOpensearch withNodeCpuCount(long nodeCpuCount) {
        Utils.checkNotNull(nodeCpuCount, "nodeCpuCount");
        this.nodeCpuCount = Optional.ofNullable(nodeCpuCount);
        return this;
    }

    /**
     * Number of CPUs for each node
     */
    public DbaasServiceOpensearch withNodeCpuCount(Optional<? extends Long> nodeCpuCount) {
        Utils.checkNotNull(nodeCpuCount, "nodeCpuCount");
        this.nodeCpuCount = nodeCpuCount;
        return this;
    }

    /**
     * Service integrations
     */
    public DbaasServiceOpensearch withIntegrations(java.util.List<DbaasIntegration> integrations) {
        Utils.checkNotNull(integrations, "integrations");
        this.integrations = Optional.ofNullable(integrations);
        return this;
    }

    /**
     * Service integrations
     */
    public DbaasServiceOpensearch withIntegrations(Optional<? extends java.util.List<DbaasIntegration>> integrations) {
        Utils.checkNotNull(integrations, "integrations");
        this.integrations = integrations;
        return this;
    }

    /**
     * The zone where the service is running
     */
    public DbaasServiceOpensearch withZone(String zone) {
        Utils.checkNotNull(zone, "zone");
        this.zone = Optional.ofNullable(zone);
        return this;
    }

    /**
     * The zone where the service is running
     */
    public DbaasServiceOpensearch withZone(Optional<? extends String> zone) {
        Utils.checkNotNull(zone, "zone");
        this.zone = zone;
        return this;
    }

    /**
     * State of individual service nodes
     */
    public DbaasServiceOpensearch withNodeStates(java.util.List<DbaasNodeState> nodeStates) {
        Utils.checkNotNull(nodeStates, "nodeStates");
        this.nodeStates = Optional.ofNullable(nodeStates);
        return this;
    }

    /**
     * State of individual service nodes
     */
    public DbaasServiceOpensearch withNodeStates(Optional<? extends java.util.List<DbaasNodeState>> nodeStates) {
        Utils.checkNotNull(nodeStates, "nodeStates");
        this.nodeStates = nodeStates;
        return this;
    }

    public DbaasServiceOpensearch withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    /**
     * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
     */
    public DbaasServiceOpensearch withKeepIndexRefreshInterval(boolean keepIndexRefreshInterval) {
        Utils.checkNotNull(keepIndexRefreshInterval, "keepIndexRefreshInterval");
        this.keepIndexRefreshInterval = Optional.ofNullable(keepIndexRefreshInterval);
        return this;
    }

    /**
     * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
     */
    public DbaasServiceOpensearch withKeepIndexRefreshInterval(Optional<? extends Boolean> keepIndexRefreshInterval) {
        Utils.checkNotNull(keepIndexRefreshInterval, "keepIndexRefreshInterval");
        this.keepIndexRefreshInterval = keepIndexRefreshInterval;
        return this;
    }

    public DbaasServiceOpensearch withType(String type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    public DbaasServiceOpensearch withState(EnumServiceState state) {
        Utils.checkNotNull(state, "state");
        this.state = Optional.ofNullable(state);
        return this;
    }

    public DbaasServiceOpensearch withState(Optional<? extends EnumServiceState> state) {
        Utils.checkNotNull(state, "state");
        this.state = state;
        return this;
    }

    /**
     * Allowed CIDR address blocks for incoming connections
     */
    public DbaasServiceOpensearch withIpFilter(java.util.List<String> ipFilter) {
        Utils.checkNotNull(ipFilter, "ipFilter");
        this.ipFilter = Optional.ofNullable(ipFilter);
        return this;
    }

    /**
     * Allowed CIDR address blocks for incoming connections
     */
    public DbaasServiceOpensearch withIpFilter(Optional<? extends java.util.List<String>> ipFilter) {
        Utils.checkNotNull(ipFilter, "ipFilter");
        this.ipFilter = ipFilter;
        return this;
    }

    /**
     * List of backups for the service
     */
    public DbaasServiceOpensearch withBackups(java.util.List<DbaasServiceBackup> backups) {
        Utils.checkNotNull(backups, "backups");
        this.backups = Optional.ofNullable(backups);
        return this;
    }

    /**
     * List of backups for the service
     */
    public DbaasServiceOpensearch withBackups(Optional<? extends java.util.List<DbaasServiceBackup>> backups) {
        Utils.checkNotNull(backups, "backups");
        this.backups = backups;
        return this;
    }

    /**
     * Service is protected against termination and powering off
     */
    public DbaasServiceOpensearch withTerminationProtection(boolean terminationProtection) {
        Utils.checkNotNull(terminationProtection, "terminationProtection");
        this.terminationProtection = Optional.ofNullable(terminationProtection);
        return this;
    }

    /**
     * Service is protected against termination and powering off
     */
    public DbaasServiceOpensearch withTerminationProtection(Optional<? extends Boolean> terminationProtection) {
        Utils.checkNotNull(terminationProtection, "terminationProtection");
        this.terminationProtection = terminationProtection;
        return this;
    }

    /**
     * Service notifications
     */
    public DbaasServiceOpensearch withNotifications(java.util.List<DbaasServiceNotification> notifications) {
        Utils.checkNotNull(notifications, "notifications");
        this.notifications = Optional.ofNullable(notifications);
        return this;
    }

    /**
     * Service notifications
     */
    public DbaasServiceOpensearch withNotifications(Optional<? extends java.util.List<DbaasServiceNotification>> notifications) {
        Utils.checkNotNull(notifications, "notifications");
        this.notifications = notifications;
        return this;
    }

    /**
     * Service component information objects
     */
    public DbaasServiceOpensearch withComponents(java.util.List<DbaasServiceOpensearchComponents> components) {
        Utils.checkNotNull(components, "components");
        this.components = Optional.ofNullable(components);
        return this;
    }

    /**
     * Service component information objects
     */
    public DbaasServiceOpensearch withComponents(Optional<? extends java.util.List<DbaasServiceOpensearchComponents>> components) {
        Utils.checkNotNull(components, "components");
        this.components = components;
        return this;
    }

    /**
     * Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
     */
    public DbaasServiceOpensearch withIndexPatterns(java.util.List<IndexPatterns> indexPatterns) {
        Utils.checkNotNull(indexPatterns, "indexPatterns");
        this.indexPatterns = Optional.ofNullable(indexPatterns);
        return this;
    }

    /**
     * Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
     */
    public DbaasServiceOpensearch withIndexPatterns(Optional<? extends java.util.List<IndexPatterns>> indexPatterns) {
        Utils.checkNotNull(indexPatterns, "indexPatterns");
        this.indexPatterns = indexPatterns;
        return this;
    }

    /**
     * Automatic maintenance settings
     */
    public DbaasServiceOpensearch withMaintenance(DbaasServiceMaintenance maintenance) {
        Utils.checkNotNull(maintenance, "maintenance");
        this.maintenance = Optional.ofNullable(maintenance);
        return this;
    }

    /**
     * Automatic maintenance settings
     */
    public DbaasServiceOpensearch withMaintenance(Optional<? extends DbaasServiceMaintenance> maintenance) {
        Utils.checkNotNull(maintenance, "maintenance");
        this.maintenance = maintenance;
        return this;
    }

    /**
     * Template settings for all new indexes
     */
    public DbaasServiceOpensearch withIndexTemplate(IndexTemplate indexTemplate) {
        Utils.checkNotNull(indexTemplate, "indexTemplate");
        this.indexTemplate = Optional.ofNullable(indexTemplate);
        return this;
    }

    /**
     * Template settings for all new indexes
     */
    public DbaasServiceOpensearch withIndexTemplate(Optional<? extends IndexTemplate> indexTemplate) {
        Utils.checkNotNull(indexTemplate, "indexTemplate");
        this.indexTemplate = indexTemplate;
        return this;
    }

    /**
     * TODO UNIT disk space for data storage
     */
    public DbaasServiceOpensearch withDiskSize(long diskSize) {
        Utils.checkNotNull(diskSize, "diskSize");
        this.diskSize = Optional.ofNullable(diskSize);
        return this;
    }

    /**
     * TODO UNIT disk space for data storage
     */
    public DbaasServiceOpensearch withDiskSize(Optional<? extends Long> diskSize) {
        Utils.checkNotNull(diskSize, "diskSize");
        this.diskSize = diskSize;
        return this;
    }

    /**
     * TODO UNIT of memory for each node
     */
    public DbaasServiceOpensearch withNodeMemory(long nodeMemory) {
        Utils.checkNotNull(nodeMemory, "nodeMemory");
        this.nodeMemory = Optional.ofNullable(nodeMemory);
        return this;
    }

    /**
     * TODO UNIT of memory for each node
     */
    public DbaasServiceOpensearch withNodeMemory(Optional<? extends Long> nodeMemory) {
        Utils.checkNotNull(nodeMemory, "nodeMemory");
        this.nodeMemory = nodeMemory;
        return this;
    }

    /**
     * URI for connecting to the service (may be absent)
     */
    public DbaasServiceOpensearch withUri(String uri) {
        Utils.checkNotNull(uri, "uri");
        this.uri = Optional.ofNullable(uri);
        return this;
    }

    /**
     * URI for connecting to the service (may be absent)
     */
    public DbaasServiceOpensearch withUri(Optional<? extends String> uri) {
        Utils.checkNotNull(uri, "uri");
        this.uri = uri;
        return this;
    }

    public DbaasServiceOpensearch withOpensearchSettings(JsonSchemaOpensearch opensearchSettings) {
        Utils.checkNotNull(opensearchSettings, "opensearchSettings");
        this.opensearchSettings = Optional.ofNullable(opensearchSettings);
        return this;
    }

    public DbaasServiceOpensearch withOpensearchSettings(Optional<? extends JsonSchemaOpensearch> opensearchSettings) {
        Utils.checkNotNull(opensearchSettings, "opensearchSettings");
        this.opensearchSettings = opensearchSettings;
        return this;
    }

    /**
     * service_uri parameterized into key-value pairs
     */
    public DbaasServiceOpensearch withUriParams(DbaasServiceOpensearchUriParams uriParams) {
        Utils.checkNotNull(uriParams, "uriParams");
        this.uriParams = Optional.ofNullable(uriParams);
        return this;
    }

    /**
     * service_uri parameterized into key-value pairs
     */
    public DbaasServiceOpensearch withUriParams(Optional<? extends DbaasServiceOpensearchUriParams> uriParams) {
        Utils.checkNotNull(uriParams, "uriParams");
        this.uriParams = uriParams;
        return this;
    }

    /**
     * OpenSearch version
     */
    public DbaasServiceOpensearch withVersion(String version) {
        Utils.checkNotNull(version, "version");
        this.version = Optional.ofNullable(version);
        return this;
    }

    /**
     * OpenSearch version
     */
    public DbaasServiceOpensearch withVersion(Optional<? extends String> version) {
        Utils.checkNotNull(version, "version");
        this.version = version;
        return this;
    }

    /**
     * Service creation timestamp (ISO 8601)
     */
    public DbaasServiceOpensearch withCreatedAt(OffsetDateTime createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = Optional.ofNullable(createdAt);
        return this;
    }

    /**
     * Service creation timestamp (ISO 8601)
     */
    public DbaasServiceOpensearch withCreatedAt(Optional<? extends OffsetDateTime> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * Subscription plan
     */
    public DbaasServiceOpensearch withPlan(String plan) {
        Utils.checkNotNull(plan, "plan");
        this.plan = plan;
        return this;
    }

    /**
     * OpenSearch Dashboards settings
     */
    public DbaasServiceOpensearch withOpensearchDashboards(OpensearchDashboards opensearchDashboards) {
        Utils.checkNotNull(opensearchDashboards, "opensearchDashboards");
        this.opensearchDashboards = Optional.ofNullable(opensearchDashboards);
        return this;
    }

    /**
     * OpenSearch Dashboards settings
     */
    public DbaasServiceOpensearch withOpensearchDashboards(Optional<? extends OpensearchDashboards> opensearchDashboards) {
        Utils.checkNotNull(opensearchDashboards, "opensearchDashboards");
        this.opensearchDashboards = opensearchDashboards;
        return this;
    }

    /**
     * List of service users
     */
    public DbaasServiceOpensearch withUsers(java.util.List<DbaasServiceOpensearchUsers> users) {
        Utils.checkNotNull(users, "users");
        this.users = Optional.ofNullable(users);
        return this;
    }

    /**
     * List of service users
     */
    public DbaasServiceOpensearch withUsers(Optional<? extends java.util.List<DbaasServiceOpensearchUsers>> users) {
        Utils.checkNotNull(users, "users");
        this.users = users;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        DbaasServiceOpensearch other = (DbaasServiceOpensearch) o;
        return 
            java.util.Objects.deepEquals(this.description, other.description) &&
            java.util.Objects.deepEquals(this.maxIndexCount, other.maxIndexCount) &&
            java.util.Objects.deepEquals(this.updatedAt, other.updatedAt) &&
            java.util.Objects.deepEquals(this.nodeCount, other.nodeCount) &&
            java.util.Objects.deepEquals(this.connectionInfo, other.connectionInfo) &&
            java.util.Objects.deepEquals(this.nodeCpuCount, other.nodeCpuCount) &&
            java.util.Objects.deepEquals(this.integrations, other.integrations) &&
            java.util.Objects.deepEquals(this.zone, other.zone) &&
            java.util.Objects.deepEquals(this.nodeStates, other.nodeStates) &&
            java.util.Objects.deepEquals(this.name, other.name) &&
            java.util.Objects.deepEquals(this.keepIndexRefreshInterval, other.keepIndexRefreshInterval) &&
            java.util.Objects.deepEquals(this.type, other.type) &&
            java.util.Objects.deepEquals(this.state, other.state) &&
            java.util.Objects.deepEquals(this.ipFilter, other.ipFilter) &&
            java.util.Objects.deepEquals(this.backups, other.backups) &&
            java.util.Objects.deepEquals(this.terminationProtection, other.terminationProtection) &&
            java.util.Objects.deepEquals(this.notifications, other.notifications) &&
            java.util.Objects.deepEquals(this.components, other.components) &&
            java.util.Objects.deepEquals(this.indexPatterns, other.indexPatterns) &&
            java.util.Objects.deepEquals(this.maintenance, other.maintenance) &&
            java.util.Objects.deepEquals(this.indexTemplate, other.indexTemplate) &&
            java.util.Objects.deepEquals(this.diskSize, other.diskSize) &&
            java.util.Objects.deepEquals(this.nodeMemory, other.nodeMemory) &&
            java.util.Objects.deepEquals(this.uri, other.uri) &&
            java.util.Objects.deepEquals(this.opensearchSettings, other.opensearchSettings) &&
            java.util.Objects.deepEquals(this.uriParams, other.uriParams) &&
            java.util.Objects.deepEquals(this.version, other.version) &&
            java.util.Objects.deepEquals(this.createdAt, other.createdAt) &&
            java.util.Objects.deepEquals(this.plan, other.plan) &&
            java.util.Objects.deepEquals(this.opensearchDashboards, other.opensearchDashboards) &&
            java.util.Objects.deepEquals(this.users, other.users);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            description,
            maxIndexCount,
            updatedAt,
            nodeCount,
            connectionInfo,
            nodeCpuCount,
            integrations,
            zone,
            nodeStates,
            name,
            keepIndexRefreshInterval,
            type,
            state,
            ipFilter,
            backups,
            terminationProtection,
            notifications,
            components,
            indexPatterns,
            maintenance,
            indexTemplate,
            diskSize,
            nodeMemory,
            uri,
            opensearchSettings,
            uriParams,
            version,
            createdAt,
            plan,
            opensearchDashboards,
            users);
    }
    
    @Override
    public String toString() {
        return Utils.toString(DbaasServiceOpensearch.class,
                "description", description,
                "maxIndexCount", maxIndexCount,
                "updatedAt", updatedAt,
                "nodeCount", nodeCount,
                "connectionInfo", connectionInfo,
                "nodeCpuCount", nodeCpuCount,
                "integrations", integrations,
                "zone", zone,
                "nodeStates", nodeStates,
                "name", name,
                "keepIndexRefreshInterval", keepIndexRefreshInterval,
                "type", type,
                "state", state,
                "ipFilter", ipFilter,
                "backups", backups,
                "terminationProtection", terminationProtection,
                "notifications", notifications,
                "components", components,
                "indexPatterns", indexPatterns,
                "maintenance", maintenance,
                "indexTemplate", indexTemplate,
                "diskSize", diskSize,
                "nodeMemory", nodeMemory,
                "uri", uri,
                "opensearchSettings", opensearchSettings,
                "uriParams", uriParams,
                "version", version,
                "createdAt", createdAt,
                "plan", plan,
                "opensearchDashboards", opensearchDashboards,
                "users", users);
    }
    
    public final static class Builder {
 
        private Optional<? extends String> description = Optional.empty();
 
        private Optional<? extends Long> maxIndexCount = Optional.empty();
 
        private Optional<? extends OffsetDateTime> updatedAt = Optional.empty();
 
        private Optional<? extends Long> nodeCount = Optional.empty();
 
        private Optional<? extends DbaasServiceOpensearchConnectionInfo> connectionInfo = Optional.empty();
 
        private Optional<? extends Long> nodeCpuCount = Optional.empty();
 
        private Optional<? extends java.util.List<DbaasIntegration>> integrations = Optional.empty();
 
        private Optional<? extends String> zone = Optional.empty();
 
        private Optional<? extends java.util.List<DbaasNodeState>> nodeStates = Optional.empty();
 
        private String name;
 
        private Optional<? extends Boolean> keepIndexRefreshInterval = Optional.empty();
 
        private String type;
 
        private Optional<? extends EnumServiceState> state = Optional.empty();
 
        private Optional<? extends java.util.List<String>> ipFilter = Optional.empty();
 
        private Optional<? extends java.util.List<DbaasServiceBackup>> backups = Optional.empty();
 
        private Optional<? extends Boolean> terminationProtection = Optional.empty();
 
        private Optional<? extends java.util.List<DbaasServiceNotification>> notifications = Optional.empty();
 
        private Optional<? extends java.util.List<DbaasServiceOpensearchComponents>> components = Optional.empty();
 
        private Optional<? extends java.util.List<IndexPatterns>> indexPatterns = Optional.empty();
 
        private Optional<? extends DbaasServiceMaintenance> maintenance = Optional.empty();
 
        private Optional<? extends IndexTemplate> indexTemplate = Optional.empty();
 
        private Optional<? extends Long> diskSize = Optional.empty();
 
        private Optional<? extends Long> nodeMemory = Optional.empty();
 
        private Optional<? extends String> uri = Optional.empty();
 
        private Optional<? extends JsonSchemaOpensearch> opensearchSettings = Optional.empty();
 
        private Optional<? extends DbaasServiceOpensearchUriParams> uriParams = Optional.empty();
 
        private Optional<? extends String> version = Optional.empty();
 
        private Optional<? extends OffsetDateTime> createdAt = Optional.empty();
 
        private String plan;
 
        private Optional<? extends OpensearchDashboards> opensearchDashboards = Optional.empty();
 
        private Optional<? extends java.util.List<DbaasServiceOpensearchUsers>> users = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * DbaaS service description
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = Optional.ofNullable(description);
            return this;
        }

        /**
         * DbaaS service description
         */
        public Builder description(Optional<? extends String> description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }

        /**
         * Maximum number of indexes to keep before deleting the oldest one
         */
        public Builder maxIndexCount(long maxIndexCount) {
            Utils.checkNotNull(maxIndexCount, "maxIndexCount");
            this.maxIndexCount = Optional.ofNullable(maxIndexCount);
            return this;
        }

        /**
         * Maximum number of indexes to keep before deleting the oldest one
         */
        public Builder maxIndexCount(Optional<? extends Long> maxIndexCount) {
            Utils.checkNotNull(maxIndexCount, "maxIndexCount");
            this.maxIndexCount = maxIndexCount;
            return this;
        }

        /**
         * Service last update timestamp (ISO 8601)
         */
        public Builder updatedAt(OffsetDateTime updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = Optional.ofNullable(updatedAt);
            return this;
        }

        /**
         * Service last update timestamp (ISO 8601)
         */
        public Builder updatedAt(Optional<? extends OffsetDateTime> updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = updatedAt;
            return this;
        }

        /**
         * Number of service nodes in the active plan
         */
        public Builder nodeCount(long nodeCount) {
            Utils.checkNotNull(nodeCount, "nodeCount");
            this.nodeCount = Optional.ofNullable(nodeCount);
            return this;
        }

        /**
         * Number of service nodes in the active plan
         */
        public Builder nodeCount(Optional<? extends Long> nodeCount) {
            Utils.checkNotNull(nodeCount, "nodeCount");
            this.nodeCount = nodeCount;
            return this;
        }

        /**
         * Opensearch connection information properties
         */
        public Builder connectionInfo(DbaasServiceOpensearchConnectionInfo connectionInfo) {
            Utils.checkNotNull(connectionInfo, "connectionInfo");
            this.connectionInfo = Optional.ofNullable(connectionInfo);
            return this;
        }

        /**
         * Opensearch connection information properties
         */
        public Builder connectionInfo(Optional<? extends DbaasServiceOpensearchConnectionInfo> connectionInfo) {
            Utils.checkNotNull(connectionInfo, "connectionInfo");
            this.connectionInfo = connectionInfo;
            return this;
        }

        /**
         * Number of CPUs for each node
         */
        public Builder nodeCpuCount(long nodeCpuCount) {
            Utils.checkNotNull(nodeCpuCount, "nodeCpuCount");
            this.nodeCpuCount = Optional.ofNullable(nodeCpuCount);
            return this;
        }

        /**
         * Number of CPUs for each node
         */
        public Builder nodeCpuCount(Optional<? extends Long> nodeCpuCount) {
            Utils.checkNotNull(nodeCpuCount, "nodeCpuCount");
            this.nodeCpuCount = nodeCpuCount;
            return this;
        }

        /**
         * Service integrations
         */
        public Builder integrations(java.util.List<DbaasIntegration> integrations) {
            Utils.checkNotNull(integrations, "integrations");
            this.integrations = Optional.ofNullable(integrations);
            return this;
        }

        /**
         * Service integrations
         */
        public Builder integrations(Optional<? extends java.util.List<DbaasIntegration>> integrations) {
            Utils.checkNotNull(integrations, "integrations");
            this.integrations = integrations;
            return this;
        }

        /**
         * The zone where the service is running
         */
        public Builder zone(String zone) {
            Utils.checkNotNull(zone, "zone");
            this.zone = Optional.ofNullable(zone);
            return this;
        }

        /**
         * The zone where the service is running
         */
        public Builder zone(Optional<? extends String> zone) {
            Utils.checkNotNull(zone, "zone");
            this.zone = zone;
            return this;
        }

        /**
         * State of individual service nodes
         */
        public Builder nodeStates(java.util.List<DbaasNodeState> nodeStates) {
            Utils.checkNotNull(nodeStates, "nodeStates");
            this.nodeStates = Optional.ofNullable(nodeStates);
            return this;
        }

        /**
         * State of individual service nodes
         */
        public Builder nodeStates(Optional<? extends java.util.List<DbaasNodeState>> nodeStates) {
            Utils.checkNotNull(nodeStates, "nodeStates");
            this.nodeStates = nodeStates;
            return this;
        }

        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }

        /**
         * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
         */
        public Builder keepIndexRefreshInterval(boolean keepIndexRefreshInterval) {
            Utils.checkNotNull(keepIndexRefreshInterval, "keepIndexRefreshInterval");
            this.keepIndexRefreshInterval = Optional.ofNullable(keepIndexRefreshInterval);
            return this;
        }

        /**
         * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
         */
        public Builder keepIndexRefreshInterval(Optional<? extends Boolean> keepIndexRefreshInterval) {
            Utils.checkNotNull(keepIndexRefreshInterval, "keepIndexRefreshInterval");
            this.keepIndexRefreshInterval = keepIndexRefreshInterval;
            return this;
        }

        public Builder type(String type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }

        public Builder state(EnumServiceState state) {
            Utils.checkNotNull(state, "state");
            this.state = Optional.ofNullable(state);
            return this;
        }

        public Builder state(Optional<? extends EnumServiceState> state) {
            Utils.checkNotNull(state, "state");
            this.state = state;
            return this;
        }

        /**
         * Allowed CIDR address blocks for incoming connections
         */
        public Builder ipFilter(java.util.List<String> ipFilter) {
            Utils.checkNotNull(ipFilter, "ipFilter");
            this.ipFilter = Optional.ofNullable(ipFilter);
            return this;
        }

        /**
         * Allowed CIDR address blocks for incoming connections
         */
        public Builder ipFilter(Optional<? extends java.util.List<String>> ipFilter) {
            Utils.checkNotNull(ipFilter, "ipFilter");
            this.ipFilter = ipFilter;
            return this;
        }

        /**
         * List of backups for the service
         */
        public Builder backups(java.util.List<DbaasServiceBackup> backups) {
            Utils.checkNotNull(backups, "backups");
            this.backups = Optional.ofNullable(backups);
            return this;
        }

        /**
         * List of backups for the service
         */
        public Builder backups(Optional<? extends java.util.List<DbaasServiceBackup>> backups) {
            Utils.checkNotNull(backups, "backups");
            this.backups = backups;
            return this;
        }

        /**
         * Service is protected against termination and powering off
         */
        public Builder terminationProtection(boolean terminationProtection) {
            Utils.checkNotNull(terminationProtection, "terminationProtection");
            this.terminationProtection = Optional.ofNullable(terminationProtection);
            return this;
        }

        /**
         * Service is protected against termination and powering off
         */
        public Builder terminationProtection(Optional<? extends Boolean> terminationProtection) {
            Utils.checkNotNull(terminationProtection, "terminationProtection");
            this.terminationProtection = terminationProtection;
            return this;
        }

        /**
         * Service notifications
         */
        public Builder notifications(java.util.List<DbaasServiceNotification> notifications) {
            Utils.checkNotNull(notifications, "notifications");
            this.notifications = Optional.ofNullable(notifications);
            return this;
        }

        /**
         * Service notifications
         */
        public Builder notifications(Optional<? extends java.util.List<DbaasServiceNotification>> notifications) {
            Utils.checkNotNull(notifications, "notifications");
            this.notifications = notifications;
            return this;
        }

        /**
         * Service component information objects
         */
        public Builder components(java.util.List<DbaasServiceOpensearchComponents> components) {
            Utils.checkNotNull(components, "components");
            this.components = Optional.ofNullable(components);
            return this;
        }

        /**
         * Service component information objects
         */
        public Builder components(Optional<? extends java.util.List<DbaasServiceOpensearchComponents>> components) {
            Utils.checkNotNull(components, "components");
            this.components = components;
            return this;
        }

        /**
         * Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
         */
        public Builder indexPatterns(java.util.List<IndexPatterns> indexPatterns) {
            Utils.checkNotNull(indexPatterns, "indexPatterns");
            this.indexPatterns = Optional.ofNullable(indexPatterns);
            return this;
        }

        /**
         * Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
         */
        public Builder indexPatterns(Optional<? extends java.util.List<IndexPatterns>> indexPatterns) {
            Utils.checkNotNull(indexPatterns, "indexPatterns");
            this.indexPatterns = indexPatterns;
            return this;
        }

        /**
         * Automatic maintenance settings
         */
        public Builder maintenance(DbaasServiceMaintenance maintenance) {
            Utils.checkNotNull(maintenance, "maintenance");
            this.maintenance = Optional.ofNullable(maintenance);
            return this;
        }

        /**
         * Automatic maintenance settings
         */
        public Builder maintenance(Optional<? extends DbaasServiceMaintenance> maintenance) {
            Utils.checkNotNull(maintenance, "maintenance");
            this.maintenance = maintenance;
            return this;
        }

        /**
         * Template settings for all new indexes
         */
        public Builder indexTemplate(IndexTemplate indexTemplate) {
            Utils.checkNotNull(indexTemplate, "indexTemplate");
            this.indexTemplate = Optional.ofNullable(indexTemplate);
            return this;
        }

        /**
         * Template settings for all new indexes
         */
        public Builder indexTemplate(Optional<? extends IndexTemplate> indexTemplate) {
            Utils.checkNotNull(indexTemplate, "indexTemplate");
            this.indexTemplate = indexTemplate;
            return this;
        }

        /**
         * TODO UNIT disk space for data storage
         */
        public Builder diskSize(long diskSize) {
            Utils.checkNotNull(diskSize, "diskSize");
            this.diskSize = Optional.ofNullable(diskSize);
            return this;
        }

        /**
         * TODO UNIT disk space for data storage
         */
        public Builder diskSize(Optional<? extends Long> diskSize) {
            Utils.checkNotNull(diskSize, "diskSize");
            this.diskSize = diskSize;
            return this;
        }

        /**
         * TODO UNIT of memory for each node
         */
        public Builder nodeMemory(long nodeMemory) {
            Utils.checkNotNull(nodeMemory, "nodeMemory");
            this.nodeMemory = Optional.ofNullable(nodeMemory);
            return this;
        }

        /**
         * TODO UNIT of memory for each node
         */
        public Builder nodeMemory(Optional<? extends Long> nodeMemory) {
            Utils.checkNotNull(nodeMemory, "nodeMemory");
            this.nodeMemory = nodeMemory;
            return this;
        }

        /**
         * URI for connecting to the service (may be absent)
         */
        public Builder uri(String uri) {
            Utils.checkNotNull(uri, "uri");
            this.uri = Optional.ofNullable(uri);
            return this;
        }

        /**
         * URI for connecting to the service (may be absent)
         */
        public Builder uri(Optional<? extends String> uri) {
            Utils.checkNotNull(uri, "uri");
            this.uri = uri;
            return this;
        }

        public Builder opensearchSettings(JsonSchemaOpensearch opensearchSettings) {
            Utils.checkNotNull(opensearchSettings, "opensearchSettings");
            this.opensearchSettings = Optional.ofNullable(opensearchSettings);
            return this;
        }

        public Builder opensearchSettings(Optional<? extends JsonSchemaOpensearch> opensearchSettings) {
            Utils.checkNotNull(opensearchSettings, "opensearchSettings");
            this.opensearchSettings = opensearchSettings;
            return this;
        }

        /**
         * service_uri parameterized into key-value pairs
         */
        public Builder uriParams(DbaasServiceOpensearchUriParams uriParams) {
            Utils.checkNotNull(uriParams, "uriParams");
            this.uriParams = Optional.ofNullable(uriParams);
            return this;
        }

        /**
         * service_uri parameterized into key-value pairs
         */
        public Builder uriParams(Optional<? extends DbaasServiceOpensearchUriParams> uriParams) {
            Utils.checkNotNull(uriParams, "uriParams");
            this.uriParams = uriParams;
            return this;
        }

        /**
         * OpenSearch version
         */
        public Builder version(String version) {
            Utils.checkNotNull(version, "version");
            this.version = Optional.ofNullable(version);
            return this;
        }

        /**
         * OpenSearch version
         */
        public Builder version(Optional<? extends String> version) {
            Utils.checkNotNull(version, "version");
            this.version = version;
            return this;
        }

        /**
         * Service creation timestamp (ISO 8601)
         */
        public Builder createdAt(OffsetDateTime createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        /**
         * Service creation timestamp (ISO 8601)
         */
        public Builder createdAt(Optional<? extends OffsetDateTime> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        /**
         * Subscription plan
         */
        public Builder plan(String plan) {
            Utils.checkNotNull(plan, "plan");
            this.plan = plan;
            return this;
        }

        /**
         * OpenSearch Dashboards settings
         */
        public Builder opensearchDashboards(OpensearchDashboards opensearchDashboards) {
            Utils.checkNotNull(opensearchDashboards, "opensearchDashboards");
            this.opensearchDashboards = Optional.ofNullable(opensearchDashboards);
            return this;
        }

        /**
         * OpenSearch Dashboards settings
         */
        public Builder opensearchDashboards(Optional<? extends OpensearchDashboards> opensearchDashboards) {
            Utils.checkNotNull(opensearchDashboards, "opensearchDashboards");
            this.opensearchDashboards = opensearchDashboards;
            return this;
        }

        /**
         * List of service users
         */
        public Builder users(java.util.List<DbaasServiceOpensearchUsers> users) {
            Utils.checkNotNull(users, "users");
            this.users = Optional.ofNullable(users);
            return this;
        }

        /**
         * List of service users
         */
        public Builder users(Optional<? extends java.util.List<DbaasServiceOpensearchUsers>> users) {
            Utils.checkNotNull(users, "users");
            this.users = users;
            return this;
        }
        
        public DbaasServiceOpensearch build() {
            return new DbaasServiceOpensearch(
                description,
                maxIndexCount,
                updatedAt,
                nodeCount,
                connectionInfo,
                nodeCpuCount,
                integrations,
                zone,
                nodeStates,
                name,
                keepIndexRefreshInterval,
                type,
                state,
                ipFilter,
                backups,
                terminationProtection,
                notifications,
                components,
                indexPatterns,
                maintenance,
                indexTemplate,
                diskSize,
                nodeMemory,
                uri,
                opensearchSettings,
                uriParams,
                version,
                createdAt,
                plan,
                opensearchDashboards,
                users);
        }
    }
}

