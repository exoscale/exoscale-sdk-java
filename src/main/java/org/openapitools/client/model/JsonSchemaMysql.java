/*
 * Exoscale Public API
 *  Infrastructure automation API, allowing programmatic access to all Exoscale products and services.  The [OpenAPI Specification](http://spec.openapis.org/oas/v3.0.3.html) source of this documentation can be obtained here:  * [JSON format](https://openapi-v2.exoscale.com/source.json) * [YAML format](https://openapi-v2.exoscale.com/source.yaml)
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: api@exoscale.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * JsonSchemaMysql
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-03-27T17:14:44.205710495Z[Etc/UTC]", comments = "Generator version: 7.5.0-SNAPSHOT")
public class JsonSchemaMysql {
  public static final String SERIALIZED_NAME_NET_WRITE_TIMEOUT = "net_write_timeout";
  @SerializedName(SERIALIZED_NAME_NET_WRITE_TIMEOUT)
  private Integer netWriteTimeout;

  /**
   * The storage engine for in-memory internal temporary tables.
   */
  @JsonAdapter(InternalTmpMemStorageEngineEnum.Adapter.class)
  public enum InternalTmpMemStorageEngineEnum {
    TEMPTABLE("TempTable"),
    
    MEMORY("MEMORY");

    private String value;

    InternalTmpMemStorageEngineEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static InternalTmpMemStorageEngineEnum fromValue(String value) {
      for (InternalTmpMemStorageEngineEnum b : InternalTmpMemStorageEngineEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<InternalTmpMemStorageEngineEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final InternalTmpMemStorageEngineEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public InternalTmpMemStorageEngineEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return InternalTmpMemStorageEngineEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      InternalTmpMemStorageEngineEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_INTERNAL_TMP_MEM_STORAGE_ENGINE = "internal_tmp_mem_storage_engine";
  @SerializedName(SERIALIZED_NAME_INTERNAL_TMP_MEM_STORAGE_ENGINE)
  private InternalTmpMemStorageEngineEnum internalTmpMemStorageEngine;

  public static final String SERIALIZED_NAME_SQL_MODE = "sql_mode";
  @SerializedName(SERIALIZED_NAME_SQL_MODE)
  private String sqlMode;

  public static final String SERIALIZED_NAME_INFORMATION_SCHEMA_STATS_EXPIRY = "information_schema_stats_expiry";
  @SerializedName(SERIALIZED_NAME_INFORMATION_SCHEMA_STATS_EXPIRY)
  private Integer informationSchemaStatsExpiry;

  public static final String SERIALIZED_NAME_SORT_BUFFER_SIZE = "sort_buffer_size";
  @SerializedName(SERIALIZED_NAME_SORT_BUFFER_SIZE)
  private Integer sortBufferSize;

  public static final String SERIALIZED_NAME_INNODB_THREAD_CONCURRENCY = "innodb_thread_concurrency";
  @SerializedName(SERIALIZED_NAME_INNODB_THREAD_CONCURRENCY)
  private Integer innodbThreadConcurrency;

  public static final String SERIALIZED_NAME_INNODB_WRITE_IO_THREADS = "innodb_write_io_threads";
  @SerializedName(SERIALIZED_NAME_INNODB_WRITE_IO_THREADS)
  private Integer innodbWriteIoThreads;

  public static final String SERIALIZED_NAME_INNODB_FT_MIN_TOKEN_SIZE = "innodb_ft_min_token_size";
  @SerializedName(SERIALIZED_NAME_INNODB_FT_MIN_TOKEN_SIZE)
  private Integer innodbFtMinTokenSize;

  public static final String SERIALIZED_NAME_INNODB_CHANGE_BUFFER_MAX_SIZE = "innodb_change_buffer_max_size";
  @SerializedName(SERIALIZED_NAME_INNODB_CHANGE_BUFFER_MAX_SIZE)
  private Integer innodbChangeBufferMaxSize;

  public static final String SERIALIZED_NAME_INNODB_FLUSH_NEIGHBORS = "innodb_flush_neighbors";
  @SerializedName(SERIALIZED_NAME_INNODB_FLUSH_NEIGHBORS)
  private Integer innodbFlushNeighbors;

  public static final String SERIALIZED_NAME_TMP_TABLE_SIZE = "tmp_table_size";
  @SerializedName(SERIALIZED_NAME_TMP_TABLE_SIZE)
  private Integer tmpTableSize;

  public static final String SERIALIZED_NAME_SLOW_QUERY_LOG = "slow_query_log";
  @SerializedName(SERIALIZED_NAME_SLOW_QUERY_LOG)
  private Boolean slowQueryLog;

  public static final String SERIALIZED_NAME_CONNECT_TIMEOUT = "connect_timeout";
  @SerializedName(SERIALIZED_NAME_CONNECT_TIMEOUT)
  private Integer connectTimeout;

  public static final String SERIALIZED_NAME_NET_READ_TIMEOUT = "net_read_timeout";
  @SerializedName(SERIALIZED_NAME_NET_READ_TIMEOUT)
  private Integer netReadTimeout;

  public static final String SERIALIZED_NAME_INNODB_LOCK_WAIT_TIMEOUT = "innodb_lock_wait_timeout";
  @SerializedName(SERIALIZED_NAME_INNODB_LOCK_WAIT_TIMEOUT)
  private Integer innodbLockWaitTimeout;

  public static final String SERIALIZED_NAME_WAIT_TIMEOUT = "wait_timeout";
  @SerializedName(SERIALIZED_NAME_WAIT_TIMEOUT)
  private Integer waitTimeout;

  public static final String SERIALIZED_NAME_INNODB_ROLLBACK_ON_TIMEOUT = "innodb_rollback_on_timeout";
  @SerializedName(SERIALIZED_NAME_INNODB_ROLLBACK_ON_TIMEOUT)
  private Boolean innodbRollbackOnTimeout;

  public static final String SERIALIZED_NAME_GROUP_CONCAT_MAX_LEN = "group_concat_max_len";
  @SerializedName(SERIALIZED_NAME_GROUP_CONCAT_MAX_LEN)
  private Integer groupConcatMaxLen;

  public static final String SERIALIZED_NAME_NET_BUFFER_LENGTH = "net_buffer_length";
  @SerializedName(SERIALIZED_NAME_NET_BUFFER_LENGTH)
  private Integer netBufferLength;

  public static final String SERIALIZED_NAME_INNODB_PRINT_ALL_DEADLOCKS = "innodb_print_all_deadlocks";
  @SerializedName(SERIALIZED_NAME_INNODB_PRINT_ALL_DEADLOCKS)
  private Boolean innodbPrintAllDeadlocks;

  public static final String SERIALIZED_NAME_INNODB_ONLINE_ALTER_LOG_MAX_SIZE = "innodb_online_alter_log_max_size";
  @SerializedName(SERIALIZED_NAME_INNODB_ONLINE_ALTER_LOG_MAX_SIZE)
  private Integer innodbOnlineAlterLogMaxSize;

  public static final String SERIALIZED_NAME_INTERACTIVE_TIMEOUT = "interactive_timeout";
  @SerializedName(SERIALIZED_NAME_INTERACTIVE_TIMEOUT)
  private Integer interactiveTimeout;

  public static final String SERIALIZED_NAME_INNODB_LOG_BUFFER_SIZE = "innodb_log_buffer_size";
  @SerializedName(SERIALIZED_NAME_INNODB_LOG_BUFFER_SIZE)
  private Integer innodbLogBufferSize;

  public static final String SERIALIZED_NAME_MAX_ALLOWED_PACKET = "max_allowed_packet";
  @SerializedName(SERIALIZED_NAME_MAX_ALLOWED_PACKET)
  private Integer maxAllowedPacket;

  public static final String SERIALIZED_NAME_MAX_HEAP_TABLE_SIZE = "max_heap_table_size";
  @SerializedName(SERIALIZED_NAME_MAX_HEAP_TABLE_SIZE)
  private Integer maxHeapTableSize;

  public static final String SERIALIZED_NAME_INNODB_FT_SERVER_STOPWORD_TABLE = "innodb_ft_server_stopword_table";
  @SerializedName(SERIALIZED_NAME_INNODB_FT_SERVER_STOPWORD_TABLE)
  private String innodbFtServerStopwordTable;

  public static final String SERIALIZED_NAME_INNODB_READ_IO_THREADS = "innodb_read_io_threads";
  @SerializedName(SERIALIZED_NAME_INNODB_READ_IO_THREADS)
  private Integer innodbReadIoThreads;

  public static final String SERIALIZED_NAME_SQL_REQUIRE_PRIMARY_KEY = "sql_require_primary_key";
  @SerializedName(SERIALIZED_NAME_SQL_REQUIRE_PRIMARY_KEY)
  private Boolean sqlRequirePrimaryKey;

  public static final String SERIALIZED_NAME_DEFAULT_TIME_ZONE = "default_time_zone";
  @SerializedName(SERIALIZED_NAME_DEFAULT_TIME_ZONE)
  private String defaultTimeZone;

  public static final String SERIALIZED_NAME_LONG_QUERY_TIME = "long_query_time";
  @SerializedName(SERIALIZED_NAME_LONG_QUERY_TIME)
  private BigDecimal longQueryTime;

  public JsonSchemaMysql() {
  }

  public JsonSchemaMysql netWriteTimeout(Integer netWriteTimeout) {
    this.netWriteTimeout = netWriteTimeout;
    return this;
  }

   /**
   * The number of seconds to wait for a block to be written to a connection before aborting the write.
   * minimum: 1
   * maximum: 3600
   * @return netWriteTimeout
  **/
  @javax.annotation.Nullable
  public Integer getNetWriteTimeout() {
    return netWriteTimeout;
  }

  public void setNetWriteTimeout(Integer netWriteTimeout) {
    this.netWriteTimeout = netWriteTimeout;
  }


  public JsonSchemaMysql internalTmpMemStorageEngine(InternalTmpMemStorageEngineEnum internalTmpMemStorageEngine) {
    this.internalTmpMemStorageEngine = internalTmpMemStorageEngine;
    return this;
  }

   /**
   * The storage engine for in-memory internal temporary tables.
   * @return internalTmpMemStorageEngine
  **/
  @javax.annotation.Nullable
  public InternalTmpMemStorageEngineEnum getInternalTmpMemStorageEngine() {
    return internalTmpMemStorageEngine;
  }

  public void setInternalTmpMemStorageEngine(InternalTmpMemStorageEngineEnum internalTmpMemStorageEngine) {
    this.internalTmpMemStorageEngine = internalTmpMemStorageEngine;
  }


  public JsonSchemaMysql sqlMode(String sqlMode) {
    this.sqlMode = sqlMode;
    return this;
  }

   /**
   * Global SQL mode. Set to empty to use MySQL server defaults. When creating a new service and not setting this field Aiven default SQL mode (strict, SQL standard compliant) will be assigned.
   * @return sqlMode
  **/
  @javax.annotation.Nullable
  public String getSqlMode() {
    return sqlMode;
  }

  public void setSqlMode(String sqlMode) {
    this.sqlMode = sqlMode;
  }


  public JsonSchemaMysql informationSchemaStatsExpiry(Integer informationSchemaStatsExpiry) {
    this.informationSchemaStatsExpiry = informationSchemaStatsExpiry;
    return this;
  }

   /**
   * The time, in seconds, before cached statistics expire
   * minimum: 900
   * maximum: 31536000
   * @return informationSchemaStatsExpiry
  **/
  @javax.annotation.Nullable
  public Integer getInformationSchemaStatsExpiry() {
    return informationSchemaStatsExpiry;
  }

  public void setInformationSchemaStatsExpiry(Integer informationSchemaStatsExpiry) {
    this.informationSchemaStatsExpiry = informationSchemaStatsExpiry;
  }


  public JsonSchemaMysql sortBufferSize(Integer sortBufferSize) {
    this.sortBufferSize = sortBufferSize;
    return this;
  }

   /**
   * Sort buffer size in bytes for ORDER BY optimization. Default is 262144 (256K)
   * minimum: 32768
   * maximum: 1073741824
   * @return sortBufferSize
  **/
  @javax.annotation.Nullable
  public Integer getSortBufferSize() {
    return sortBufferSize;
  }

  public void setSortBufferSize(Integer sortBufferSize) {
    this.sortBufferSize = sortBufferSize;
  }


  public JsonSchemaMysql innodbThreadConcurrency(Integer innodbThreadConcurrency) {
    this.innodbThreadConcurrency = innodbThreadConcurrency;
    return this;
  }

   /**
   * Defines the maximum number of threads permitted inside of InnoDB. Default is 0 (infinite concurrency - no limit)
   * minimum: 0
   * maximum: 1000
   * @return innodbThreadConcurrency
  **/
  @javax.annotation.Nullable
  public Integer getInnodbThreadConcurrency() {
    return innodbThreadConcurrency;
  }

  public void setInnodbThreadConcurrency(Integer innodbThreadConcurrency) {
    this.innodbThreadConcurrency = innodbThreadConcurrency;
  }


  public JsonSchemaMysql innodbWriteIoThreads(Integer innodbWriteIoThreads) {
    this.innodbWriteIoThreads = innodbWriteIoThreads;
    return this;
  }

   /**
   * The number of I/O threads for write operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
   * minimum: 1
   * maximum: 64
   * @return innodbWriteIoThreads
  **/
  @javax.annotation.Nullable
  public Integer getInnodbWriteIoThreads() {
    return innodbWriteIoThreads;
  }

  public void setInnodbWriteIoThreads(Integer innodbWriteIoThreads) {
    this.innodbWriteIoThreads = innodbWriteIoThreads;
  }


  public JsonSchemaMysql innodbFtMinTokenSize(Integer innodbFtMinTokenSize) {
    this.innodbFtMinTokenSize = innodbFtMinTokenSize;
    return this;
  }

   /**
   * Minimum length of words that are stored in an InnoDB FULLTEXT index. Changing this parameter will lead to a restart of the MySQL service.
   * minimum: 0
   * maximum: 16
   * @return innodbFtMinTokenSize
  **/
  @javax.annotation.Nullable
  public Integer getInnodbFtMinTokenSize() {
    return innodbFtMinTokenSize;
  }

  public void setInnodbFtMinTokenSize(Integer innodbFtMinTokenSize) {
    this.innodbFtMinTokenSize = innodbFtMinTokenSize;
  }


  public JsonSchemaMysql innodbChangeBufferMaxSize(Integer innodbChangeBufferMaxSize) {
    this.innodbChangeBufferMaxSize = innodbChangeBufferMaxSize;
    return this;
  }

   /**
   * Maximum size for the InnoDB change buffer, as a percentage of the total size of the buffer pool. Default is 25
   * minimum: 0
   * maximum: 50
   * @return innodbChangeBufferMaxSize
  **/
  @javax.annotation.Nullable
  public Integer getInnodbChangeBufferMaxSize() {
    return innodbChangeBufferMaxSize;
  }

  public void setInnodbChangeBufferMaxSize(Integer innodbChangeBufferMaxSize) {
    this.innodbChangeBufferMaxSize = innodbChangeBufferMaxSize;
  }


  public JsonSchemaMysql innodbFlushNeighbors(Integer innodbFlushNeighbors) {
    this.innodbFlushNeighbors = innodbFlushNeighbors;
    return this;
  }

   /**
   * Specifies whether flushing a page from the InnoDB buffer pool also flushes other dirty pages in the same extent (default is 1): 0 - dirty pages in the same extent are not flushed,  1 - flush contiguous dirty pages in the same extent,  2 - flush dirty pages in the same extent
   * minimum: 0
   * maximum: 2
   * @return innodbFlushNeighbors
  **/
  @javax.annotation.Nullable
  public Integer getInnodbFlushNeighbors() {
    return innodbFlushNeighbors;
  }

  public void setInnodbFlushNeighbors(Integer innodbFlushNeighbors) {
    this.innodbFlushNeighbors = innodbFlushNeighbors;
  }


  public JsonSchemaMysql tmpTableSize(Integer tmpTableSize) {
    this.tmpTableSize = tmpTableSize;
    return this;
  }

   /**
   * Limits the size of internal in-memory tables. Also set max_heap_table_size. Default is 16777216 (16M)
   * minimum: 1048576
   * maximum: 1073741824
   * @return tmpTableSize
  **/
  @javax.annotation.Nullable
  public Integer getTmpTableSize() {
    return tmpTableSize;
  }

  public void setTmpTableSize(Integer tmpTableSize) {
    this.tmpTableSize = tmpTableSize;
  }


  public JsonSchemaMysql slowQueryLog(Boolean slowQueryLog) {
    this.slowQueryLog = slowQueryLog;
    return this;
  }

   /**
   * Slow query log enables capturing of slow queries. Setting slow_query_log to false also truncates the mysql.slow_log table. Default is off
   * @return slowQueryLog
  **/
  @javax.annotation.Nullable
  public Boolean getSlowQueryLog() {
    return slowQueryLog;
  }

  public void setSlowQueryLog(Boolean slowQueryLog) {
    this.slowQueryLog = slowQueryLog;
  }


  public JsonSchemaMysql connectTimeout(Integer connectTimeout) {
    this.connectTimeout = connectTimeout;
    return this;
  }

   /**
   * The number of seconds that the mysqld server waits for a connect packet before responding with Bad handshake
   * minimum: 2
   * maximum: 3600
   * @return connectTimeout
  **/
  @javax.annotation.Nullable
  public Integer getConnectTimeout() {
    return connectTimeout;
  }

  public void setConnectTimeout(Integer connectTimeout) {
    this.connectTimeout = connectTimeout;
  }


  public JsonSchemaMysql netReadTimeout(Integer netReadTimeout) {
    this.netReadTimeout = netReadTimeout;
    return this;
  }

   /**
   * The number of seconds to wait for more data from a connection before aborting the read.
   * minimum: 1
   * maximum: 3600
   * @return netReadTimeout
  **/
  @javax.annotation.Nullable
  public Integer getNetReadTimeout() {
    return netReadTimeout;
  }

  public void setNetReadTimeout(Integer netReadTimeout) {
    this.netReadTimeout = netReadTimeout;
  }


  public JsonSchemaMysql innodbLockWaitTimeout(Integer innodbLockWaitTimeout) {
    this.innodbLockWaitTimeout = innodbLockWaitTimeout;
    return this;
  }

   /**
   * The length of time in seconds an InnoDB transaction waits for a row lock before giving up. Default is 120.
   * minimum: 1
   * maximum: 3600
   * @return innodbLockWaitTimeout
  **/
  @javax.annotation.Nullable
  public Integer getInnodbLockWaitTimeout() {
    return innodbLockWaitTimeout;
  }

  public void setInnodbLockWaitTimeout(Integer innodbLockWaitTimeout) {
    this.innodbLockWaitTimeout = innodbLockWaitTimeout;
  }


  public JsonSchemaMysql waitTimeout(Integer waitTimeout) {
    this.waitTimeout = waitTimeout;
    return this;
  }

   /**
   * The number of seconds the server waits for activity on a noninteractive connection before closing it.
   * minimum: 1
   * maximum: 2147483
   * @return waitTimeout
  **/
  @javax.annotation.Nullable
  public Integer getWaitTimeout() {
    return waitTimeout;
  }

  public void setWaitTimeout(Integer waitTimeout) {
    this.waitTimeout = waitTimeout;
  }


  public JsonSchemaMysql innodbRollbackOnTimeout(Boolean innodbRollbackOnTimeout) {
    this.innodbRollbackOnTimeout = innodbRollbackOnTimeout;
    return this;
  }

   /**
   * When enabled a transaction timeout causes InnoDB to abort and roll back the entire transaction. Changing this parameter will lead to a restart of the MySQL service.
   * @return innodbRollbackOnTimeout
  **/
  @javax.annotation.Nullable
  public Boolean getInnodbRollbackOnTimeout() {
    return innodbRollbackOnTimeout;
  }

  public void setInnodbRollbackOnTimeout(Boolean innodbRollbackOnTimeout) {
    this.innodbRollbackOnTimeout = innodbRollbackOnTimeout;
  }


  public JsonSchemaMysql groupConcatMaxLen(Integer groupConcatMaxLen) {
    this.groupConcatMaxLen = groupConcatMaxLen;
    return this;
  }

   /**
   * The maximum permitted result length in bytes for the GROUP_CONCAT() function.
   * minimum: 4
   * maximum: -1
   * @return groupConcatMaxLen
  **/
  @javax.annotation.Nullable
  public Integer getGroupConcatMaxLen() {
    return groupConcatMaxLen;
  }

  public void setGroupConcatMaxLen(Integer groupConcatMaxLen) {
    this.groupConcatMaxLen = groupConcatMaxLen;
  }


  public JsonSchemaMysql netBufferLength(Integer netBufferLength) {
    this.netBufferLength = netBufferLength;
    return this;
  }

   /**
   * Start sizes of connection buffer and result buffer. Default is 16384 (16K). Changing this parameter will lead to a restart of the MySQL service.
   * minimum: 1024
   * maximum: 1048576
   * @return netBufferLength
  **/
  @javax.annotation.Nullable
  public Integer getNetBufferLength() {
    return netBufferLength;
  }

  public void setNetBufferLength(Integer netBufferLength) {
    this.netBufferLength = netBufferLength;
  }


  public JsonSchemaMysql innodbPrintAllDeadlocks(Boolean innodbPrintAllDeadlocks) {
    this.innodbPrintAllDeadlocks = innodbPrintAllDeadlocks;
    return this;
  }

   /**
   * When enabled, information about all deadlocks in InnoDB user transactions is recorded in the error log. Disabled by default.
   * @return innodbPrintAllDeadlocks
  **/
  @javax.annotation.Nullable
  public Boolean getInnodbPrintAllDeadlocks() {
    return innodbPrintAllDeadlocks;
  }

  public void setInnodbPrintAllDeadlocks(Boolean innodbPrintAllDeadlocks) {
    this.innodbPrintAllDeadlocks = innodbPrintAllDeadlocks;
  }


  public JsonSchemaMysql innodbOnlineAlterLogMaxSize(Integer innodbOnlineAlterLogMaxSize) {
    this.innodbOnlineAlterLogMaxSize = innodbOnlineAlterLogMaxSize;
    return this;
  }

   /**
   * The upper limit in bytes on the size of the temporary log files used during online DDL operations for InnoDB tables.
   * minimum: 65536
   * maximum: 1099511627776
   * @return innodbOnlineAlterLogMaxSize
  **/
  @javax.annotation.Nullable
  public Integer getInnodbOnlineAlterLogMaxSize() {
    return innodbOnlineAlterLogMaxSize;
  }

  public void setInnodbOnlineAlterLogMaxSize(Integer innodbOnlineAlterLogMaxSize) {
    this.innodbOnlineAlterLogMaxSize = innodbOnlineAlterLogMaxSize;
  }


  public JsonSchemaMysql interactiveTimeout(Integer interactiveTimeout) {
    this.interactiveTimeout = interactiveTimeout;
    return this;
  }

   /**
   * The number of seconds the server waits for activity on an interactive connection before closing it.
   * minimum: 30
   * maximum: 604800
   * @return interactiveTimeout
  **/
  @javax.annotation.Nullable
  public Integer getInteractiveTimeout() {
    return interactiveTimeout;
  }

  public void setInteractiveTimeout(Integer interactiveTimeout) {
    this.interactiveTimeout = interactiveTimeout;
  }


  public JsonSchemaMysql innodbLogBufferSize(Integer innodbLogBufferSize) {
    this.innodbLogBufferSize = innodbLogBufferSize;
    return this;
  }

   /**
   * The size in bytes of the buffer that InnoDB uses to write to the log files on disk.
   * minimum: 1048576
   * maximum: 4294967295
   * @return innodbLogBufferSize
  **/
  @javax.annotation.Nullable
  public Integer getInnodbLogBufferSize() {
    return innodbLogBufferSize;
  }

  public void setInnodbLogBufferSize(Integer innodbLogBufferSize) {
    this.innodbLogBufferSize = innodbLogBufferSize;
  }


  public JsonSchemaMysql maxAllowedPacket(Integer maxAllowedPacket) {
    this.maxAllowedPacket = maxAllowedPacket;
    return this;
  }

   /**
   * Size of the largest message in bytes that can be received by the server. Default is 67108864 (64M)
   * minimum: 102400
   * maximum: 1073741824
   * @return maxAllowedPacket
  **/
  @javax.annotation.Nullable
  public Integer getMaxAllowedPacket() {
    return maxAllowedPacket;
  }

  public void setMaxAllowedPacket(Integer maxAllowedPacket) {
    this.maxAllowedPacket = maxAllowedPacket;
  }


  public JsonSchemaMysql maxHeapTableSize(Integer maxHeapTableSize) {
    this.maxHeapTableSize = maxHeapTableSize;
    return this;
  }

   /**
   * Limits the size of internal in-memory tables. Also set tmp_table_size. Default is 16777216 (16M)
   * minimum: 1048576
   * maximum: 1073741824
   * @return maxHeapTableSize
  **/
  @javax.annotation.Nullable
  public Integer getMaxHeapTableSize() {
    return maxHeapTableSize;
  }

  public void setMaxHeapTableSize(Integer maxHeapTableSize) {
    this.maxHeapTableSize = maxHeapTableSize;
  }


  public JsonSchemaMysql innodbFtServerStopwordTable(String innodbFtServerStopwordTable) {
    this.innodbFtServerStopwordTable = innodbFtServerStopwordTable;
    return this;
  }

   /**
   * This option is used to specify your own InnoDB FULLTEXT index stopword list for all InnoDB tables.
   * @return innodbFtServerStopwordTable
  **/
  @javax.annotation.Nullable
  public String getInnodbFtServerStopwordTable() {
    return innodbFtServerStopwordTable;
  }

  public void setInnodbFtServerStopwordTable(String innodbFtServerStopwordTable) {
    this.innodbFtServerStopwordTable = innodbFtServerStopwordTable;
  }


  public JsonSchemaMysql innodbReadIoThreads(Integer innodbReadIoThreads) {
    this.innodbReadIoThreads = innodbReadIoThreads;
    return this;
  }

   /**
   * The number of I/O threads for read operations in InnoDB. Default is 4. Changing this parameter will lead to a restart of the MySQL service.
   * minimum: 1
   * maximum: 64
   * @return innodbReadIoThreads
  **/
  @javax.annotation.Nullable
  public Integer getInnodbReadIoThreads() {
    return innodbReadIoThreads;
  }

  public void setInnodbReadIoThreads(Integer innodbReadIoThreads) {
    this.innodbReadIoThreads = innodbReadIoThreads;
  }


  public JsonSchemaMysql sqlRequirePrimaryKey(Boolean sqlRequirePrimaryKey) {
    this.sqlRequirePrimaryKey = sqlRequirePrimaryKey;
    return this;
  }

   /**
   * Require primary key to be defined for new tables or old tables modified with ALTER TABLE and fail if missing. It is recommended to always have primary keys because various functionality may break if any large table is missing them.
   * @return sqlRequirePrimaryKey
  **/
  @javax.annotation.Nullable
  public Boolean getSqlRequirePrimaryKey() {
    return sqlRequirePrimaryKey;
  }

  public void setSqlRequirePrimaryKey(Boolean sqlRequirePrimaryKey) {
    this.sqlRequirePrimaryKey = sqlRequirePrimaryKey;
  }


  public JsonSchemaMysql defaultTimeZone(String defaultTimeZone) {
    this.defaultTimeZone = defaultTimeZone;
    return this;
  }

   /**
   * Default server time zone as an offset from UTC (from -12:00 to +12:00), a time zone name, or &#39;SYSTEM&#39; to use the MySQL server default.
   * @return defaultTimeZone
  **/
  @javax.annotation.Nullable
  public String getDefaultTimeZone() {
    return defaultTimeZone;
  }

  public void setDefaultTimeZone(String defaultTimeZone) {
    this.defaultTimeZone = defaultTimeZone;
  }


  public JsonSchemaMysql longQueryTime(BigDecimal longQueryTime) {
    this.longQueryTime = longQueryTime;
    return this;
  }

   /**
   * The slow_query_logs work as SQL statements that take more than long_query_time seconds to execute. Default is 10s
   * minimum: 0.0
   * maximum: 3600
   * @return longQueryTime
  **/
  @javax.annotation.Nullable
  public BigDecimal getLongQueryTime() {
    return longQueryTime;
  }

  public void setLongQueryTime(BigDecimal longQueryTime) {
    this.longQueryTime = longQueryTime;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    JsonSchemaMysql jsonSchemaMysql = (JsonSchemaMysql) o;
    return Objects.equals(this.netWriteTimeout, jsonSchemaMysql.netWriteTimeout) &&
        Objects.equals(this.internalTmpMemStorageEngine, jsonSchemaMysql.internalTmpMemStorageEngine) &&
        Objects.equals(this.sqlMode, jsonSchemaMysql.sqlMode) &&
        Objects.equals(this.informationSchemaStatsExpiry, jsonSchemaMysql.informationSchemaStatsExpiry) &&
        Objects.equals(this.sortBufferSize, jsonSchemaMysql.sortBufferSize) &&
        Objects.equals(this.innodbThreadConcurrency, jsonSchemaMysql.innodbThreadConcurrency) &&
        Objects.equals(this.innodbWriteIoThreads, jsonSchemaMysql.innodbWriteIoThreads) &&
        Objects.equals(this.innodbFtMinTokenSize, jsonSchemaMysql.innodbFtMinTokenSize) &&
        Objects.equals(this.innodbChangeBufferMaxSize, jsonSchemaMysql.innodbChangeBufferMaxSize) &&
        Objects.equals(this.innodbFlushNeighbors, jsonSchemaMysql.innodbFlushNeighbors) &&
        Objects.equals(this.tmpTableSize, jsonSchemaMysql.tmpTableSize) &&
        Objects.equals(this.slowQueryLog, jsonSchemaMysql.slowQueryLog) &&
        Objects.equals(this.connectTimeout, jsonSchemaMysql.connectTimeout) &&
        Objects.equals(this.netReadTimeout, jsonSchemaMysql.netReadTimeout) &&
        Objects.equals(this.innodbLockWaitTimeout, jsonSchemaMysql.innodbLockWaitTimeout) &&
        Objects.equals(this.waitTimeout, jsonSchemaMysql.waitTimeout) &&
        Objects.equals(this.innodbRollbackOnTimeout, jsonSchemaMysql.innodbRollbackOnTimeout) &&
        Objects.equals(this.groupConcatMaxLen, jsonSchemaMysql.groupConcatMaxLen) &&
        Objects.equals(this.netBufferLength, jsonSchemaMysql.netBufferLength) &&
        Objects.equals(this.innodbPrintAllDeadlocks, jsonSchemaMysql.innodbPrintAllDeadlocks) &&
        Objects.equals(this.innodbOnlineAlterLogMaxSize, jsonSchemaMysql.innodbOnlineAlterLogMaxSize) &&
        Objects.equals(this.interactiveTimeout, jsonSchemaMysql.interactiveTimeout) &&
        Objects.equals(this.innodbLogBufferSize, jsonSchemaMysql.innodbLogBufferSize) &&
        Objects.equals(this.maxAllowedPacket, jsonSchemaMysql.maxAllowedPacket) &&
        Objects.equals(this.maxHeapTableSize, jsonSchemaMysql.maxHeapTableSize) &&
        Objects.equals(this.innodbFtServerStopwordTable, jsonSchemaMysql.innodbFtServerStopwordTable) &&
        Objects.equals(this.innodbReadIoThreads, jsonSchemaMysql.innodbReadIoThreads) &&
        Objects.equals(this.sqlRequirePrimaryKey, jsonSchemaMysql.sqlRequirePrimaryKey) &&
        Objects.equals(this.defaultTimeZone, jsonSchemaMysql.defaultTimeZone) &&
        Objects.equals(this.longQueryTime, jsonSchemaMysql.longQueryTime);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(netWriteTimeout, internalTmpMemStorageEngine, sqlMode, informationSchemaStatsExpiry, sortBufferSize, innodbThreadConcurrency, innodbWriteIoThreads, innodbFtMinTokenSize, innodbChangeBufferMaxSize, innodbFlushNeighbors, tmpTableSize, slowQueryLog, connectTimeout, netReadTimeout, innodbLockWaitTimeout, waitTimeout, innodbRollbackOnTimeout, groupConcatMaxLen, netBufferLength, innodbPrintAllDeadlocks, innodbOnlineAlterLogMaxSize, interactiveTimeout, innodbLogBufferSize, maxAllowedPacket, maxHeapTableSize, innodbFtServerStopwordTable, innodbReadIoThreads, sqlRequirePrimaryKey, defaultTimeZone, longQueryTime);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class JsonSchemaMysql {\n");
    sb.append("    netWriteTimeout: ").append(toIndentedString(netWriteTimeout)).append("\n");
    sb.append("    internalTmpMemStorageEngine: ").append(toIndentedString(internalTmpMemStorageEngine)).append("\n");
    sb.append("    sqlMode: ").append(toIndentedString(sqlMode)).append("\n");
    sb.append("    informationSchemaStatsExpiry: ").append(toIndentedString(informationSchemaStatsExpiry)).append("\n");
    sb.append("    sortBufferSize: ").append(toIndentedString(sortBufferSize)).append("\n");
    sb.append("    innodbThreadConcurrency: ").append(toIndentedString(innodbThreadConcurrency)).append("\n");
    sb.append("    innodbWriteIoThreads: ").append(toIndentedString(innodbWriteIoThreads)).append("\n");
    sb.append("    innodbFtMinTokenSize: ").append(toIndentedString(innodbFtMinTokenSize)).append("\n");
    sb.append("    innodbChangeBufferMaxSize: ").append(toIndentedString(innodbChangeBufferMaxSize)).append("\n");
    sb.append("    innodbFlushNeighbors: ").append(toIndentedString(innodbFlushNeighbors)).append("\n");
    sb.append("    tmpTableSize: ").append(toIndentedString(tmpTableSize)).append("\n");
    sb.append("    slowQueryLog: ").append(toIndentedString(slowQueryLog)).append("\n");
    sb.append("    connectTimeout: ").append(toIndentedString(connectTimeout)).append("\n");
    sb.append("    netReadTimeout: ").append(toIndentedString(netReadTimeout)).append("\n");
    sb.append("    innodbLockWaitTimeout: ").append(toIndentedString(innodbLockWaitTimeout)).append("\n");
    sb.append("    waitTimeout: ").append(toIndentedString(waitTimeout)).append("\n");
    sb.append("    innodbRollbackOnTimeout: ").append(toIndentedString(innodbRollbackOnTimeout)).append("\n");
    sb.append("    groupConcatMaxLen: ").append(toIndentedString(groupConcatMaxLen)).append("\n");
    sb.append("    netBufferLength: ").append(toIndentedString(netBufferLength)).append("\n");
    sb.append("    innodbPrintAllDeadlocks: ").append(toIndentedString(innodbPrintAllDeadlocks)).append("\n");
    sb.append("    innodbOnlineAlterLogMaxSize: ").append(toIndentedString(innodbOnlineAlterLogMaxSize)).append("\n");
    sb.append("    interactiveTimeout: ").append(toIndentedString(interactiveTimeout)).append("\n");
    sb.append("    innodbLogBufferSize: ").append(toIndentedString(innodbLogBufferSize)).append("\n");
    sb.append("    maxAllowedPacket: ").append(toIndentedString(maxAllowedPacket)).append("\n");
    sb.append("    maxHeapTableSize: ").append(toIndentedString(maxHeapTableSize)).append("\n");
    sb.append("    innodbFtServerStopwordTable: ").append(toIndentedString(innodbFtServerStopwordTable)).append("\n");
    sb.append("    innodbReadIoThreads: ").append(toIndentedString(innodbReadIoThreads)).append("\n");
    sb.append("    sqlRequirePrimaryKey: ").append(toIndentedString(sqlRequirePrimaryKey)).append("\n");
    sb.append("    defaultTimeZone: ").append(toIndentedString(defaultTimeZone)).append("\n");
    sb.append("    longQueryTime: ").append(toIndentedString(longQueryTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("net_write_timeout");
    openapiFields.add("internal_tmp_mem_storage_engine");
    openapiFields.add("sql_mode");
    openapiFields.add("information_schema_stats_expiry");
    openapiFields.add("sort_buffer_size");
    openapiFields.add("innodb_thread_concurrency");
    openapiFields.add("innodb_write_io_threads");
    openapiFields.add("innodb_ft_min_token_size");
    openapiFields.add("innodb_change_buffer_max_size");
    openapiFields.add("innodb_flush_neighbors");
    openapiFields.add("tmp_table_size");
    openapiFields.add("slow_query_log");
    openapiFields.add("connect_timeout");
    openapiFields.add("net_read_timeout");
    openapiFields.add("innodb_lock_wait_timeout");
    openapiFields.add("wait_timeout");
    openapiFields.add("innodb_rollback_on_timeout");
    openapiFields.add("group_concat_max_len");
    openapiFields.add("net_buffer_length");
    openapiFields.add("innodb_print_all_deadlocks");
    openapiFields.add("innodb_online_alter_log_max_size");
    openapiFields.add("interactive_timeout");
    openapiFields.add("innodb_log_buffer_size");
    openapiFields.add("max_allowed_packet");
    openapiFields.add("max_heap_table_size");
    openapiFields.add("innodb_ft_server_stopword_table");
    openapiFields.add("innodb_read_io_threads");
    openapiFields.add("sql_require_primary_key");
    openapiFields.add("default_time_zone");
    openapiFields.add("long_query_time");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to JsonSchemaMysql
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!JsonSchemaMysql.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in JsonSchemaMysql is not found in the empty JSON string", JsonSchemaMysql.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!JsonSchemaMysql.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `JsonSchemaMysql` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("internal_tmp_mem_storage_engine") != null && !jsonObj.get("internal_tmp_mem_storage_engine").isJsonNull()) && !jsonObj.get("internal_tmp_mem_storage_engine").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `internal_tmp_mem_storage_engine` to be a primitive type in the JSON string but got `%s`", jsonObj.get("internal_tmp_mem_storage_engine").toString()));
      }
      // validate the optional field `internal_tmp_mem_storage_engine`
      if (jsonObj.get("internal_tmp_mem_storage_engine") != null && !jsonObj.get("internal_tmp_mem_storage_engine").isJsonNull()) {
        InternalTmpMemStorageEngineEnum.validateJsonElement(jsonObj.get("internal_tmp_mem_storage_engine"));
      }
      if ((jsonObj.get("sql_mode") != null && !jsonObj.get("sql_mode").isJsonNull()) && !jsonObj.get("sql_mode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sql_mode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sql_mode").toString()));
      }
      if ((jsonObj.get("innodb_ft_server_stopword_table") != null && !jsonObj.get("innodb_ft_server_stopword_table").isJsonNull()) && !jsonObj.get("innodb_ft_server_stopword_table").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `innodb_ft_server_stopword_table` to be a primitive type in the JSON string but got `%s`", jsonObj.get("innodb_ft_server_stopword_table").toString()));
      }
      if ((jsonObj.get("default_time_zone") != null && !jsonObj.get("default_time_zone").isJsonNull()) && !jsonObj.get("default_time_zone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `default_time_zone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("default_time_zone").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!JsonSchemaMysql.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'JsonSchemaMysql' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<JsonSchemaMysql> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(JsonSchemaMysql.class));

       return (TypeAdapter<T>) new TypeAdapter<JsonSchemaMysql>() {
           @Override
           public void write(JsonWriter out, JsonSchemaMysql value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public JsonSchemaMysql read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of JsonSchemaMysql given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of JsonSchemaMysql
  * @throws IOException if the JSON string is invalid with respect to JsonSchemaMysql
  */
  public static JsonSchemaMysql fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, JsonSchemaMysql.class);
  }

 /**
  * Convert an instance of JsonSchemaMysql to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

