/*
 * ExoscalePublicAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.exoscale.apichgva2.models;

import com.fasterxml.jackson.annotation.JsonGetter;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonSetter;

/**
 * This is a model class for KafkaBrokerConfigurationValues type.
 */
public class KafkaBrokerConfigurationValues {
    private String saslOauthbearerExpectedAudience;
    private Integer groupMaxSessionTimeoutMs;
    private Long logFlushIntervalMessages;
    private String saslOauthbearerJwksEndpointUrl;
    private Integer maxConnectionsPerIp;
    private String saslOauthbearerExpectedIssuer;
    private Integer logIndexSizeMaxBytes;
    private Boolean autoCreateTopicsEnable;
    private Integer logIndexIntervalBytes;
    private Integer replicaFetchMaxBytes;
    private Integer numPartitions;
    private Integer transactionStateLogSegmentBytes;
    private Integer replicaFetchResponseMaxBytes;
    private LogMessageTimestampTypeEnum logMessageTimestampType;
    private Integer connectionsMaxIdleMs;
    private Integer logFlushIntervalMs;
    private Boolean logPreallocate;
    private Integer logSegmentDeleteDelayMs;
    private Integer messageMaxBytes;
    private Integer groupInitialRebalanceDelayMs;
    private Integer logLocalRetentionBytes;
    private Integer logRollJitterMs;
    private Integer transactionRemoveExpiredTransactionCleanupIntervalMs;
    private Integer defaultReplicationFactor;
    private Integer logRollMs;
    private Integer producerPurgatoryPurgeIntervalRequests;
    private Integer logRetentionBytes;
    private Integer minInsyncReplicas;
    private CompressionTypeEnum compressionType;
    private Integer logMessageTimestampDifferenceMaxMs;
    private Integer logLocalRetentionMs;
    private Boolean logMessageDownconversionEnable;
    private String saslOauthbearerSubClaimName;
    private Integer maxIncrementalFetchSessionCacheSlots;
    private Integer logRetentionHours;
    private Integer groupMinSessionTimeoutMs;
    private Integer socketRequestMaxBytes;
    private Integer logSegmentBytes;
    private ConfigureLogCleanerForTopicCompaction logCleanupAndCompaction;
    private Integer offsetsRetentionMinutes;
    private Integer logRetentionMs;

    /**
     * Default constructor.
     */
    public KafkaBrokerConfigurationValues() {
    }

    /**
     * Initialization constructor.
     * @param  saslOauthbearerExpectedAudience  String value for saslOauthbearerExpectedAudience.
     * @param  groupMaxSessionTimeoutMs  Integer value for groupMaxSessionTimeoutMs.
     * @param  logFlushIntervalMessages  Long value for logFlushIntervalMessages.
     * @param  saslOauthbearerJwksEndpointUrl  String value for saslOauthbearerJwksEndpointUrl.
     * @param  maxConnectionsPerIp  Integer value for maxConnectionsPerIp.
     * @param  saslOauthbearerExpectedIssuer  String value for saslOauthbearerExpectedIssuer.
     * @param  logIndexSizeMaxBytes  Integer value for logIndexSizeMaxBytes.
     * @param  autoCreateTopicsEnable  Boolean value for autoCreateTopicsEnable.
     * @param  logIndexIntervalBytes  Integer value for logIndexIntervalBytes.
     * @param  replicaFetchMaxBytes  Integer value for replicaFetchMaxBytes.
     * @param  numPartitions  Integer value for numPartitions.
     * @param  transactionStateLogSegmentBytes  Integer value for transactionStateLogSegmentBytes.
     * @param  replicaFetchResponseMaxBytes  Integer value for replicaFetchResponseMaxBytes.
     * @param  logMessageTimestampType  LogMessageTimestampTypeEnum value for
     *         logMessageTimestampType.
     * @param  connectionsMaxIdleMs  Integer value for connectionsMaxIdleMs.
     * @param  logFlushIntervalMs  Integer value for logFlushIntervalMs.
     * @param  logPreallocate  Boolean value for logPreallocate.
     * @param  logSegmentDeleteDelayMs  Integer value for logSegmentDeleteDelayMs.
     * @param  messageMaxBytes  Integer value for messageMaxBytes.
     * @param  groupInitialRebalanceDelayMs  Integer value for groupInitialRebalanceDelayMs.
     * @param  logLocalRetentionBytes  Integer value for logLocalRetentionBytes.
     * @param  logRollJitterMs  Integer value for logRollJitterMs.
     * @param  transactionRemoveExpiredTransactionCleanupIntervalMs  Integer value for
     *         transactionRemoveExpiredTransactionCleanupIntervalMs.
     * @param  defaultReplicationFactor  Integer value for defaultReplicationFactor.
     * @param  logRollMs  Integer value for logRollMs.
     * @param  producerPurgatoryPurgeIntervalRequests  Integer value for
     *         producerPurgatoryPurgeIntervalRequests.
     * @param  logRetentionBytes  Integer value for logRetentionBytes.
     * @param  minInsyncReplicas  Integer value for minInsyncReplicas.
     * @param  compressionType  CompressionTypeEnum value for compressionType.
     * @param  logMessageTimestampDifferenceMaxMs  Integer value for
     *         logMessageTimestampDifferenceMaxMs.
     * @param  logLocalRetentionMs  Integer value for logLocalRetentionMs.
     * @param  logMessageDownconversionEnable  Boolean value for logMessageDownconversionEnable.
     * @param  saslOauthbearerSubClaimName  String value for saslOauthbearerSubClaimName.
     * @param  maxIncrementalFetchSessionCacheSlots  Integer value for
     *         maxIncrementalFetchSessionCacheSlots.
     * @param  logRetentionHours  Integer value for logRetentionHours.
     * @param  groupMinSessionTimeoutMs  Integer value for groupMinSessionTimeoutMs.
     * @param  socketRequestMaxBytes  Integer value for socketRequestMaxBytes.
     * @param  logSegmentBytes  Integer value for logSegmentBytes.
     * @param  logCleanupAndCompaction  ConfigureLogCleanerForTopicCompaction value for
     *         logCleanupAndCompaction.
     * @param  offsetsRetentionMinutes  Integer value for offsetsRetentionMinutes.
     * @param  logRetentionMs  Integer value for logRetentionMs.
     */
    public KafkaBrokerConfigurationValues(
            String saslOauthbearerExpectedAudience,
            Integer groupMaxSessionTimeoutMs,
            Long logFlushIntervalMessages,
            String saslOauthbearerJwksEndpointUrl,
            Integer maxConnectionsPerIp,
            String saslOauthbearerExpectedIssuer,
            Integer logIndexSizeMaxBytes,
            Boolean autoCreateTopicsEnable,
            Integer logIndexIntervalBytes,
            Integer replicaFetchMaxBytes,
            Integer numPartitions,
            Integer transactionStateLogSegmentBytes,
            Integer replicaFetchResponseMaxBytes,
            LogMessageTimestampTypeEnum logMessageTimestampType,
            Integer connectionsMaxIdleMs,
            Integer logFlushIntervalMs,
            Boolean logPreallocate,
            Integer logSegmentDeleteDelayMs,
            Integer messageMaxBytes,
            Integer groupInitialRebalanceDelayMs,
            Integer logLocalRetentionBytes,
            Integer logRollJitterMs,
            Integer transactionRemoveExpiredTransactionCleanupIntervalMs,
            Integer defaultReplicationFactor,
            Integer logRollMs,
            Integer producerPurgatoryPurgeIntervalRequests,
            Integer logRetentionBytes,
            Integer minInsyncReplicas,
            CompressionTypeEnum compressionType,
            Integer logMessageTimestampDifferenceMaxMs,
            Integer logLocalRetentionMs,
            Boolean logMessageDownconversionEnable,
            String saslOauthbearerSubClaimName,
            Integer maxIncrementalFetchSessionCacheSlots,
            Integer logRetentionHours,
            Integer groupMinSessionTimeoutMs,
            Integer socketRequestMaxBytes,
            Integer logSegmentBytes,
            ConfigureLogCleanerForTopicCompaction logCleanupAndCompaction,
            Integer offsetsRetentionMinutes,
            Integer logRetentionMs) {
        this.saslOauthbearerExpectedAudience = saslOauthbearerExpectedAudience;
        this.groupMaxSessionTimeoutMs = groupMaxSessionTimeoutMs;
        this.logFlushIntervalMessages = logFlushIntervalMessages;
        this.saslOauthbearerJwksEndpointUrl = saslOauthbearerJwksEndpointUrl;
        this.maxConnectionsPerIp = maxConnectionsPerIp;
        this.saslOauthbearerExpectedIssuer = saslOauthbearerExpectedIssuer;
        this.logIndexSizeMaxBytes = logIndexSizeMaxBytes;
        this.autoCreateTopicsEnable = autoCreateTopicsEnable;
        this.logIndexIntervalBytes = logIndexIntervalBytes;
        this.replicaFetchMaxBytes = replicaFetchMaxBytes;
        this.numPartitions = numPartitions;
        this.transactionStateLogSegmentBytes = transactionStateLogSegmentBytes;
        this.replicaFetchResponseMaxBytes = replicaFetchResponseMaxBytes;
        this.logMessageTimestampType = logMessageTimestampType;
        this.connectionsMaxIdleMs = connectionsMaxIdleMs;
        this.logFlushIntervalMs = logFlushIntervalMs;
        this.logPreallocate = logPreallocate;
        this.logSegmentDeleteDelayMs = logSegmentDeleteDelayMs;
        this.messageMaxBytes = messageMaxBytes;
        this.groupInitialRebalanceDelayMs = groupInitialRebalanceDelayMs;
        this.logLocalRetentionBytes = logLocalRetentionBytes;
        this.logRollJitterMs = logRollJitterMs;
        this.transactionRemoveExpiredTransactionCleanupIntervalMs =
                transactionRemoveExpiredTransactionCleanupIntervalMs;
        this.defaultReplicationFactor = defaultReplicationFactor;
        this.logRollMs = logRollMs;
        this.producerPurgatoryPurgeIntervalRequests = producerPurgatoryPurgeIntervalRequests;
        this.logRetentionBytes = logRetentionBytes;
        this.minInsyncReplicas = minInsyncReplicas;
        this.compressionType = compressionType;
        this.logMessageTimestampDifferenceMaxMs = logMessageTimestampDifferenceMaxMs;
        this.logLocalRetentionMs = logLocalRetentionMs;
        this.logMessageDownconversionEnable = logMessageDownconversionEnable;
        this.saslOauthbearerSubClaimName = saslOauthbearerSubClaimName;
        this.maxIncrementalFetchSessionCacheSlots = maxIncrementalFetchSessionCacheSlots;
        this.logRetentionHours = logRetentionHours;
        this.groupMinSessionTimeoutMs = groupMinSessionTimeoutMs;
        this.socketRequestMaxBytes = socketRequestMaxBytes;
        this.logSegmentBytes = logSegmentBytes;
        this.logCleanupAndCompaction = logCleanupAndCompaction;
        this.offsetsRetentionMinutes = offsetsRetentionMinutes;
        this.logRetentionMs = logRetentionMs;
    }

    /**
     * Getter for SaslOauthbearerExpectedAudience.
     * The (optional) comma-delimited setting for the broker to use to verify that the JWT was
     * issued for one of the expected audiences.
     * @return Returns the String
     */
    @JsonGetter("sasl_oauthbearer_expected_audience")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public String getSaslOauthbearerExpectedAudience() {
        return saslOauthbearerExpectedAudience;
    }

    /**
     * Setter for SaslOauthbearerExpectedAudience.
     * The (optional) comma-delimited setting for the broker to use to verify that the JWT was
     * issued for one of the expected audiences.
     * @param saslOauthbearerExpectedAudience Value for String
     */
    @JsonSetter("sasl_oauthbearer_expected_audience")
    public void setSaslOauthbearerExpectedAudience(String saslOauthbearerExpectedAudience) {
        this.saslOauthbearerExpectedAudience = saslOauthbearerExpectedAudience;
    }

    /**
     * Getter for GroupMaxSessionTimeoutMs.
     * The maximum allowed session timeout for registered consumers. Longer timeouts give consumers
     * more time to process messages in between heartbeats at the cost of a longer time to detect
     * failures.
     * @return Returns the Integer
     */
    @JsonGetter("group_max_session_timeout_ms")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getGroupMaxSessionTimeoutMs() {
        return groupMaxSessionTimeoutMs;
    }

    /**
     * Setter for GroupMaxSessionTimeoutMs.
     * The maximum allowed session timeout for registered consumers. Longer timeouts give consumers
     * more time to process messages in between heartbeats at the cost of a longer time to detect
     * failures.
     * @param groupMaxSessionTimeoutMs Value for Integer
     */
    @JsonSetter("group_max_session_timeout_ms")
    public void setGroupMaxSessionTimeoutMs(Integer groupMaxSessionTimeoutMs) {
        this.groupMaxSessionTimeoutMs = groupMaxSessionTimeoutMs;
    }

    /**
     * Getter for LogFlushIntervalMessages.
     * The number of messages accumulated on a log partition before messages are flushed to disk
     * @return Returns the Long
     */
    @JsonGetter("log_flush_interval_messages")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Long getLogFlushIntervalMessages() {
        return logFlushIntervalMessages;
    }

    /**
     * Setter for LogFlushIntervalMessages.
     * The number of messages accumulated on a log partition before messages are flushed to disk
     * @param logFlushIntervalMessages Value for Long
     */
    @JsonSetter("log_flush_interval_messages")
    public void setLogFlushIntervalMessages(Long logFlushIntervalMessages) {
        this.logFlushIntervalMessages = logFlushIntervalMessages;
    }

    /**
     * Getter for SaslOauthbearerJwksEndpointUrl.
     * OIDC JWKS endpoint URL. By setting this the SASL SSL OAuth2/OIDC authentication is enabled.
     * See also other options for SASL OAuth2/OIDC.
     * @return Returns the String
     */
    @JsonGetter("sasl_oauthbearer_jwks_endpoint_url")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public String getSaslOauthbearerJwksEndpointUrl() {
        return saslOauthbearerJwksEndpointUrl;
    }

    /**
     * Setter for SaslOauthbearerJwksEndpointUrl.
     * OIDC JWKS endpoint URL. By setting this the SASL SSL OAuth2/OIDC authentication is enabled.
     * See also other options for SASL OAuth2/OIDC.
     * @param saslOauthbearerJwksEndpointUrl Value for String
     */
    @JsonSetter("sasl_oauthbearer_jwks_endpoint_url")
    public void setSaslOauthbearerJwksEndpointUrl(String saslOauthbearerJwksEndpointUrl) {
        this.saslOauthbearerJwksEndpointUrl = saslOauthbearerJwksEndpointUrl;
    }

    /**
     * Getter for MaxConnectionsPerIp.
     * The maximum number of connections allowed from each ip address (defaults to 2147483647).
     * @return Returns the Integer
     */
    @JsonGetter("max_connections_per_ip")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getMaxConnectionsPerIp() {
        return maxConnectionsPerIp;
    }

    /**
     * Setter for MaxConnectionsPerIp.
     * The maximum number of connections allowed from each ip address (defaults to 2147483647).
     * @param maxConnectionsPerIp Value for Integer
     */
    @JsonSetter("max_connections_per_ip")
    public void setMaxConnectionsPerIp(Integer maxConnectionsPerIp) {
        this.maxConnectionsPerIp = maxConnectionsPerIp;
    }

    /**
     * Getter for SaslOauthbearerExpectedIssuer.
     * Optional setting for the broker to use to verify that the JWT was created by the expected
     * issuer.
     * @return Returns the String
     */
    @JsonGetter("sasl_oauthbearer_expected_issuer")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public String getSaslOauthbearerExpectedIssuer() {
        return saslOauthbearerExpectedIssuer;
    }

    /**
     * Setter for SaslOauthbearerExpectedIssuer.
     * Optional setting for the broker to use to verify that the JWT was created by the expected
     * issuer.
     * @param saslOauthbearerExpectedIssuer Value for String
     */
    @JsonSetter("sasl_oauthbearer_expected_issuer")
    public void setSaslOauthbearerExpectedIssuer(String saslOauthbearerExpectedIssuer) {
        this.saslOauthbearerExpectedIssuer = saslOauthbearerExpectedIssuer;
    }

    /**
     * Getter for LogIndexSizeMaxBytes.
     * The maximum size in bytes of the offset index
     * @return Returns the Integer
     */
    @JsonGetter("log_index_size_max_bytes")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getLogIndexSizeMaxBytes() {
        return logIndexSizeMaxBytes;
    }

    /**
     * Setter for LogIndexSizeMaxBytes.
     * The maximum size in bytes of the offset index
     * @param logIndexSizeMaxBytes Value for Integer
     */
    @JsonSetter("log_index_size_max_bytes")
    public void setLogIndexSizeMaxBytes(Integer logIndexSizeMaxBytes) {
        this.logIndexSizeMaxBytes = logIndexSizeMaxBytes;
    }

    /**
     * Getter for AutoCreateTopicsEnable.
     * Enable auto creation of topics
     * @return Returns the Boolean
     */
    @JsonGetter("auto_create_topics_enable")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Boolean getAutoCreateTopicsEnable() {
        return autoCreateTopicsEnable;
    }

    /**
     * Setter for AutoCreateTopicsEnable.
     * Enable auto creation of topics
     * @param autoCreateTopicsEnable Value for Boolean
     */
    @JsonSetter("auto_create_topics_enable")
    public void setAutoCreateTopicsEnable(Boolean autoCreateTopicsEnable) {
        this.autoCreateTopicsEnable = autoCreateTopicsEnable;
    }

    /**
     * Getter for LogIndexIntervalBytes.
     * The interval with which Kafka adds an entry to the offset index
     * @return Returns the Integer
     */
    @JsonGetter("log_index_interval_bytes")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getLogIndexIntervalBytes() {
        return logIndexIntervalBytes;
    }

    /**
     * Setter for LogIndexIntervalBytes.
     * The interval with which Kafka adds an entry to the offset index
     * @param logIndexIntervalBytes Value for Integer
     */
    @JsonSetter("log_index_interval_bytes")
    public void setLogIndexIntervalBytes(Integer logIndexIntervalBytes) {
        this.logIndexIntervalBytes = logIndexIntervalBytes;
    }

    /**
     * Getter for ReplicaFetchMaxBytes.
     * The number of bytes of messages to attempt to fetch for each partition (defaults to 1048576).
     * This is not an absolute maximum, if the first record batch in the first non-empty partition
     * of the fetch is larger than this value, the record batch will still be returned to ensure
     * that progress can be made.
     * @return Returns the Integer
     */
    @JsonGetter("replica_fetch_max_bytes")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getReplicaFetchMaxBytes() {
        return replicaFetchMaxBytes;
    }

    /**
     * Setter for ReplicaFetchMaxBytes.
     * The number of bytes of messages to attempt to fetch for each partition (defaults to 1048576).
     * This is not an absolute maximum, if the first record batch in the first non-empty partition
     * of the fetch is larger than this value, the record batch will still be returned to ensure
     * that progress can be made.
     * @param replicaFetchMaxBytes Value for Integer
     */
    @JsonSetter("replica_fetch_max_bytes")
    public void setReplicaFetchMaxBytes(Integer replicaFetchMaxBytes) {
        this.replicaFetchMaxBytes = replicaFetchMaxBytes;
    }

    /**
     * Getter for NumPartitions.
     * Number of partitions for autocreated topics
     * @return Returns the Integer
     */
    @JsonGetter("num_partitions")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getNumPartitions() {
        return numPartitions;
    }

    /**
     * Setter for NumPartitions.
     * Number of partitions for autocreated topics
     * @param numPartitions Value for Integer
     */
    @JsonSetter("num_partitions")
    public void setNumPartitions(Integer numPartitions) {
        this.numPartitions = numPartitions;
    }

    /**
     * Getter for TransactionStateLogSegmentBytes.
     * The transaction topic segment bytes should be kept relatively small in order to facilitate
     * faster log compaction and cache loads (defaults to 104857600 (100 mebibytes)).
     * @return Returns the Integer
     */
    @JsonGetter("transaction_state_log_segment_bytes")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getTransactionStateLogSegmentBytes() {
        return transactionStateLogSegmentBytes;
    }

    /**
     * Setter for TransactionStateLogSegmentBytes.
     * The transaction topic segment bytes should be kept relatively small in order to facilitate
     * faster log compaction and cache loads (defaults to 104857600 (100 mebibytes)).
     * @param transactionStateLogSegmentBytes Value for Integer
     */
    @JsonSetter("transaction_state_log_segment_bytes")
    public void setTransactionStateLogSegmentBytes(Integer transactionStateLogSegmentBytes) {
        this.transactionStateLogSegmentBytes = transactionStateLogSegmentBytes;
    }

    /**
     * Getter for ReplicaFetchResponseMaxBytes.
     * Maximum bytes expected for the entire fetch response (defaults to 10485760). Records are
     * fetched in batches, and if the first record batch in the first non-empty partition of the
     * fetch is larger than this value, the record batch will still be returned to ensure that
     * progress can be made. As such, this is not an absolute maximum.
     * @return Returns the Integer
     */
    @JsonGetter("replica_fetch_response_max_bytes")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getReplicaFetchResponseMaxBytes() {
        return replicaFetchResponseMaxBytes;
    }

    /**
     * Setter for ReplicaFetchResponseMaxBytes.
     * Maximum bytes expected for the entire fetch response (defaults to 10485760). Records are
     * fetched in batches, and if the first record batch in the first non-empty partition of the
     * fetch is larger than this value, the record batch will still be returned to ensure that
     * progress can be made. As such, this is not an absolute maximum.
     * @param replicaFetchResponseMaxBytes Value for Integer
     */
    @JsonSetter("replica_fetch_response_max_bytes")
    public void setReplicaFetchResponseMaxBytes(Integer replicaFetchResponseMaxBytes) {
        this.replicaFetchResponseMaxBytes = replicaFetchResponseMaxBytes;
    }

    /**
     * Getter for LogMessageTimestampType.
     * Define whether the timestamp in the message is message create time or log append time.
     * @return Returns the LogMessageTimestampTypeEnum
     */
    @JsonGetter("log_message_timestamp_type")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public LogMessageTimestampTypeEnum getLogMessageTimestampType() {
        return logMessageTimestampType;
    }

    /**
     * Setter for LogMessageTimestampType.
     * Define whether the timestamp in the message is message create time or log append time.
     * @param logMessageTimestampType Value for LogMessageTimestampTypeEnum
     */
    @JsonSetter("log_message_timestamp_type")
    public void setLogMessageTimestampType(LogMessageTimestampTypeEnum logMessageTimestampType) {
        this.logMessageTimestampType = logMessageTimestampType;
    }

    /**
     * Getter for ConnectionsMaxIdleMs.
     * Idle connections timeout: the server socket processor threads close the connections that idle
     * for longer than this.
     * @return Returns the Integer
     */
    @JsonGetter("connections_max_idle_ms")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getConnectionsMaxIdleMs() {
        return connectionsMaxIdleMs;
    }

    /**
     * Setter for ConnectionsMaxIdleMs.
     * Idle connections timeout: the server socket processor threads close the connections that idle
     * for longer than this.
     * @param connectionsMaxIdleMs Value for Integer
     */
    @JsonSetter("connections_max_idle_ms")
    public void setConnectionsMaxIdleMs(Integer connectionsMaxIdleMs) {
        this.connectionsMaxIdleMs = connectionsMaxIdleMs;
    }

    /**
     * Getter for LogFlushIntervalMs.
     * The maximum time in ms that a message in any topic is kept in memory before flushed to disk.
     * If not set, the value in log.flush.scheduler.interval.ms is used
     * @return Returns the Integer
     */
    @JsonGetter("log_flush_interval_ms")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getLogFlushIntervalMs() {
        return logFlushIntervalMs;
    }

    /**
     * Setter for LogFlushIntervalMs.
     * The maximum time in ms that a message in any topic is kept in memory before flushed to disk.
     * If not set, the value in log.flush.scheduler.interval.ms is used
     * @param logFlushIntervalMs Value for Integer
     */
    @JsonSetter("log_flush_interval_ms")
    public void setLogFlushIntervalMs(Integer logFlushIntervalMs) {
        this.logFlushIntervalMs = logFlushIntervalMs;
    }

    /**
     * Getter for LogPreallocate.
     * Should pre allocate file when create new segment?
     * @return Returns the Boolean
     */
    @JsonGetter("log_preallocate")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Boolean getLogPreallocate() {
        return logPreallocate;
    }

    /**
     * Setter for LogPreallocate.
     * Should pre allocate file when create new segment?
     * @param logPreallocate Value for Boolean
     */
    @JsonSetter("log_preallocate")
    public void setLogPreallocate(Boolean logPreallocate) {
        this.logPreallocate = logPreallocate;
    }

    /**
     * Getter for LogSegmentDeleteDelayMs.
     * The amount of time to wait before deleting a file from the filesystem
     * @return Returns the Integer
     */
    @JsonGetter("log_segment_delete_delay_ms")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getLogSegmentDeleteDelayMs() {
        return logSegmentDeleteDelayMs;
    }

    /**
     * Setter for LogSegmentDeleteDelayMs.
     * The amount of time to wait before deleting a file from the filesystem
     * @param logSegmentDeleteDelayMs Value for Integer
     */
    @JsonSetter("log_segment_delete_delay_ms")
    public void setLogSegmentDeleteDelayMs(Integer logSegmentDeleteDelayMs) {
        this.logSegmentDeleteDelayMs = logSegmentDeleteDelayMs;
    }

    /**
     * Getter for MessageMaxBytes.
     * The maximum size of message that the server can receive.
     * @return Returns the Integer
     */
    @JsonGetter("message_max_bytes")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getMessageMaxBytes() {
        return messageMaxBytes;
    }

    /**
     * Setter for MessageMaxBytes.
     * The maximum size of message that the server can receive.
     * @param messageMaxBytes Value for Integer
     */
    @JsonSetter("message_max_bytes")
    public void setMessageMaxBytes(Integer messageMaxBytes) {
        this.messageMaxBytes = messageMaxBytes;
    }

    /**
     * Getter for GroupInitialRebalanceDelayMs.
     * The amount of time, in milliseconds, the group coordinator will wait for more consumers to
     * join a new group before performing the first rebalance. A longer delay means potentially
     * fewer rebalances, but increases the time until processing begins. The default value for this
     * is 3 seconds. During development and testing it might be desirable to set this to 0 in order
     * to not delay test execution time.
     * @return Returns the Integer
     */
    @JsonGetter("group_initial_rebalance_delay_ms")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getGroupInitialRebalanceDelayMs() {
        return groupInitialRebalanceDelayMs;
    }

    /**
     * Setter for GroupInitialRebalanceDelayMs.
     * The amount of time, in milliseconds, the group coordinator will wait for more consumers to
     * join a new group before performing the first rebalance. A longer delay means potentially
     * fewer rebalances, but increases the time until processing begins. The default value for this
     * is 3 seconds. During development and testing it might be desirable to set this to 0 in order
     * to not delay test execution time.
     * @param groupInitialRebalanceDelayMs Value for Integer
     */
    @JsonSetter("group_initial_rebalance_delay_ms")
    public void setGroupInitialRebalanceDelayMs(Integer groupInitialRebalanceDelayMs) {
        this.groupInitialRebalanceDelayMs = groupInitialRebalanceDelayMs;
    }

    /**
     * Getter for LogLocalRetentionBytes.
     * The maximum size of local log segments that can grow for a partition before it gets eligible
     * for deletion. If set to -2, the value of log.retention.bytes is used. The effective value
     * should always be less than or equal to log.retention.bytes value.
     * @return Returns the Integer
     */
    @JsonGetter("log_local_retention_bytes")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getLogLocalRetentionBytes() {
        return logLocalRetentionBytes;
    }

    /**
     * Setter for LogLocalRetentionBytes.
     * The maximum size of local log segments that can grow for a partition before it gets eligible
     * for deletion. If set to -2, the value of log.retention.bytes is used. The effective value
     * should always be less than or equal to log.retention.bytes value.
     * @param logLocalRetentionBytes Value for Integer
     */
    @JsonSetter("log_local_retention_bytes")
    public void setLogLocalRetentionBytes(Integer logLocalRetentionBytes) {
        this.logLocalRetentionBytes = logLocalRetentionBytes;
    }

    /**
     * Getter for LogRollJitterMs.
     * The maximum jitter to subtract from logRollTimeMillis (in milliseconds). If not set, the
     * value in log.roll.jitter.hours is used
     * @return Returns the Integer
     */
    @JsonGetter("log_roll_jitter_ms")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getLogRollJitterMs() {
        return logRollJitterMs;
    }

    /**
     * Setter for LogRollJitterMs.
     * The maximum jitter to subtract from logRollTimeMillis (in milliseconds). If not set, the
     * value in log.roll.jitter.hours is used
     * @param logRollJitterMs Value for Integer
     */
    @JsonSetter("log_roll_jitter_ms")
    public void setLogRollJitterMs(Integer logRollJitterMs) {
        this.logRollJitterMs = logRollJitterMs;
    }

    /**
     * Getter for TransactionRemoveExpiredTransactionCleanupIntervalMs.
     * The interval at which to remove transactions that have expired due to
     * transactional.id.expiration.ms passing (defaults to 3600000 (1 hour)).
     * @return Returns the Integer
     */
    @JsonGetter("transaction_remove_expired_transaction_cleanup_interval_ms")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getTransactionRemoveExpiredTransactionCleanupIntervalMs() {
        return transactionRemoveExpiredTransactionCleanupIntervalMs;
    }

    /**
     * Setter for TransactionRemoveExpiredTransactionCleanupIntervalMs.
     * The interval at which to remove transactions that have expired due to
     * transactional.id.expiration.ms passing (defaults to 3600000 (1 hour)).
     * @param transactionRemoveExpiredTransactionCleanupIntervalMs Value for Integer
     */
    @JsonSetter("transaction_remove_expired_transaction_cleanup_interval_ms")
    public void setTransactionRemoveExpiredTransactionCleanupIntervalMs(Integer transactionRemoveExpiredTransactionCleanupIntervalMs) {
        this.transactionRemoveExpiredTransactionCleanupIntervalMs = transactionRemoveExpiredTransactionCleanupIntervalMs;
    }

    /**
     * Getter for DefaultReplicationFactor.
     * Replication factor for autocreated topics
     * @return Returns the Integer
     */
    @JsonGetter("default_replication_factor")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getDefaultReplicationFactor() {
        return defaultReplicationFactor;
    }

    /**
     * Setter for DefaultReplicationFactor.
     * Replication factor for autocreated topics
     * @param defaultReplicationFactor Value for Integer
     */
    @JsonSetter("default_replication_factor")
    public void setDefaultReplicationFactor(Integer defaultReplicationFactor) {
        this.defaultReplicationFactor = defaultReplicationFactor;
    }

    /**
     * Getter for LogRollMs.
     * The maximum time before a new log segment is rolled out (in milliseconds).
     * @return Returns the Integer
     */
    @JsonGetter("log_roll_ms")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getLogRollMs() {
        return logRollMs;
    }

    /**
     * Setter for LogRollMs.
     * The maximum time before a new log segment is rolled out (in milliseconds).
     * @param logRollMs Value for Integer
     */
    @JsonSetter("log_roll_ms")
    public void setLogRollMs(Integer logRollMs) {
        this.logRollMs = logRollMs;
    }

    /**
     * Getter for ProducerPurgatoryPurgeIntervalRequests.
     * The purge interval (in number of requests) of the producer request purgatory(defaults to
     * 1000).
     * @return Returns the Integer
     */
    @JsonGetter("producer_purgatory_purge_interval_requests")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getProducerPurgatoryPurgeIntervalRequests() {
        return producerPurgatoryPurgeIntervalRequests;
    }

    /**
     * Setter for ProducerPurgatoryPurgeIntervalRequests.
     * The purge interval (in number of requests) of the producer request purgatory(defaults to
     * 1000).
     * @param producerPurgatoryPurgeIntervalRequests Value for Integer
     */
    @JsonSetter("producer_purgatory_purge_interval_requests")
    public void setProducerPurgatoryPurgeIntervalRequests(Integer producerPurgatoryPurgeIntervalRequests) {
        this.producerPurgatoryPurgeIntervalRequests = producerPurgatoryPurgeIntervalRequests;
    }

    /**
     * Getter for LogRetentionBytes.
     * The maximum size of the log before deleting messages
     * @return Returns the Integer
     */
    @JsonGetter("log_retention_bytes")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getLogRetentionBytes() {
        return logRetentionBytes;
    }

    /**
     * Setter for LogRetentionBytes.
     * The maximum size of the log before deleting messages
     * @param logRetentionBytes Value for Integer
     */
    @JsonSetter("log_retention_bytes")
    public void setLogRetentionBytes(Integer logRetentionBytes) {
        this.logRetentionBytes = logRetentionBytes;
    }

    /**
     * Getter for MinInsyncReplicas.
     * When a producer sets acks to 'all' (or '-1'), min.insync.replicas specifies the minimum
     * number of replicas that must acknowledge a write for the write to be considered successful.
     * @return Returns the Integer
     */
    @JsonGetter("min_insync_replicas")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getMinInsyncReplicas() {
        return minInsyncReplicas;
    }

    /**
     * Setter for MinInsyncReplicas.
     * When a producer sets acks to 'all' (or '-1'), min.insync.replicas specifies the minimum
     * number of replicas that must acknowledge a write for the write to be considered successful.
     * @param minInsyncReplicas Value for Integer
     */
    @JsonSetter("min_insync_replicas")
    public void setMinInsyncReplicas(Integer minInsyncReplicas) {
        this.minInsyncReplicas = minInsyncReplicas;
    }

    /**
     * Getter for CompressionType.
     * Specify the final compression type for a given topic. This configuration accepts the standard
     * compression codecs ('gzip', 'snappy', 'lz4', 'zstd'). It additionally accepts 'uncompressed'
     * which is equivalent to no compression; and 'producer' which means retain the original
     * compression codec set by the producer.
     * @return Returns the CompressionTypeEnum
     */
    @JsonGetter("compression_type")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public CompressionTypeEnum getCompressionType() {
        return compressionType;
    }

    /**
     * Setter for CompressionType.
     * Specify the final compression type for a given topic. This configuration accepts the standard
     * compression codecs ('gzip', 'snappy', 'lz4', 'zstd'). It additionally accepts 'uncompressed'
     * which is equivalent to no compression; and 'producer' which means retain the original
     * compression codec set by the producer.
     * @param compressionType Value for CompressionTypeEnum
     */
    @JsonSetter("compression_type")
    public void setCompressionType(CompressionTypeEnum compressionType) {
        this.compressionType = compressionType;
    }

    /**
     * Getter for LogMessageTimestampDifferenceMaxMs.
     * The maximum difference allowed between the timestamp when a broker receives a message and the
     * timestamp specified in the message
     * @return Returns the Integer
     */
    @JsonGetter("log_message_timestamp_difference_max_ms")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getLogMessageTimestampDifferenceMaxMs() {
        return logMessageTimestampDifferenceMaxMs;
    }

    /**
     * Setter for LogMessageTimestampDifferenceMaxMs.
     * The maximum difference allowed between the timestamp when a broker receives a message and the
     * timestamp specified in the message
     * @param logMessageTimestampDifferenceMaxMs Value for Integer
     */
    @JsonSetter("log_message_timestamp_difference_max_ms")
    public void setLogMessageTimestampDifferenceMaxMs(Integer logMessageTimestampDifferenceMaxMs) {
        this.logMessageTimestampDifferenceMaxMs = logMessageTimestampDifferenceMaxMs;
    }

    /**
     * Getter for LogLocalRetentionMs.
     * The number of milliseconds to keep the local log segments before it gets eligible for
     * deletion. If set to -2, the value of log.retention.ms is used. The effective value should
     * always be less than or equal to log.retention.ms value.
     * @return Returns the Integer
     */
    @JsonGetter("log_local_retention_ms")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getLogLocalRetentionMs() {
        return logLocalRetentionMs;
    }

    /**
     * Setter for LogLocalRetentionMs.
     * The number of milliseconds to keep the local log segments before it gets eligible for
     * deletion. If set to -2, the value of log.retention.ms is used. The effective value should
     * always be less than or equal to log.retention.ms value.
     * @param logLocalRetentionMs Value for Integer
     */
    @JsonSetter("log_local_retention_ms")
    public void setLogLocalRetentionMs(Integer logLocalRetentionMs) {
        this.logLocalRetentionMs = logLocalRetentionMs;
    }

    /**
     * Getter for LogMessageDownconversionEnable.
     * This configuration controls whether down-conversion of message formats is enabled to satisfy
     * consume requests.
     * @return Returns the Boolean
     */
    @JsonGetter("log_message_downconversion_enable")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Boolean getLogMessageDownconversionEnable() {
        return logMessageDownconversionEnable;
    }

    /**
     * Setter for LogMessageDownconversionEnable.
     * This configuration controls whether down-conversion of message formats is enabled to satisfy
     * consume requests.
     * @param logMessageDownconversionEnable Value for Boolean
     */
    @JsonSetter("log_message_downconversion_enable")
    public void setLogMessageDownconversionEnable(Boolean logMessageDownconversionEnable) {
        this.logMessageDownconversionEnable = logMessageDownconversionEnable;
    }

    /**
     * Getter for SaslOauthbearerSubClaimName.
     * Name of the scope from which to extract the subject claim from the JWT. Defaults to sub.
     * @return Returns the String
     */
    @JsonGetter("sasl_oauthbearer_sub_claim_name")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public String getSaslOauthbearerSubClaimName() {
        return saslOauthbearerSubClaimName;
    }

    /**
     * Setter for SaslOauthbearerSubClaimName.
     * Name of the scope from which to extract the subject claim from the JWT. Defaults to sub.
     * @param saslOauthbearerSubClaimName Value for String
     */
    @JsonSetter("sasl_oauthbearer_sub_claim_name")
    public void setSaslOauthbearerSubClaimName(String saslOauthbearerSubClaimName) {
        this.saslOauthbearerSubClaimName = saslOauthbearerSubClaimName;
    }

    /**
     * Getter for MaxIncrementalFetchSessionCacheSlots.
     * The maximum number of incremental fetch sessions that the broker will maintain.
     * @return Returns the Integer
     */
    @JsonGetter("max_incremental_fetch_session_cache_slots")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getMaxIncrementalFetchSessionCacheSlots() {
        return maxIncrementalFetchSessionCacheSlots;
    }

    /**
     * Setter for MaxIncrementalFetchSessionCacheSlots.
     * The maximum number of incremental fetch sessions that the broker will maintain.
     * @param maxIncrementalFetchSessionCacheSlots Value for Integer
     */
    @JsonSetter("max_incremental_fetch_session_cache_slots")
    public void setMaxIncrementalFetchSessionCacheSlots(Integer maxIncrementalFetchSessionCacheSlots) {
        this.maxIncrementalFetchSessionCacheSlots = maxIncrementalFetchSessionCacheSlots;
    }

    /**
     * Getter for LogRetentionHours.
     * The number of hours to keep a log file before deleting it
     * @return Returns the Integer
     */
    @JsonGetter("log_retention_hours")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getLogRetentionHours() {
        return logRetentionHours;
    }

    /**
     * Setter for LogRetentionHours.
     * The number of hours to keep a log file before deleting it
     * @param logRetentionHours Value for Integer
     */
    @JsonSetter("log_retention_hours")
    public void setLogRetentionHours(Integer logRetentionHours) {
        this.logRetentionHours = logRetentionHours;
    }

    /**
     * Getter for GroupMinSessionTimeoutMs.
     * The minimum allowed session timeout for registered consumers. Longer timeouts give consumers
     * more time to process messages in between heartbeats at the cost of a longer time to detect
     * failures.
     * @return Returns the Integer
     */
    @JsonGetter("group_min_session_timeout_ms")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getGroupMinSessionTimeoutMs() {
        return groupMinSessionTimeoutMs;
    }

    /**
     * Setter for GroupMinSessionTimeoutMs.
     * The minimum allowed session timeout for registered consumers. Longer timeouts give consumers
     * more time to process messages in between heartbeats at the cost of a longer time to detect
     * failures.
     * @param groupMinSessionTimeoutMs Value for Integer
     */
    @JsonSetter("group_min_session_timeout_ms")
    public void setGroupMinSessionTimeoutMs(Integer groupMinSessionTimeoutMs) {
        this.groupMinSessionTimeoutMs = groupMinSessionTimeoutMs;
    }

    /**
     * Getter for SocketRequestMaxBytes.
     * The maximum number of bytes in a socket request (defaults to 104857600).
     * @return Returns the Integer
     */
    @JsonGetter("socket_request_max_bytes")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getSocketRequestMaxBytes() {
        return socketRequestMaxBytes;
    }

    /**
     * Setter for SocketRequestMaxBytes.
     * The maximum number of bytes in a socket request (defaults to 104857600).
     * @param socketRequestMaxBytes Value for Integer
     */
    @JsonSetter("socket_request_max_bytes")
    public void setSocketRequestMaxBytes(Integer socketRequestMaxBytes) {
        this.socketRequestMaxBytes = socketRequestMaxBytes;
    }

    /**
     * Getter for LogSegmentBytes.
     * The maximum size of a single log file
     * @return Returns the Integer
     */
    @JsonGetter("log_segment_bytes")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getLogSegmentBytes() {
        return logSegmentBytes;
    }

    /**
     * Setter for LogSegmentBytes.
     * The maximum size of a single log file
     * @param logSegmentBytes Value for Integer
     */
    @JsonSetter("log_segment_bytes")
    public void setLogSegmentBytes(Integer logSegmentBytes) {
        this.logSegmentBytes = logSegmentBytes;
    }

    /**
     * Getter for LogCleanupAndCompaction.
     * @return Returns the ConfigureLogCleanerForTopicCompaction
     */
    @JsonGetter("log-cleanup-and-compaction")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public ConfigureLogCleanerForTopicCompaction getLogCleanupAndCompaction() {
        return logCleanupAndCompaction;
    }

    /**
     * Setter for LogCleanupAndCompaction.
     * @param logCleanupAndCompaction Value for ConfigureLogCleanerForTopicCompaction
     */
    @JsonSetter("log-cleanup-and-compaction")
    public void setLogCleanupAndCompaction(ConfigureLogCleanerForTopicCompaction logCleanupAndCompaction) {
        this.logCleanupAndCompaction = logCleanupAndCompaction;
    }

    /**
     * Getter for OffsetsRetentionMinutes.
     * Log retention window in minutes for offsets topic
     * @return Returns the Integer
     */
    @JsonGetter("offsets_retention_minutes")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getOffsetsRetentionMinutes() {
        return offsetsRetentionMinutes;
    }

    /**
     * Setter for OffsetsRetentionMinutes.
     * Log retention window in minutes for offsets topic
     * @param offsetsRetentionMinutes Value for Integer
     */
    @JsonSetter("offsets_retention_minutes")
    public void setOffsetsRetentionMinutes(Integer offsetsRetentionMinutes) {
        this.offsetsRetentionMinutes = offsetsRetentionMinutes;
    }

    /**
     * Getter for LogRetentionMs.
     * The number of milliseconds to keep a log file before deleting it (in milliseconds), If not
     * set, the value in log.retention.minutes is used. If set to -1, no time limit is applied.
     * @return Returns the Integer
     */
    @JsonGetter("log_retention_ms")
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public Integer getLogRetentionMs() {
        return logRetentionMs;
    }

    /**
     * Setter for LogRetentionMs.
     * The number of milliseconds to keep a log file before deleting it (in milliseconds), If not
     * set, the value in log.retention.minutes is used. If set to -1, no time limit is applied.
     * @param logRetentionMs Value for Integer
     */
    @JsonSetter("log_retention_ms")
    public void setLogRetentionMs(Integer logRetentionMs) {
        this.logRetentionMs = logRetentionMs;
    }

    /**
     * Converts this KafkaBrokerConfigurationValues into string format.
     * @return String representation of this class
     */
    @Override
    public String toString() {
        return "KafkaBrokerConfigurationValues [" + "saslOauthbearerExpectedAudience="
                + saslOauthbearerExpectedAudience + ", groupMaxSessionTimeoutMs="
                + groupMaxSessionTimeoutMs + ", logFlushIntervalMessages="
                + logFlushIntervalMessages + ", saslOauthbearerJwksEndpointUrl="
                + saslOauthbearerJwksEndpointUrl + ", maxConnectionsPerIp=" + maxConnectionsPerIp
                + ", saslOauthbearerExpectedIssuer=" + saslOauthbearerExpectedIssuer
                + ", logIndexSizeMaxBytes=" + logIndexSizeMaxBytes + ", autoCreateTopicsEnable="
                + autoCreateTopicsEnable + ", logIndexIntervalBytes=" + logIndexIntervalBytes
                + ", replicaFetchMaxBytes=" + replicaFetchMaxBytes + ", numPartitions="
                + numPartitions + ", transactionStateLogSegmentBytes="
                + transactionStateLogSegmentBytes + ", replicaFetchResponseMaxBytes="
                + replicaFetchResponseMaxBytes + ", logMessageTimestampType="
                + logMessageTimestampType + ", connectionsMaxIdleMs=" + connectionsMaxIdleMs
                + ", logFlushIntervalMs=" + logFlushIntervalMs + ", logPreallocate="
                + logPreallocate + ", logSegmentDeleteDelayMs=" + logSegmentDeleteDelayMs
                + ", messageMaxBytes=" + messageMaxBytes + ", groupInitialRebalanceDelayMs="
                + groupInitialRebalanceDelayMs + ", logLocalRetentionBytes="
                + logLocalRetentionBytes + ", logRollJitterMs=" + logRollJitterMs
                + ", transactionRemoveExpiredTransactionCleanupIntervalMs="
                + transactionRemoveExpiredTransactionCleanupIntervalMs
                + ", defaultReplicationFactor=" + defaultReplicationFactor + ", logRollMs="
                + logRollMs + ", producerPurgatoryPurgeIntervalRequests="
                + producerPurgatoryPurgeIntervalRequests + ", logRetentionBytes="
                + logRetentionBytes + ", minInsyncReplicas=" + minInsyncReplicas
                + ", compressionType=" + compressionType + ", logMessageTimestampDifferenceMaxMs="
                + logMessageTimestampDifferenceMaxMs + ", logLocalRetentionMs="
                + logLocalRetentionMs + ", logMessageDownconversionEnable="
                + logMessageDownconversionEnable + ", saslOauthbearerSubClaimName="
                + saslOauthbearerSubClaimName + ", maxIncrementalFetchSessionCacheSlots="
                + maxIncrementalFetchSessionCacheSlots + ", logRetentionHours=" + logRetentionHours
                + ", groupMinSessionTimeoutMs=" + groupMinSessionTimeoutMs
                + ", socketRequestMaxBytes=" + socketRequestMaxBytes + ", logSegmentBytes="
                + logSegmentBytes + ", logCleanupAndCompaction=" + logCleanupAndCompaction
                + ", offsetsRetentionMinutes=" + offsetsRetentionMinutes + ", logRetentionMs="
                + logRetentionMs + "]";
    }

    /**
     * Builds a new {@link KafkaBrokerConfigurationValues.Builder} object.
     * Creates the instance with the state of the current model.
     * @return a new {@link KafkaBrokerConfigurationValues.Builder} object
     */
    public Builder toBuilder() {
        Builder builder = new Builder()
                .saslOauthbearerExpectedAudience(getSaslOauthbearerExpectedAudience())
                .groupMaxSessionTimeoutMs(getGroupMaxSessionTimeoutMs())
                .logFlushIntervalMessages(getLogFlushIntervalMessages())
                .saslOauthbearerJwksEndpointUrl(getSaslOauthbearerJwksEndpointUrl())
                .maxConnectionsPerIp(getMaxConnectionsPerIp())
                .saslOauthbearerExpectedIssuer(getSaslOauthbearerExpectedIssuer())
                .logIndexSizeMaxBytes(getLogIndexSizeMaxBytes())
                .autoCreateTopicsEnable(getAutoCreateTopicsEnable())
                .logIndexIntervalBytes(getLogIndexIntervalBytes())
                .replicaFetchMaxBytes(getReplicaFetchMaxBytes())
                .numPartitions(getNumPartitions())
                .transactionStateLogSegmentBytes(getTransactionStateLogSegmentBytes())
                .replicaFetchResponseMaxBytes(getReplicaFetchResponseMaxBytes())
                .logMessageTimestampType(getLogMessageTimestampType())
                .connectionsMaxIdleMs(getConnectionsMaxIdleMs())
                .logFlushIntervalMs(getLogFlushIntervalMs())
                .logPreallocate(getLogPreallocate())
                .logSegmentDeleteDelayMs(getLogSegmentDeleteDelayMs())
                .messageMaxBytes(getMessageMaxBytes())
                .groupInitialRebalanceDelayMs(getGroupInitialRebalanceDelayMs())
                .logLocalRetentionBytes(getLogLocalRetentionBytes())
                .logRollJitterMs(getLogRollJitterMs())
                .transactionRemoveExpiredTransactionCleanupIntervalMs(getTransactionRemoveExpiredTransactionCleanupIntervalMs())
                .defaultReplicationFactor(getDefaultReplicationFactor())
                .logRollMs(getLogRollMs())
                .producerPurgatoryPurgeIntervalRequests(getProducerPurgatoryPurgeIntervalRequests())
                .logRetentionBytes(getLogRetentionBytes())
                .minInsyncReplicas(getMinInsyncReplicas())
                .compressionType(getCompressionType())
                .logMessageTimestampDifferenceMaxMs(getLogMessageTimestampDifferenceMaxMs())
                .logLocalRetentionMs(getLogLocalRetentionMs())
                .logMessageDownconversionEnable(getLogMessageDownconversionEnable())
                .saslOauthbearerSubClaimName(getSaslOauthbearerSubClaimName())
                .maxIncrementalFetchSessionCacheSlots(getMaxIncrementalFetchSessionCacheSlots())
                .logRetentionHours(getLogRetentionHours())
                .groupMinSessionTimeoutMs(getGroupMinSessionTimeoutMs())
                .socketRequestMaxBytes(getSocketRequestMaxBytes())
                .logSegmentBytes(getLogSegmentBytes())
                .logCleanupAndCompaction(getLogCleanupAndCompaction())
                .offsetsRetentionMinutes(getOffsetsRetentionMinutes())
                .logRetentionMs(getLogRetentionMs());
        return builder;
    }

    /**
     * Class to build instances of {@link KafkaBrokerConfigurationValues}.
     */
    public static class Builder {
        private String saslOauthbearerExpectedAudience;
        private Integer groupMaxSessionTimeoutMs;
        private Long logFlushIntervalMessages;
        private String saslOauthbearerJwksEndpointUrl;
        private Integer maxConnectionsPerIp;
        private String saslOauthbearerExpectedIssuer;
        private Integer logIndexSizeMaxBytes;
        private Boolean autoCreateTopicsEnable;
        private Integer logIndexIntervalBytes;
        private Integer replicaFetchMaxBytes;
        private Integer numPartitions;
        private Integer transactionStateLogSegmentBytes;
        private Integer replicaFetchResponseMaxBytes;
        private LogMessageTimestampTypeEnum logMessageTimestampType;
        private Integer connectionsMaxIdleMs;
        private Integer logFlushIntervalMs;
        private Boolean logPreallocate;
        private Integer logSegmentDeleteDelayMs;
        private Integer messageMaxBytes;
        private Integer groupInitialRebalanceDelayMs;
        private Integer logLocalRetentionBytes;
        private Integer logRollJitterMs;
        private Integer transactionRemoveExpiredTransactionCleanupIntervalMs;
        private Integer defaultReplicationFactor;
        private Integer logRollMs;
        private Integer producerPurgatoryPurgeIntervalRequests;
        private Integer logRetentionBytes;
        private Integer minInsyncReplicas;
        private CompressionTypeEnum compressionType;
        private Integer logMessageTimestampDifferenceMaxMs;
        private Integer logLocalRetentionMs;
        private Boolean logMessageDownconversionEnable;
        private String saslOauthbearerSubClaimName;
        private Integer maxIncrementalFetchSessionCacheSlots;
        private Integer logRetentionHours;
        private Integer groupMinSessionTimeoutMs;
        private Integer socketRequestMaxBytes;
        private Integer logSegmentBytes;
        private ConfigureLogCleanerForTopicCompaction logCleanupAndCompaction;
        private Integer offsetsRetentionMinutes;
        private Integer logRetentionMs;



        /**
         * Setter for saslOauthbearerExpectedAudience.
         * @param  saslOauthbearerExpectedAudience  String value for
         *         saslOauthbearerExpectedAudience.
         * @return Builder
         */
        public Builder saslOauthbearerExpectedAudience(String saslOauthbearerExpectedAudience) {
            this.saslOauthbearerExpectedAudience = saslOauthbearerExpectedAudience;
            return this;
        }

        /**
         * Setter for groupMaxSessionTimeoutMs.
         * @param  groupMaxSessionTimeoutMs  Integer value for groupMaxSessionTimeoutMs.
         * @return Builder
         */
        public Builder groupMaxSessionTimeoutMs(Integer groupMaxSessionTimeoutMs) {
            this.groupMaxSessionTimeoutMs = groupMaxSessionTimeoutMs;
            return this;
        }

        /**
         * Setter for logFlushIntervalMessages.
         * @param  logFlushIntervalMessages  Long value for logFlushIntervalMessages.
         * @return Builder
         */
        public Builder logFlushIntervalMessages(Long logFlushIntervalMessages) {
            this.logFlushIntervalMessages = logFlushIntervalMessages;
            return this;
        }

        /**
         * Setter for saslOauthbearerJwksEndpointUrl.
         * @param  saslOauthbearerJwksEndpointUrl  String value for saslOauthbearerJwksEndpointUrl.
         * @return Builder
         */
        public Builder saslOauthbearerJwksEndpointUrl(String saslOauthbearerJwksEndpointUrl) {
            this.saslOauthbearerJwksEndpointUrl = saslOauthbearerJwksEndpointUrl;
            return this;
        }

        /**
         * Setter for maxConnectionsPerIp.
         * @param  maxConnectionsPerIp  Integer value for maxConnectionsPerIp.
         * @return Builder
         */
        public Builder maxConnectionsPerIp(Integer maxConnectionsPerIp) {
            this.maxConnectionsPerIp = maxConnectionsPerIp;
            return this;
        }

        /**
         * Setter for saslOauthbearerExpectedIssuer.
         * @param  saslOauthbearerExpectedIssuer  String value for saslOauthbearerExpectedIssuer.
         * @return Builder
         */
        public Builder saslOauthbearerExpectedIssuer(String saslOauthbearerExpectedIssuer) {
            this.saslOauthbearerExpectedIssuer = saslOauthbearerExpectedIssuer;
            return this;
        }

        /**
         * Setter for logIndexSizeMaxBytes.
         * @param  logIndexSizeMaxBytes  Integer value for logIndexSizeMaxBytes.
         * @return Builder
         */
        public Builder logIndexSizeMaxBytes(Integer logIndexSizeMaxBytes) {
            this.logIndexSizeMaxBytes = logIndexSizeMaxBytes;
            return this;
        }

        /**
         * Setter for autoCreateTopicsEnable.
         * @param  autoCreateTopicsEnable  Boolean value for autoCreateTopicsEnable.
         * @return Builder
         */
        public Builder autoCreateTopicsEnable(Boolean autoCreateTopicsEnable) {
            this.autoCreateTopicsEnable = autoCreateTopicsEnable;
            return this;
        }

        /**
         * Setter for logIndexIntervalBytes.
         * @param  logIndexIntervalBytes  Integer value for logIndexIntervalBytes.
         * @return Builder
         */
        public Builder logIndexIntervalBytes(Integer logIndexIntervalBytes) {
            this.logIndexIntervalBytes = logIndexIntervalBytes;
            return this;
        }

        /**
         * Setter for replicaFetchMaxBytes.
         * @param  replicaFetchMaxBytes  Integer value for replicaFetchMaxBytes.
         * @return Builder
         */
        public Builder replicaFetchMaxBytes(Integer replicaFetchMaxBytes) {
            this.replicaFetchMaxBytes = replicaFetchMaxBytes;
            return this;
        }

        /**
         * Setter for numPartitions.
         * @param  numPartitions  Integer value for numPartitions.
         * @return Builder
         */
        public Builder numPartitions(Integer numPartitions) {
            this.numPartitions = numPartitions;
            return this;
        }

        /**
         * Setter for transactionStateLogSegmentBytes.
         * @param  transactionStateLogSegmentBytes  Integer value for
         *         transactionStateLogSegmentBytes.
         * @return Builder
         */
        public Builder transactionStateLogSegmentBytes(Integer transactionStateLogSegmentBytes) {
            this.transactionStateLogSegmentBytes = transactionStateLogSegmentBytes;
            return this;
        }

        /**
         * Setter for replicaFetchResponseMaxBytes.
         * @param  replicaFetchResponseMaxBytes  Integer value for replicaFetchResponseMaxBytes.
         * @return Builder
         */
        public Builder replicaFetchResponseMaxBytes(Integer replicaFetchResponseMaxBytes) {
            this.replicaFetchResponseMaxBytes = replicaFetchResponseMaxBytes;
            return this;
        }

        /**
         * Setter for logMessageTimestampType.
         * @param  logMessageTimestampType  LogMessageTimestampTypeEnum value for
         *         logMessageTimestampType.
         * @return Builder
         */
        public Builder logMessageTimestampType(
                LogMessageTimestampTypeEnum logMessageTimestampType) {
            this.logMessageTimestampType = logMessageTimestampType;
            return this;
        }

        /**
         * Setter for connectionsMaxIdleMs.
         * @param  connectionsMaxIdleMs  Integer value for connectionsMaxIdleMs.
         * @return Builder
         */
        public Builder connectionsMaxIdleMs(Integer connectionsMaxIdleMs) {
            this.connectionsMaxIdleMs = connectionsMaxIdleMs;
            return this;
        }

        /**
         * Setter for logFlushIntervalMs.
         * @param  logFlushIntervalMs  Integer value for logFlushIntervalMs.
         * @return Builder
         */
        public Builder logFlushIntervalMs(Integer logFlushIntervalMs) {
            this.logFlushIntervalMs = logFlushIntervalMs;
            return this;
        }

        /**
         * Setter for logPreallocate.
         * @param  logPreallocate  Boolean value for logPreallocate.
         * @return Builder
         */
        public Builder logPreallocate(Boolean logPreallocate) {
            this.logPreallocate = logPreallocate;
            return this;
        }

        /**
         * Setter for logSegmentDeleteDelayMs.
         * @param  logSegmentDeleteDelayMs  Integer value for logSegmentDeleteDelayMs.
         * @return Builder
         */
        public Builder logSegmentDeleteDelayMs(Integer logSegmentDeleteDelayMs) {
            this.logSegmentDeleteDelayMs = logSegmentDeleteDelayMs;
            return this;
        }

        /**
         * Setter for messageMaxBytes.
         * @param  messageMaxBytes  Integer value for messageMaxBytes.
         * @return Builder
         */
        public Builder messageMaxBytes(Integer messageMaxBytes) {
            this.messageMaxBytes = messageMaxBytes;
            return this;
        }

        /**
         * Setter for groupInitialRebalanceDelayMs.
         * @param  groupInitialRebalanceDelayMs  Integer value for groupInitialRebalanceDelayMs.
         * @return Builder
         */
        public Builder groupInitialRebalanceDelayMs(Integer groupInitialRebalanceDelayMs) {
            this.groupInitialRebalanceDelayMs = groupInitialRebalanceDelayMs;
            return this;
        }

        /**
         * Setter for logLocalRetentionBytes.
         * @param  logLocalRetentionBytes  Integer value for logLocalRetentionBytes.
         * @return Builder
         */
        public Builder logLocalRetentionBytes(Integer logLocalRetentionBytes) {
            this.logLocalRetentionBytes = logLocalRetentionBytes;
            return this;
        }

        /**
         * Setter for logRollJitterMs.
         * @param  logRollJitterMs  Integer value for logRollJitterMs.
         * @return Builder
         */
        public Builder logRollJitterMs(Integer logRollJitterMs) {
            this.logRollJitterMs = logRollJitterMs;
            return this;
        }

        /**
         * Setter for transactionRemoveExpiredTransactionCleanupIntervalMs.
         * @param  transactionRemoveExpiredTransactionCleanupIntervalMs  Integer value for
         *         transactionRemoveExpiredTransactionCleanupIntervalMs.
         * @return Builder
         */
        public Builder transactionRemoveExpiredTransactionCleanupIntervalMs(
                Integer transactionRemoveExpiredTransactionCleanupIntervalMs) {
            this.transactionRemoveExpiredTransactionCleanupIntervalMs =
                    transactionRemoveExpiredTransactionCleanupIntervalMs;
            return this;
        }

        /**
         * Setter for defaultReplicationFactor.
         * @param  defaultReplicationFactor  Integer value for defaultReplicationFactor.
         * @return Builder
         */
        public Builder defaultReplicationFactor(Integer defaultReplicationFactor) {
            this.defaultReplicationFactor = defaultReplicationFactor;
            return this;
        }

        /**
         * Setter for logRollMs.
         * @param  logRollMs  Integer value for logRollMs.
         * @return Builder
         */
        public Builder logRollMs(Integer logRollMs) {
            this.logRollMs = logRollMs;
            return this;
        }

        /**
         * Setter for producerPurgatoryPurgeIntervalRequests.
         * @param  producerPurgatoryPurgeIntervalRequests  Integer value for
         *         producerPurgatoryPurgeIntervalRequests.
         * @return Builder
         */
        public Builder producerPurgatoryPurgeIntervalRequests(
                Integer producerPurgatoryPurgeIntervalRequests) {
            this.producerPurgatoryPurgeIntervalRequests = producerPurgatoryPurgeIntervalRequests;
            return this;
        }

        /**
         * Setter for logRetentionBytes.
         * @param  logRetentionBytes  Integer value for logRetentionBytes.
         * @return Builder
         */
        public Builder logRetentionBytes(Integer logRetentionBytes) {
            this.logRetentionBytes = logRetentionBytes;
            return this;
        }

        /**
         * Setter for minInsyncReplicas.
         * @param  minInsyncReplicas  Integer value for minInsyncReplicas.
         * @return Builder
         */
        public Builder minInsyncReplicas(Integer minInsyncReplicas) {
            this.minInsyncReplicas = minInsyncReplicas;
            return this;
        }

        /**
         * Setter for compressionType.
         * @param  compressionType  CompressionTypeEnum value for compressionType.
         * @return Builder
         */
        public Builder compressionType(CompressionTypeEnum compressionType) {
            this.compressionType = compressionType;
            return this;
        }

        /**
         * Setter for logMessageTimestampDifferenceMaxMs.
         * @param  logMessageTimestampDifferenceMaxMs  Integer value for
         *         logMessageTimestampDifferenceMaxMs.
         * @return Builder
         */
        public Builder logMessageTimestampDifferenceMaxMs(
                Integer logMessageTimestampDifferenceMaxMs) {
            this.logMessageTimestampDifferenceMaxMs = logMessageTimestampDifferenceMaxMs;
            return this;
        }

        /**
         * Setter for logLocalRetentionMs.
         * @param  logLocalRetentionMs  Integer value for logLocalRetentionMs.
         * @return Builder
         */
        public Builder logLocalRetentionMs(Integer logLocalRetentionMs) {
            this.logLocalRetentionMs = logLocalRetentionMs;
            return this;
        }

        /**
         * Setter for logMessageDownconversionEnable.
         * @param  logMessageDownconversionEnable  Boolean value for logMessageDownconversionEnable.
         * @return Builder
         */
        public Builder logMessageDownconversionEnable(Boolean logMessageDownconversionEnable) {
            this.logMessageDownconversionEnable = logMessageDownconversionEnable;
            return this;
        }

        /**
         * Setter for saslOauthbearerSubClaimName.
         * @param  saslOauthbearerSubClaimName  String value for saslOauthbearerSubClaimName.
         * @return Builder
         */
        public Builder saslOauthbearerSubClaimName(String saslOauthbearerSubClaimName) {
            this.saslOauthbearerSubClaimName = saslOauthbearerSubClaimName;
            return this;
        }

        /**
         * Setter for maxIncrementalFetchSessionCacheSlots.
         * @param  maxIncrementalFetchSessionCacheSlots  Integer value for
         *         maxIncrementalFetchSessionCacheSlots.
         * @return Builder
         */
        public Builder maxIncrementalFetchSessionCacheSlots(
                Integer maxIncrementalFetchSessionCacheSlots) {
            this.maxIncrementalFetchSessionCacheSlots = maxIncrementalFetchSessionCacheSlots;
            return this;
        }

        /**
         * Setter for logRetentionHours.
         * @param  logRetentionHours  Integer value for logRetentionHours.
         * @return Builder
         */
        public Builder logRetentionHours(Integer logRetentionHours) {
            this.logRetentionHours = logRetentionHours;
            return this;
        }

        /**
         * Setter for groupMinSessionTimeoutMs.
         * @param  groupMinSessionTimeoutMs  Integer value for groupMinSessionTimeoutMs.
         * @return Builder
         */
        public Builder groupMinSessionTimeoutMs(Integer groupMinSessionTimeoutMs) {
            this.groupMinSessionTimeoutMs = groupMinSessionTimeoutMs;
            return this;
        }

        /**
         * Setter for socketRequestMaxBytes.
         * @param  socketRequestMaxBytes  Integer value for socketRequestMaxBytes.
         * @return Builder
         */
        public Builder socketRequestMaxBytes(Integer socketRequestMaxBytes) {
            this.socketRequestMaxBytes = socketRequestMaxBytes;
            return this;
        }

        /**
         * Setter for logSegmentBytes.
         * @param  logSegmentBytes  Integer value for logSegmentBytes.
         * @return Builder
         */
        public Builder logSegmentBytes(Integer logSegmentBytes) {
            this.logSegmentBytes = logSegmentBytes;
            return this;
        }

        /**
         * Setter for logCleanupAndCompaction.
         * @param  logCleanupAndCompaction  ConfigureLogCleanerForTopicCompaction value for
         *         logCleanupAndCompaction.
         * @return Builder
         */
        public Builder logCleanupAndCompaction(
                ConfigureLogCleanerForTopicCompaction logCleanupAndCompaction) {
            this.logCleanupAndCompaction = logCleanupAndCompaction;
            return this;
        }

        /**
         * Setter for offsetsRetentionMinutes.
         * @param  offsetsRetentionMinutes  Integer value for offsetsRetentionMinutes.
         * @return Builder
         */
        public Builder offsetsRetentionMinutes(Integer offsetsRetentionMinutes) {
            this.offsetsRetentionMinutes = offsetsRetentionMinutes;
            return this;
        }

        /**
         * Setter for logRetentionMs.
         * @param  logRetentionMs  Integer value for logRetentionMs.
         * @return Builder
         */
        public Builder logRetentionMs(Integer logRetentionMs) {
            this.logRetentionMs = logRetentionMs;
            return this;
        }

        /**
         * Builds a new {@link KafkaBrokerConfigurationValues} object using the set fields.
         * @return {@link KafkaBrokerConfigurationValues}
         */
        public KafkaBrokerConfigurationValues build() {
            return new KafkaBrokerConfigurationValues(saslOauthbearerExpectedAudience,
                    groupMaxSessionTimeoutMs, logFlushIntervalMessages,
                    saslOauthbearerJwksEndpointUrl, maxConnectionsPerIp,
                    saslOauthbearerExpectedIssuer, logIndexSizeMaxBytes, autoCreateTopicsEnable,
                    logIndexIntervalBytes, replicaFetchMaxBytes, numPartitions,
                    transactionStateLogSegmentBytes, replicaFetchResponseMaxBytes,
                    logMessageTimestampType, connectionsMaxIdleMs, logFlushIntervalMs,
                    logPreallocate, logSegmentDeleteDelayMs, messageMaxBytes,
                    groupInitialRebalanceDelayMs, logLocalRetentionBytes, logRollJitterMs,
                    transactionRemoveExpiredTransactionCleanupIntervalMs, defaultReplicationFactor,
                    logRollMs, producerPurgatoryPurgeIntervalRequests, logRetentionBytes,
                    minInsyncReplicas, compressionType, logMessageTimestampDifferenceMaxMs,
                    logLocalRetentionMs, logMessageDownconversionEnable,
                    saslOauthbearerSubClaimName, maxIncrementalFetchSessionCacheSlots,
                    logRetentionHours, groupMinSessionTimeoutMs, socketRequestMaxBytes,
                    logSegmentBytes, logCleanupAndCompaction, offsetsRetentionMinutes,
                    logRetentionMs);
        }
    }
}
