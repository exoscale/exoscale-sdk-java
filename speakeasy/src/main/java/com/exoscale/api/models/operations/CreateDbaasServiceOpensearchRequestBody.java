/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package com.exoscale.api.models.operations;

import com.exoscale.api.utils.Utils;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;


public class CreateDbaasServiceOpensearchRequestBody {

    /**
     * Maximum number of indexes to keep before deleting the oldest one
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max-index-count")
    private Optional<? extends Long> maxIndexCount;

    /**
     * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("keep-index-refresh-interval")
    private Optional<? extends Boolean> keepIndexRefreshInterval;

    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ip-filter")
    private Optional<? extends java.util.List<String>> ipFilter;

    /**
     * Service is protected against termination and powering off
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("termination-protection")
    private Optional<? extends Boolean> terminationProtection;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fork-from-service")
    private Optional<? extends String> forkFromService;

    /**
     * Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("index-patterns")
    private Optional<? extends java.util.List<IndexPatterns>> indexPatterns;

    /**
     * Automatic maintenance settings
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maintenance")
    private Optional<? extends CreateDbaasServiceOpensearchMaintenance> maintenance;

    /**
     * Template settings for all new indexes
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("index-template")
    private Optional<? extends IndexTemplate> indexTemplate;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("opensearch-settings")
    private Optional<? extends com.exoscale.api.models.components.JsonSchemaOpensearch> opensearchSettings;

    /**
     * OpenSearch major version
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("version")
    private Optional<? extends String> version;

    /**
     * Name of a backup to recover from for services that support backup names
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("recovery-backup-name")
    private Optional<? extends String> recoveryBackupName;

    /**
     * Subscription plan
     */
    @JsonProperty("plan")
    private String plan;

    /**
     * OpenSearch Dashboards settings
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("opensearch-dashboards")
    private Optional<? extends OpensearchDashboards> opensearchDashboards;

    public CreateDbaasServiceOpensearchRequestBody(
            @JsonProperty("max-index-count") Optional<? extends Long> maxIndexCount,
            @JsonProperty("keep-index-refresh-interval") Optional<? extends Boolean> keepIndexRefreshInterval,
            @JsonProperty("ip-filter") Optional<? extends java.util.List<String>> ipFilter,
            @JsonProperty("termination-protection") Optional<? extends Boolean> terminationProtection,
            @JsonProperty("fork-from-service") Optional<? extends String> forkFromService,
            @JsonProperty("index-patterns") Optional<? extends java.util.List<IndexPatterns>> indexPatterns,
            @JsonProperty("maintenance") Optional<? extends CreateDbaasServiceOpensearchMaintenance> maintenance,
            @JsonProperty("index-template") Optional<? extends IndexTemplate> indexTemplate,
            @JsonProperty("opensearch-settings") Optional<? extends com.exoscale.api.models.components.JsonSchemaOpensearch> opensearchSettings,
            @JsonProperty("version") Optional<? extends String> version,
            @JsonProperty("recovery-backup-name") Optional<? extends String> recoveryBackupName,
            @JsonProperty("plan") String plan,
            @JsonProperty("opensearch-dashboards") Optional<? extends OpensearchDashboards> opensearchDashboards) {
        Utils.checkNotNull(maxIndexCount, "maxIndexCount");
        Utils.checkNotNull(keepIndexRefreshInterval, "keepIndexRefreshInterval");
        Utils.checkNotNull(ipFilter, "ipFilter");
        Utils.checkNotNull(terminationProtection, "terminationProtection");
        Utils.checkNotNull(forkFromService, "forkFromService");
        Utils.checkNotNull(indexPatterns, "indexPatterns");
        Utils.checkNotNull(maintenance, "maintenance");
        Utils.checkNotNull(indexTemplate, "indexTemplate");
        Utils.checkNotNull(opensearchSettings, "opensearchSettings");
        Utils.checkNotNull(version, "version");
        Utils.checkNotNull(recoveryBackupName, "recoveryBackupName");
        Utils.checkNotNull(plan, "plan");
        Utils.checkNotNull(opensearchDashboards, "opensearchDashboards");
        this.maxIndexCount = maxIndexCount;
        this.keepIndexRefreshInterval = keepIndexRefreshInterval;
        this.ipFilter = ipFilter;
        this.terminationProtection = terminationProtection;
        this.forkFromService = forkFromService;
        this.indexPatterns = indexPatterns;
        this.maintenance = maintenance;
        this.indexTemplate = indexTemplate;
        this.opensearchSettings = opensearchSettings;
        this.version = version;
        this.recoveryBackupName = recoveryBackupName;
        this.plan = plan;
        this.opensearchDashboards = opensearchDashboards;
    }

    /**
     * Maximum number of indexes to keep before deleting the oldest one
     */
    public Optional<? extends Long> maxIndexCount() {
        return maxIndexCount;
    }

    /**
     * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
     */
    public Optional<? extends Boolean> keepIndexRefreshInterval() {
        return keepIndexRefreshInterval;
    }

    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    public Optional<? extends java.util.List<String>> ipFilter() {
        return ipFilter;
    }

    /**
     * Service is protected against termination and powering off
     */
    public Optional<? extends Boolean> terminationProtection() {
        return terminationProtection;
    }

    public Optional<? extends String> forkFromService() {
        return forkFromService;
    }

    /**
     * Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
     */
    public Optional<? extends java.util.List<IndexPatterns>> indexPatterns() {
        return indexPatterns;
    }

    /**
     * Automatic maintenance settings
     */
    public Optional<? extends CreateDbaasServiceOpensearchMaintenance> maintenance() {
        return maintenance;
    }

    /**
     * Template settings for all new indexes
     */
    public Optional<? extends IndexTemplate> indexTemplate() {
        return indexTemplate;
    }

    public Optional<? extends com.exoscale.api.models.components.JsonSchemaOpensearch> opensearchSettings() {
        return opensearchSettings;
    }

    /**
     * OpenSearch major version
     */
    public Optional<? extends String> version() {
        return version;
    }

    /**
     * Name of a backup to recover from for services that support backup names
     */
    public Optional<? extends String> recoveryBackupName() {
        return recoveryBackupName;
    }

    /**
     * Subscription plan
     */
    public String plan() {
        return plan;
    }

    /**
     * OpenSearch Dashboards settings
     */
    public Optional<? extends OpensearchDashboards> opensearchDashboards() {
        return opensearchDashboards;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Maximum number of indexes to keep before deleting the oldest one
     */
    public CreateDbaasServiceOpensearchRequestBody withMaxIndexCount(long maxIndexCount) {
        Utils.checkNotNull(maxIndexCount, "maxIndexCount");
        this.maxIndexCount = Optional.ofNullable(maxIndexCount);
        return this;
    }

    /**
     * Maximum number of indexes to keep before deleting the oldest one
     */
    public CreateDbaasServiceOpensearchRequestBody withMaxIndexCount(Optional<? extends Long> maxIndexCount) {
        Utils.checkNotNull(maxIndexCount, "maxIndexCount");
        this.maxIndexCount = maxIndexCount;
        return this;
    }

    /**
     * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
     */
    public CreateDbaasServiceOpensearchRequestBody withKeepIndexRefreshInterval(boolean keepIndexRefreshInterval) {
        Utils.checkNotNull(keepIndexRefreshInterval, "keepIndexRefreshInterval");
        this.keepIndexRefreshInterval = Optional.ofNullable(keepIndexRefreshInterval);
        return this;
    }

    /**
     * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
     */
    public CreateDbaasServiceOpensearchRequestBody withKeepIndexRefreshInterval(Optional<? extends Boolean> keepIndexRefreshInterval) {
        Utils.checkNotNull(keepIndexRefreshInterval, "keepIndexRefreshInterval");
        this.keepIndexRefreshInterval = keepIndexRefreshInterval;
        return this;
    }

    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    public CreateDbaasServiceOpensearchRequestBody withIpFilter(java.util.List<String> ipFilter) {
        Utils.checkNotNull(ipFilter, "ipFilter");
        this.ipFilter = Optional.ofNullable(ipFilter);
        return this;
    }

    /**
     * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
     */
    public CreateDbaasServiceOpensearchRequestBody withIpFilter(Optional<? extends java.util.List<String>> ipFilter) {
        Utils.checkNotNull(ipFilter, "ipFilter");
        this.ipFilter = ipFilter;
        return this;
    }

    /**
     * Service is protected against termination and powering off
     */
    public CreateDbaasServiceOpensearchRequestBody withTerminationProtection(boolean terminationProtection) {
        Utils.checkNotNull(terminationProtection, "terminationProtection");
        this.terminationProtection = Optional.ofNullable(terminationProtection);
        return this;
    }

    /**
     * Service is protected against termination and powering off
     */
    public CreateDbaasServiceOpensearchRequestBody withTerminationProtection(Optional<? extends Boolean> terminationProtection) {
        Utils.checkNotNull(terminationProtection, "terminationProtection");
        this.terminationProtection = terminationProtection;
        return this;
    }

    public CreateDbaasServiceOpensearchRequestBody withForkFromService(String forkFromService) {
        Utils.checkNotNull(forkFromService, "forkFromService");
        this.forkFromService = Optional.ofNullable(forkFromService);
        return this;
    }

    public CreateDbaasServiceOpensearchRequestBody withForkFromService(Optional<? extends String> forkFromService) {
        Utils.checkNotNull(forkFromService, "forkFromService");
        this.forkFromService = forkFromService;
        return this;
    }

    /**
     * Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
     */
    public CreateDbaasServiceOpensearchRequestBody withIndexPatterns(java.util.List<IndexPatterns> indexPatterns) {
        Utils.checkNotNull(indexPatterns, "indexPatterns");
        this.indexPatterns = Optional.ofNullable(indexPatterns);
        return this;
    }

    /**
     * Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
     */
    public CreateDbaasServiceOpensearchRequestBody withIndexPatterns(Optional<? extends java.util.List<IndexPatterns>> indexPatterns) {
        Utils.checkNotNull(indexPatterns, "indexPatterns");
        this.indexPatterns = indexPatterns;
        return this;
    }

    /**
     * Automatic maintenance settings
     */
    public CreateDbaasServiceOpensearchRequestBody withMaintenance(CreateDbaasServiceOpensearchMaintenance maintenance) {
        Utils.checkNotNull(maintenance, "maintenance");
        this.maintenance = Optional.ofNullable(maintenance);
        return this;
    }

    /**
     * Automatic maintenance settings
     */
    public CreateDbaasServiceOpensearchRequestBody withMaintenance(Optional<? extends CreateDbaasServiceOpensearchMaintenance> maintenance) {
        Utils.checkNotNull(maintenance, "maintenance");
        this.maintenance = maintenance;
        return this;
    }

    /**
     * Template settings for all new indexes
     */
    public CreateDbaasServiceOpensearchRequestBody withIndexTemplate(IndexTemplate indexTemplate) {
        Utils.checkNotNull(indexTemplate, "indexTemplate");
        this.indexTemplate = Optional.ofNullable(indexTemplate);
        return this;
    }

    /**
     * Template settings for all new indexes
     */
    public CreateDbaasServiceOpensearchRequestBody withIndexTemplate(Optional<? extends IndexTemplate> indexTemplate) {
        Utils.checkNotNull(indexTemplate, "indexTemplate");
        this.indexTemplate = indexTemplate;
        return this;
    }

    public CreateDbaasServiceOpensearchRequestBody withOpensearchSettings(com.exoscale.api.models.components.JsonSchemaOpensearch opensearchSettings) {
        Utils.checkNotNull(opensearchSettings, "opensearchSettings");
        this.opensearchSettings = Optional.ofNullable(opensearchSettings);
        return this;
    }

    public CreateDbaasServiceOpensearchRequestBody withOpensearchSettings(Optional<? extends com.exoscale.api.models.components.JsonSchemaOpensearch> opensearchSettings) {
        Utils.checkNotNull(opensearchSettings, "opensearchSettings");
        this.opensearchSettings = opensearchSettings;
        return this;
    }

    /**
     * OpenSearch major version
     */
    public CreateDbaasServiceOpensearchRequestBody withVersion(String version) {
        Utils.checkNotNull(version, "version");
        this.version = Optional.ofNullable(version);
        return this;
    }

    /**
     * OpenSearch major version
     */
    public CreateDbaasServiceOpensearchRequestBody withVersion(Optional<? extends String> version) {
        Utils.checkNotNull(version, "version");
        this.version = version;
        return this;
    }

    /**
     * Name of a backup to recover from for services that support backup names
     */
    public CreateDbaasServiceOpensearchRequestBody withRecoveryBackupName(String recoveryBackupName) {
        Utils.checkNotNull(recoveryBackupName, "recoveryBackupName");
        this.recoveryBackupName = Optional.ofNullable(recoveryBackupName);
        return this;
    }

    /**
     * Name of a backup to recover from for services that support backup names
     */
    public CreateDbaasServiceOpensearchRequestBody withRecoveryBackupName(Optional<? extends String> recoveryBackupName) {
        Utils.checkNotNull(recoveryBackupName, "recoveryBackupName");
        this.recoveryBackupName = recoveryBackupName;
        return this;
    }

    /**
     * Subscription plan
     */
    public CreateDbaasServiceOpensearchRequestBody withPlan(String plan) {
        Utils.checkNotNull(plan, "plan");
        this.plan = plan;
        return this;
    }

    /**
     * OpenSearch Dashboards settings
     */
    public CreateDbaasServiceOpensearchRequestBody withOpensearchDashboards(OpensearchDashboards opensearchDashboards) {
        Utils.checkNotNull(opensearchDashboards, "opensearchDashboards");
        this.opensearchDashboards = Optional.ofNullable(opensearchDashboards);
        return this;
    }

    /**
     * OpenSearch Dashboards settings
     */
    public CreateDbaasServiceOpensearchRequestBody withOpensearchDashboards(Optional<? extends OpensearchDashboards> opensearchDashboards) {
        Utils.checkNotNull(opensearchDashboards, "opensearchDashboards");
        this.opensearchDashboards = opensearchDashboards;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        CreateDbaasServiceOpensearchRequestBody other = (CreateDbaasServiceOpensearchRequestBody) o;
        return 
            java.util.Objects.deepEquals(this.maxIndexCount, other.maxIndexCount) &&
            java.util.Objects.deepEquals(this.keepIndexRefreshInterval, other.keepIndexRefreshInterval) &&
            java.util.Objects.deepEquals(this.ipFilter, other.ipFilter) &&
            java.util.Objects.deepEquals(this.terminationProtection, other.terminationProtection) &&
            java.util.Objects.deepEquals(this.forkFromService, other.forkFromService) &&
            java.util.Objects.deepEquals(this.indexPatterns, other.indexPatterns) &&
            java.util.Objects.deepEquals(this.maintenance, other.maintenance) &&
            java.util.Objects.deepEquals(this.indexTemplate, other.indexTemplate) &&
            java.util.Objects.deepEquals(this.opensearchSettings, other.opensearchSettings) &&
            java.util.Objects.deepEquals(this.version, other.version) &&
            java.util.Objects.deepEquals(this.recoveryBackupName, other.recoveryBackupName) &&
            java.util.Objects.deepEquals(this.plan, other.plan) &&
            java.util.Objects.deepEquals(this.opensearchDashboards, other.opensearchDashboards);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            maxIndexCount,
            keepIndexRefreshInterval,
            ipFilter,
            terminationProtection,
            forkFromService,
            indexPatterns,
            maintenance,
            indexTemplate,
            opensearchSettings,
            version,
            recoveryBackupName,
            plan,
            opensearchDashboards);
    }
    
    @Override
    public String toString() {
        return Utils.toString(CreateDbaasServiceOpensearchRequestBody.class,
                "maxIndexCount", maxIndexCount,
                "keepIndexRefreshInterval", keepIndexRefreshInterval,
                "ipFilter", ipFilter,
                "terminationProtection", terminationProtection,
                "forkFromService", forkFromService,
                "indexPatterns", indexPatterns,
                "maintenance", maintenance,
                "indexTemplate", indexTemplate,
                "opensearchSettings", opensearchSettings,
                "version", version,
                "recoveryBackupName", recoveryBackupName,
                "plan", plan,
                "opensearchDashboards", opensearchDashboards);
    }
    
    public final static class Builder {
 
        private Optional<? extends Long> maxIndexCount = Optional.empty();
 
        private Optional<? extends Boolean> keepIndexRefreshInterval = Optional.empty();
 
        private Optional<? extends java.util.List<String>> ipFilter = Optional.empty();
 
        private Optional<? extends Boolean> terminationProtection = Optional.empty();
 
        private Optional<? extends String> forkFromService = Optional.empty();
 
        private Optional<? extends java.util.List<IndexPatterns>> indexPatterns = Optional.empty();
 
        private Optional<? extends CreateDbaasServiceOpensearchMaintenance> maintenance = Optional.empty();
 
        private Optional<? extends IndexTemplate> indexTemplate = Optional.empty();
 
        private Optional<? extends com.exoscale.api.models.components.JsonSchemaOpensearch> opensearchSettings = Optional.empty();
 
        private Optional<? extends String> version = Optional.empty();
 
        private Optional<? extends String> recoveryBackupName = Optional.empty();
 
        private String plan;
 
        private Optional<? extends OpensearchDashboards> opensearchDashboards = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Maximum number of indexes to keep before deleting the oldest one
         */
        public Builder maxIndexCount(long maxIndexCount) {
            Utils.checkNotNull(maxIndexCount, "maxIndexCount");
            this.maxIndexCount = Optional.ofNullable(maxIndexCount);
            return this;
        }

        /**
         * Maximum number of indexes to keep before deleting the oldest one
         */
        public Builder maxIndexCount(Optional<? extends Long> maxIndexCount) {
            Utils.checkNotNull(maxIndexCount, "maxIndexCount");
            this.maxIndexCount = maxIndexCount;
            return this;
        }

        /**
         * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
         */
        public Builder keepIndexRefreshInterval(boolean keepIndexRefreshInterval) {
            Utils.checkNotNull(keepIndexRefreshInterval, "keepIndexRefreshInterval");
            this.keepIndexRefreshInterval = Optional.ofNullable(keepIndexRefreshInterval);
            return this;
        }

        /**
         * Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
         */
        public Builder keepIndexRefreshInterval(Optional<? extends Boolean> keepIndexRefreshInterval) {
            Utils.checkNotNull(keepIndexRefreshInterval, "keepIndexRefreshInterval");
            this.keepIndexRefreshInterval = keepIndexRefreshInterval;
            return this;
        }

        /**
         * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
         */
        public Builder ipFilter(java.util.List<String> ipFilter) {
            Utils.checkNotNull(ipFilter, "ipFilter");
            this.ipFilter = Optional.ofNullable(ipFilter);
            return this;
        }

        /**
         * Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
         */
        public Builder ipFilter(Optional<? extends java.util.List<String>> ipFilter) {
            Utils.checkNotNull(ipFilter, "ipFilter");
            this.ipFilter = ipFilter;
            return this;
        }

        /**
         * Service is protected against termination and powering off
         */
        public Builder terminationProtection(boolean terminationProtection) {
            Utils.checkNotNull(terminationProtection, "terminationProtection");
            this.terminationProtection = Optional.ofNullable(terminationProtection);
            return this;
        }

        /**
         * Service is protected against termination and powering off
         */
        public Builder terminationProtection(Optional<? extends Boolean> terminationProtection) {
            Utils.checkNotNull(terminationProtection, "terminationProtection");
            this.terminationProtection = terminationProtection;
            return this;
        }

        public Builder forkFromService(String forkFromService) {
            Utils.checkNotNull(forkFromService, "forkFromService");
            this.forkFromService = Optional.ofNullable(forkFromService);
            return this;
        }

        public Builder forkFromService(Optional<? extends String> forkFromService) {
            Utils.checkNotNull(forkFromService, "forkFromService");
            this.forkFromService = forkFromService;
            return this;
        }

        /**
         * Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
         */
        public Builder indexPatterns(java.util.List<IndexPatterns> indexPatterns) {
            Utils.checkNotNull(indexPatterns, "indexPatterns");
            this.indexPatterns = Optional.ofNullable(indexPatterns);
            return this;
        }

        /**
         * Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
         */
        public Builder indexPatterns(Optional<? extends java.util.List<IndexPatterns>> indexPatterns) {
            Utils.checkNotNull(indexPatterns, "indexPatterns");
            this.indexPatterns = indexPatterns;
            return this;
        }

        /**
         * Automatic maintenance settings
         */
        public Builder maintenance(CreateDbaasServiceOpensearchMaintenance maintenance) {
            Utils.checkNotNull(maintenance, "maintenance");
            this.maintenance = Optional.ofNullable(maintenance);
            return this;
        }

        /**
         * Automatic maintenance settings
         */
        public Builder maintenance(Optional<? extends CreateDbaasServiceOpensearchMaintenance> maintenance) {
            Utils.checkNotNull(maintenance, "maintenance");
            this.maintenance = maintenance;
            return this;
        }

        /**
         * Template settings for all new indexes
         */
        public Builder indexTemplate(IndexTemplate indexTemplate) {
            Utils.checkNotNull(indexTemplate, "indexTemplate");
            this.indexTemplate = Optional.ofNullable(indexTemplate);
            return this;
        }

        /**
         * Template settings for all new indexes
         */
        public Builder indexTemplate(Optional<? extends IndexTemplate> indexTemplate) {
            Utils.checkNotNull(indexTemplate, "indexTemplate");
            this.indexTemplate = indexTemplate;
            return this;
        }

        public Builder opensearchSettings(com.exoscale.api.models.components.JsonSchemaOpensearch opensearchSettings) {
            Utils.checkNotNull(opensearchSettings, "opensearchSettings");
            this.opensearchSettings = Optional.ofNullable(opensearchSettings);
            return this;
        }

        public Builder opensearchSettings(Optional<? extends com.exoscale.api.models.components.JsonSchemaOpensearch> opensearchSettings) {
            Utils.checkNotNull(opensearchSettings, "opensearchSettings");
            this.opensearchSettings = opensearchSettings;
            return this;
        }

        /**
         * OpenSearch major version
         */
        public Builder version(String version) {
            Utils.checkNotNull(version, "version");
            this.version = Optional.ofNullable(version);
            return this;
        }

        /**
         * OpenSearch major version
         */
        public Builder version(Optional<? extends String> version) {
            Utils.checkNotNull(version, "version");
            this.version = version;
            return this;
        }

        /**
         * Name of a backup to recover from for services that support backup names
         */
        public Builder recoveryBackupName(String recoveryBackupName) {
            Utils.checkNotNull(recoveryBackupName, "recoveryBackupName");
            this.recoveryBackupName = Optional.ofNullable(recoveryBackupName);
            return this;
        }

        /**
         * Name of a backup to recover from for services that support backup names
         */
        public Builder recoveryBackupName(Optional<? extends String> recoveryBackupName) {
            Utils.checkNotNull(recoveryBackupName, "recoveryBackupName");
            this.recoveryBackupName = recoveryBackupName;
            return this;
        }

        /**
         * Subscription plan
         */
        public Builder plan(String plan) {
            Utils.checkNotNull(plan, "plan");
            this.plan = plan;
            return this;
        }

        /**
         * OpenSearch Dashboards settings
         */
        public Builder opensearchDashboards(OpensearchDashboards opensearchDashboards) {
            Utils.checkNotNull(opensearchDashboards, "opensearchDashboards");
            this.opensearchDashboards = Optional.ofNullable(opensearchDashboards);
            return this;
        }

        /**
         * OpenSearch Dashboards settings
         */
        public Builder opensearchDashboards(Optional<? extends OpensearchDashboards> opensearchDashboards) {
            Utils.checkNotNull(opensearchDashboards, "opensearchDashboards");
            this.opensearchDashboards = opensearchDashboards;
            return this;
        }
        
        public CreateDbaasServiceOpensearchRequestBody build() {
            return new CreateDbaasServiceOpensearchRequestBody(
                maxIndexCount,
                keepIndexRefreshInterval,
                ipFilter,
                terminationProtection,
                forkFromService,
                indexPatterns,
                maintenance,
                indexTemplate,
                opensearchSettings,
                version,
                recoveryBackupName,
                plan,
                opensearchDashboards);
        }
    }
}

